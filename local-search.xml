<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习笔记3</title>
    <link href="/2021/10/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2021/10/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h3 id="一、垃圾回收器"><a href="#一、垃圾回收器" class="headerlink" title="一、垃圾回收器"></a>一、垃圾回收器</h3><p><img src="https://img2020.cnblogs.com/other/1218593/202006/1218593-20200617151346008-1339974706.webp" alt="垃圾收集器"></p><p><strong>相关概念</strong></p><ul><li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</li><li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上</li><li>吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）），也就是例如：虚拟机共运行100min，垃圾收集器花掉1min，那么吞吐量为99%。</li></ul><h4 id="1-串行"><a href="#1-串行" class="headerlink" title="1.串行"></a>1.串行</h4><ul><li>单线程</li><li>堆内存较小，适合个人电脑</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210092812153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="并行"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseSerialGC=serial + serialOld<br></code></pre></td></tr></table></figure><p><strong>安全点</strong>： 让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。并且该线程执行回收工作时，其他线程进入阻塞状态。</p><p><strong>serial收集器</strong>： </p><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点</strong>：单线程、简单高效（与其他收集器相的单线程相比），采用复制算法。对于限定单个CPU环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（STW）。</p><p><strong>ParNew收集器</strong></p><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在STW问题。</p><p><strong>Serial Old收集器</strong></p><p>serial old是serial收集器的老年代版本</p><p><strong>特点</strong>： 同样是单线程收集器，采用标记-整理算法。</p><h4 id="2-吞吐量优先"><a href="#2-吞吐量优先" class="headerlink" title="2.吞吐量优先"></a>2.吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核cpu</li><li>让单位时间内，STW的时间最短0.2 0.2 = 0.4</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210094915306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="吞吐量优先"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX：+UseParallelGC ~ -XX：+UsePrallerOldGC<br>-XX：+UseAdaptiveSizePolicy<br>-XX：GCTimeRatio=ratio <span class="hljs-comment">/*  1/（1+radio）*/</span><br>-XX：MaxGCPauseMillis=ms<span class="hljs-comment">// 200ms</span><br>-XX：ParallelGCThreads=n<br></code></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器</strong></p><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>： 属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）</p><p>GC自适应调节策略：</p><p>Parallel Scavenge收集器可设置 -XX：+UseAdptiveSizePocily参数</p><p>当开关打开时不需要手动设置新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRation）</p><p>晋升老年代的对象年龄（-XX：PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量</p><ul><li>XX：MaxGCPauseMillis=ms控制最大的垃圾收集停顿时间（默认200ms）</li><li>XX：GCTimeRatio= ratio直接设置吞吐量大小</li></ul><p><strong>Parallel Old收集器</strong></p><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>： 多线程，采用标记-整理算法（老年代没有幸存区）</p><h4 id="3-响应时间优先"><a href="#3-响应时间优先" class="headerlink" title="3.响应时间优先"></a>3.响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让STW的单词时间最短0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210104030390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="响应时间优先"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX：+UseConcMarkSweepGC ~ -XX：+UseParNewGC ~ SerialOld<br>-XX：ParallelGCThreads=n ~ -XX：ConcGCThreads=threads<br>-XX：CMSInitiatingOccupancyFraction=percent<br>-XX：+CMSScavengeBeforeRemark<br></code></pre></td></tr></table></figure><p><strong>CMS收集器</strong></p><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的<strong>老年代收集器</strong></p><p><strong>特点</strong>：基于标记-清理算法实现。并发收集、低停顿、但是会产生内存碎片</p><p><strong>应用场景</strong>： 适用于注重服务的相应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下，如web程序，b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步</strong><br><strong>初始标记</strong>： 标记GC Roots能直接到的对象，速度很快但是仍存在STP问题</p><p><strong>并发标记</strong>： 进行GC Roots Tracing的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>： 为了修改并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在STP问题</p><p>并发清理：对标记的对象进行清理回收，清除过程中，可能仍然会产生新的垃圾，这些垃圾称为浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为serial old收集器，将老年代的垃圾进行标记-整理，这也很消耗时间</p><p>CMS收集器的内存回收过程是与用户线程一起并发执行的，可以搭配ParNew收集器（多线程、新生代、复制算法）与Serial Old收集器（单线程、老年代、标记-整理算法）使用</p><h4 id="4-G1收集器"><a href="#4-G1收集器" class="headerlink" title="4.G1收集器"></a>4.G1收集器</h4><p><strong>定义</strong>： Garbage First</p><p><strong>使用场景</strong>： </p><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法，两个区域之间是复制算法</li></ul><p><strong>相关参数</strong></p><p>JDK8并不是默认开启的，所需要参数开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseG1GC<br>-XX:G1HeapRegionSize=size<br>-XX:MaxGCPauseMillis=time<br></code></pre></td></tr></table></figure><p><strong>G1垃圾回收阶段</strong></p><p><img src="https://img-blog.csdnimg.cn/20210210114932887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="G1垃圾回收阶段"></p><p>Young Collection：对新生代垃圾收集</p><p>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记</p><p>Mixed Collection：会对新生代+老年代+幸存区等进行混合收集，然后收集结束，会重新进入新生代收集</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>新生代存在STW</strong>：</p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制回收多少个小区间，方便控制GC产生的停顿时间</p><p>E：eden  S：幸存区  O：老年代</p><p>新生代收集会产生STW</p><p><img src="https://img-blog.csdnimg.cn/20210210122339138.gif" alt="Young Collection"></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>在Young GC时会进行GC Root的初始化标记</p><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），有下面的JVM参数决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:InitiatingHeapOccupancyPercent = percent  <span class="hljs-comment">//(默认45%)</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210122601873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Young Collection + CM"></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O进行<strong>全面的回收</strong></p><ul><li>最终标记会STW</li><li>拷贝存活会STW</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MaxGCPauseMills = xxms  <span class="hljs-comment">//用于指定最长的停顿时间</span><br></code></pre></td></tr></table></figure><p>Q:为什么有的老年代被拷贝了，有的没有？</p><p>A:因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多的内存）</p><p><img src="https://img-blog.csdnimg.cn/20210210144216170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Mixed Collection"></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><ul><li>Serial GC<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足发生的垃圾收集 - full GC</li></ul></li><li>Parallel GC<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足发生的垃圾收集 - full GC</li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足时（老年代所占内存超过阈值）<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，然后退化成serial Old收集器串行的收集，就会导致停顿的时候长。</li></ul></li></ul></li><li>G1<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足时（老年代所占内存超过阈值）<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，然后退化成serial Old收集器串行的收集，就会导致停顿的时候长</li></ul></li></ul></li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210154730275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Young Collection跨代引用"></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域为512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post -write barried + dirty card queue</li><li>concurrent  refinement threads 更新 Remembered Set</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210154940579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="跨代引用"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法54[力扣33]-搜索旋转排序数组</title>
    <link href="/2021/09/24/%E7%AE%97%E6%B3%9554-%E5%8A%9B%E6%89%A333-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/09/24/%E7%AE%97%E6%B3%9554-%E5%8A%9B%E6%89%A333-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span><br>输出：-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><strong>提示</strong>：</p><ul><li>1 &lt;= nums.length &lt;= 5000`</li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了 target</span><br>        <span class="hljs-keyword">while</span>( left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置数字 nums[mid] 等于目标值 target，那么说明找到了</span><br>            <span class="hljs-comment">// 返回当前的下标 mid</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br><br>            <span class="hljs-comment">// 否则的话需要先确定 mid 的左边还是右边为有序区间</span><br><br>            <span class="hljs-comment">// 如果当前区间最左端的值 nums[left] 小于等于 nums[mid]</span><br>            <span class="hljs-comment">// 说明从 left 到 mid 这段区间是递增的，为有序区间</span><br>            <span class="hljs-comment">// 即 mid 的左侧为有序区间，右侧为无序区间</span><br>            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid])&#123;<br><br>                <span class="hljs-comment">// 先去判断 target 是否在左侧有序区间内</span><br>                <span class="hljs-comment">// 如果目标值 target 大于这段有序区间的最小值 nums[left] 同时小于这段有序区间的最大值 nums[mid]</span><br>                <span class="hljs-comment">// 那么说明需要在这段有序区间去寻找 target </span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                    right = mid - <span class="hljs-number">1</span>;<br><br>                    <span class="hljs-comment">// 否则说明需要在 mid 的右侧无序区间搜索</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br><br>            <span class="hljs-comment">// 否则说明当前区间最左端的值 nums[left] 大于 nums[mid]</span><br>            <span class="hljs-comment">// 说明从 left 到 mid 这段区间是无序区间</span><br>            <span class="hljs-comment">// 即 mid 的左侧为无序区间，右侧为有序区间 </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 先去判断 target 是否在右侧有序区间内</span><br>                <span class="hljs-comment">// 如果目标值 target 大于这段有序区间的最小值 nums[mid] 同时小于这段有序区间的最大值 nums[right]</span><br>                <span class="hljs-comment">// 那么说明需要在这段有序区间去寻找 target </span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right])&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                    left = mid + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 否则说明需要在 mid 的左侧无序区间搜索</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                    right = mid - <span class="hljs-number">1</span>;<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 目标值不存在，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法53[力扣34]-在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2021/09/24/%E7%AE%97%E6%B3%9553-%E5%8A%9B%E6%89%A334-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/09/24/%E7%AE%97%E6%B3%9553-%E5%8A%9B%E6%89%A334-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= nums.length &lt;= 105</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>nums 是一个非递减数组</li><li>-109 &lt;= target &lt;= 109</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">// 寻找目标值在数组中的开始位置</span><br>        <span class="hljs-keyword">int</span> firstIdx = findBeginPostion(nums,target);<br><br>        <span class="hljs-comment">// 寻找目标值在数组中的结束位置</span><br>        <span class="hljs-keyword">int</span> lastIdx = findEndPostion(nums,target);<br><br>        <span class="hljs-comment">// 返回寻找的结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;firstIdx,lastIdx&#125;;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 寻找目标值在数组中的开始位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBeginPostion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">int</span> target)</span></span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了起始位置</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值等于目标值 target</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br><br>                <span class="hljs-comment">// 并且中间位置 mid 的左边没有元素，即中间位置 mid 为当前区间的起始位置</span><br>                <span class="hljs-comment">// 或者中间位置 mid 的前一个元素小于目标值 target</span><br>                <span class="hljs-comment">// 说明 mid 指向了 target 的起始位置</span><br>                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target)&#123;<br>                    <span class="hljs-comment">// mid 指向了 target 的起始位置，返回这个结果</span><br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，说明 mid 的左边依然有元素值等于 target</span><br>                <span class="hljs-comment">// 那么 mid 就不是 target 的起始位置，需要在 mid 的左边进行查找</span><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值大于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的左边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums[mid] &gt; target)&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值小于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的右边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找目标值在数组中的结束位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEndPostion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">int</span> target)</span></span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了结束位置    </span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值等于目标值 target</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-comment">// 并且中间位置 mid 的右边没有元素，即中间位置 mid 为当前区间的结束位置</span><br>                <span class="hljs-comment">// 或者中间位置 mid 的后一个元素大于目标值 target</span><br>                <span class="hljs-comment">// 说明 mid 指向了 target 的结束位置</span><br>                <span class="hljs-keyword">if</span>(mid == nums.length - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] &gt; target)&#123;<br>                    <span class="hljs-comment">// mid 指向了 target 的结束位置，返回这个结果</span><br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，说明 mid 的右边依然有元素值等于 target</span><br>                <span class="hljs-comment">// 那么 mid 就不是 target 的结束位置，需要在 mid 的右边进行查找</span><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1 ，右侧为 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值大于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的左边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums[mid] &gt; target)&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值小于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的右边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;    <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法52[力扣1]-两数之和</title>
    <link href="/2021/09/20/%E7%AE%97%E6%B3%9552-%E5%8A%9B%E6%89%A31-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/09/20/%E7%AE%97%E6%B3%9552-%E5%8A%9B%E6%89%A31-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">// 首先构建一个哈希表，用来存放数组的元素值以及索引值</span><br>        <span class="hljs-comment">// 其中 key 是数组中的元素值</span><br>        <span class="hljs-comment">// value 为数组中元素值的索引</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 接下来，遍历整个数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><br>            <span class="hljs-comment">// 目标值为 target，将 target 与 nums[i] 求差</span><br>            <span class="hljs-comment">// 获取与 nums[i] 配对的那个数 anotherNum</span><br>            <span class="hljs-keyword">int</span> anotherNum = target - nums[i];<br><br>            <span class="hljs-comment">// 判断哈希表中是否存在那个与 nums[i] 配对的数 anotherNum</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(anotherNum)) &#123;<br><br>                <span class="hljs-comment">// 由于哈希表中所有 key 都是来自于数组中，</span><br>                <span class="hljs-comment">// 所以，如果发现哈希表存在那个与 nums[i] 配对的数 anotherNum</span><br>                <span class="hljs-comment">// 也就说明数组中存在一个数，可以和 nums[i] 相加为 target</span><br>                <span class="hljs-comment">// 此时， anotherNum 这个 key 对应的 value 为这个数在数组中的索引</span><br>                <span class="hljs-comment">// 所以，返回 map.get(anotherNum) 和 i 就是这两个值的下标</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;map.get(anotherNum), i&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 如果发现哈希表中目前不存在那个与 nums[i] 配对的数 anotherNum</span><br>               <span class="hljs-comment">// 那么就把此时观察的数 nums[i] 和它的索引存放到哈希表中</span><br>               <span class="hljs-comment">// 等待后面的数能和它配对为 target</span><br>               map.put(nums[i], i);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 如果遍历完整个数组都找不到和为 target 的两个数，返回 0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法51[力扣51]-N皇后</title>
    <link href="/2021/09/20/%E7%AE%97%E6%B3%9551-%E5%8A%9B%E6%89%A351-N%E7%9A%87%E5%90%8E/"/>
    <url>/2021/09/20/%E7%AE%97%E6%B3%9551-%E5%8A%9B%E6%89%A351-N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],<br>[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">// 保存所有符合要求的解</span><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br><br>      <span class="hljs-comment">// attack 用来表示皇后的攻击范围</span><br>      <span class="hljs-keyword">int</span>[][] attack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>      <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>      <span class="hljs-keyword">char</span>[][] queen = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br><br>      <span class="hljs-comment">// 初始化二维数组 queen 中所有的元素为 &#x27;.&#x27;</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>[] c : queen) &#123;<br>         Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 初始化二维数组 attack 中所有的元素为 0</span><br>      <span class="hljs-comment">// 0 代表没有皇后能攻击得到</span><br>      <span class="hljs-comment">// 1 代表出于任意一个皇后的攻击范围内</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] c : attack) &#123;<br>          Arrays.fill(c, <span class="hljs-number">0</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 从棋盘的第 0 行第 0 列处理 n 皇后的情况</span><br>      backtrack(<span class="hljs-number">0</span>,n,queen,attack);<br><br>      <span class="hljs-comment">// 最后，返回所有符合要求的解</span><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 很显然，每一行只能放置一个皇后，所以我们每一行每一行的来放置皇后</span><br>    <span class="hljs-comment">// k 表示当前处理的行</span><br>    <span class="hljs-comment">// n 表示需要放置多少个皇后，同时也代表棋盘的大小为 n * n</span><br>    <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>    <span class="hljs-comment">// attack 用来表示皇后的攻击范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k ,<span class="hljs-keyword">int</span> n , <span class="hljs-keyword">char</span>[][] queen,<span class="hljs-keyword">int</span>[][] attack)</span></span>&#123;<br><br>        <span class="hljs-comment">// 如果发现在棋盘的最后一行放置好了皇后，那么就说明找到了一组符合要求的解</span><br>        <span class="hljs-keyword">if</span>(k == n)&#123;<br>            <span class="hljs-comment">// 由于 queen 为二维字符数组，所以需要转换为字符串数组</span><br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 遍历二维数组 queen</span><br>            <span class="hljs-comment">// 取出 queen 的每一行字符数组 c</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] c : queen) &#123;<br>                <span class="hljs-comment">// 把字符数组 c 中的所有字符转换为字符串的形式进行拼凑</span><br>                <span class="hljs-comment">// 比如 [&#x27;.&#x27;,&#x27;Q&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,]</span><br>                <span class="hljs-comment">// 转换为 &#x27;.Q..&#x27;</span><br>                <span class="hljs-comment">// 把这个字符串加入到 list 中</span><br>                list.add(String.copyValueOf(c));<br>            &#125;<br><br>            <span class="hljs-comment">// list 即为一组符合要求的解，把它加入到结果数组中</span><br>            res.add(list);<br>            <span class="hljs-comment">// 由于遍历完了所有的行，无需再遍历下去，所以返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 每一行只能放置一个皇后</span><br>        <span class="hljs-comment">// 并且每一列也只能放置一个皇后</span><br>        <span class="hljs-comment">// 所以在 k 行中，从 0 列到 n - 1 列，判断皇后应该放置到哪个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            <span class="hljs-comment">// 如果发现 attack[k][i] == 0</span><br>            <span class="hljs-comment">// 说明这个位置不在任何一个皇后的攻击范围内</span><br>            <span class="hljs-comment">// 所以可以考虑放置皇后</span><br>            <span class="hljs-keyword">if</span>(attack[k][i] == <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-comment">// 如果在 ( k , i ) 位置放置了皇后，那么就需要考虑在 k + 1 行应该怎么放置其它的皇后了</span><br>                <span class="hljs-comment">// 由于有可能在( k , i )  位置放置了皇后之后，在后续的其它行会无法再放置其它的皇后</span><br>                <span class="hljs-comment">// 那么就需要回到 ( k , i )  的状态，考虑能不能在 ( k , i + 1 )的位置放置</span><br>                <span class="hljs-comment">// 为了能够回到 ( k , i )  的状态，所以需要先记录此时的 attack</span><br>                <span class="hljs-comment">// 使用一个临时的二维数组，深度拷贝 attack</span><br>                <span class="hljs-comment">// 如果不使用深度拷贝，而是直接使用 int[][] temp = c</span><br>                <span class="hljs-comment">// 会导致 attack 发生改变是 temp 也会发生改变</span><br>                <span class="hljs-comment">// 这样也就无法保存之前的状态了</span><br>                <span class="hljs-keyword">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>                <span class="hljs-comment">// 通过两个 for 循环，把 attack 中的所有元素深度拷贝到 temp</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span> ; l &lt; n ; l++)&#123;<br>                    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span> ; m &lt; n ; m++)&#123;<br>                        temp[l][m] = attack[l][m];<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>                <span class="hljs-comment">// 那么 ( k , i )  的位置 queen[k][i] = &#x27;Q&#x27;</span><br>                queen[k][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>                <span class="hljs-comment">// 由于新放置了一个皇后，所以攻击范围又更多了</span><br>                <span class="hljs-comment">// 所以需要更新 attack 数组</span><br>                <span class="hljs-comment">// 新放置皇后的坐标为 ( k , i ) ，同样的需要更新它的八个方向</span><br>                checkQueenAttack(k,i,attack);<br><br>                <span class="hljs-comment">// 如果在 ( k , i )  位置放置了皇后，那么就需要考虑在 k + 1 行应该怎么放置其它的皇后</span><br>                <span class="hljs-comment">// 递归的调用 backtrack 在 k + 1 行放置皇后</span><br>                backtrack(k + <span class="hljs-number">1</span>,n,queen,attack);<br><br>                <span class="hljs-comment">// 递归结束后，拿走皇后，恢复 attack 的状态，考虑能不能在 ( k ,i + 1 )的位置放置</span><br>                attack = temp;<br><br>                <span class="hljs-comment">// 恢复 queen 的状态，说明此时皇后不放置在( k , i )  位置</span><br>                queen[k][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 坐标 ( x , y) 为皇后所处的位置</span><br>    <span class="hljs-comment">// 更新 attack</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkQueenAttack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x ,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span>[][] attack)</span></span>&#123;<br><br>        <span class="hljs-comment">// 对于每一个坐标 (x,y) 来说，都有上、下、左、右、左上、左下、右上、右下 八个方向</span><br>        <span class="hljs-comment">//【左上】的坐标为 (x - 1, y - 1)</span><br>        <span class="hljs-comment">//【上】的坐标为 (x - 1, y )</span><br>        <span class="hljs-comment">//【右上】的坐标为 (x + 1, y + 1)</span><br>        <span class="hljs-comment">//【左】的坐标为 (x, y + 1)</span><br>        <span class="hljs-comment">//【右】的坐标为 (x , y - 1)</span><br>        <span class="hljs-comment">//【左下】的坐标为 (x + 1, y - 1)</span><br>        <span class="hljs-comment">//【下】的坐标为 (x + 1, y)</span><br>        <span class="hljs-comment">//【右下】的坐标为 (x + 1, y + 1)</span><br>        <span class="hljs-comment">// 通过两个一维数组可以表示这八个方向</span><br>        <span class="hljs-comment">// dx 表示 x 的方向</span><br>        <span class="hljs-keyword">int</span> dx[] = &#123; -<span class="hljs-number">1</span> , -<span class="hljs-number">1</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span>  ,  <span class="hljs-number">0</span> ,  <span class="hljs-number">1</span>  , <span class="hljs-number">1</span> , <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-comment">// dy 表示 y 的方向</span><br>        <span class="hljs-keyword">int</span> dy[] = &#123; -<span class="hljs-number">1</span> , <span class="hljs-number">0</span>  , <span class="hljs-number">1</span> , -<span class="hljs-number">1</span> ,  <span class="hljs-number">1</span> ,  -<span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span> &#125;;<br><br>        <span class="hljs-comment">// 皇后所处的坐标肯定是皇后能攻击的位置，设置为 1</span><br>        attack[x][y] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 以坐标 ( x , y) 为中心，去更新它八个方向的坐标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">8</span>; j++)&#123;<br>            <span class="hljs-comment">// 由内向外的进行更新</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; attack.length ; i++)&#123;<br>                <span class="hljs-comment">// 新的位置的坐标行为 x + i * dx[j]</span><br>                <span class="hljs-keyword">int</span> nx = x + i * dx[j];<br>                <span class="hljs-comment">// 新的位置的坐标列为 y + i * dy[j]</span><br>                <span class="hljs-keyword">int</span> ny = y + i * dy[j];<br><br>                <span class="hljs-comment">// 如果新位置的坐标在 n * n 的棋盘范围内</span><br>                <span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; attack.length &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; attack.length)&#123;<br>                    <span class="hljs-comment">// 那么这些位置就是在坐标为 （x，y）的皇后的攻击范围内，更新为 1</span><br>                    attack[nx][ny] = <span class="hljs-number">1</span>;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法50[力扣55]-跳跃游戏</title>
    <link href="/2021/09/15/%E7%AE%97%E6%B3%9550-%E5%8A%9B%E6%89%A355-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/09/15/%E7%AE%97%E6%B3%9550-%E5%8A%9B%E6%89%A355-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置数组，保存每个位置如果在当前位置出发，一次性可以到达的最远位置</span><br>        <span class="hljs-comment">// 比如 nums 为 [ 2 , 4 , 5 , 3 , 1 , 0 , 6]</span><br>        <span class="hljs-comment">// 那么对于 2 来说，可以跳到最远的位置是 5 那个位置，即索引为 2 的那个位置</span><br>        <span class="hljs-comment">// 对于 4 来说，可以跳到最远的位置是 0 那个位置，即索引为 5 的那个位置</span><br>        <span class="hljs-comment">// 对于 5 来说，可以跳到最远的位置超过了数组的范围</span><br>        <span class="hljs-keyword">int</span>[] jump = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 初始化 jump</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-comment">// jump[i] 就是当前的索引值 i 加上该位置可以跳跃的最大长度 nums[i]</span><br>            jump[i] = i + nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 从数组下标为 0 的位置开始起跳，索引为 0</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置变量 maxJump，用来记录可以到达的最远位置</span><br>        <span class="hljs-comment">// 从数组下标为 0 的位置开始起跳，此时记录的最远距离为 jump[0]</span><br>        <span class="hljs-keyword">int</span> maxJump = jump[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 开始起跳</span><br>        <span class="hljs-comment">// 直到 index 到达数组尾部，index &gt;= nums.length</span><br>        <span class="hljs-comment">// 或者 index 超过 maxJump</span><br>        <span class="hljs-keyword">while</span>(index &lt; nums.length &amp;&amp; index &lt;= maxJump)&#123;<br><br>            <span class="hljs-comment">// 如果发现可以跳到的最远距离 maxJump 小于 jump[index]</span><br>            <span class="hljs-keyword">if</span>(maxJump &lt; jump[index])&#123;<br>                <span class="hljs-comment">// 那么需要更新 maxJump</span><br>                maxJump = jump[index];<br>            &#125;<br><br>            <span class="hljs-comment">// index 向前移动</span><br>            index++;<br>        &#125;<br><br>        <span class="hljs-comment">// 循环结束后，如果发现 index 的位置在数组 nums 的最后一个位置</span><br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            <span class="hljs-comment">// 说明可以到达最后一个下标</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 否则说明无法到达最后一个下标</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法49[力扣402]-移掉k位数字</title>
    <link href="/2021/09/15/%E7%AE%97%E6%B3%9549-%E5%8A%9B%E6%89%A3402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2021/09/15/%E7%AE%97%E6%B3%9549-%E5%8A%9B%E6%89%A3402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 初始化栈，用来存储需要保留的数字</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-comment">// 初始化字符串，用来保留最后的结果</span><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br><br>        <span class="hljs-comment">// 从左到右遍历字符串 num</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; num.length();i++)&#123;<br><br>            <span class="hljs-comment">// 获取此时遍历的字符</span><br>            <span class="hljs-keyword">char</span> digit = num.charAt(i);<br><br>            <span class="hljs-comment">// 如果此时</span><br>            <span class="hljs-comment">// 1、栈不为空</span><br>            <span class="hljs-comment">// 2、栈顶元素大于此时遍历的字符</span><br>            <span class="hljs-comment">// 3、还没有删除足够多的数字，即 k &gt; 0</span><br>            <span class="hljs-comment">// 那么这个时候需要把栈顶元素弹出</span><br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; digit &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 把栈顶元素弹出</span><br>                stack.pop();<br>                <span class="hljs-comment">// 记录删除的个数减 1</span><br>                k--;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果发现此时遍历的字符为 0 并且栈为空</span><br>            <span class="hljs-comment">// 那么就不要把 0 放入到栈中，否则最终的结果会以 0 开头</span><br>            <span class="hljs-keyword">if</span>(digit == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; stack.isEmpty())&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 把符合要求的字符放入到栈中</span><br>            stack.push(digit);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历完所有的字符后，如果发现还没有删除足够多的元素，那么需要继续删除</span><br>        <span class="hljs-comment">// 什么数字会出现这种情况呢？</span><br>        <span class="hljs-comment">// 比如数字为 123456789 ，删除的数字 k 为 1</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 不断的弹出栈顶元素</span><br>            stack.pop();<br>            <span class="hljs-comment">// 直到 k 为 0 位置</span><br>            k--;<br>        &#125;<br><br>        <span class="hljs-comment">// 操作完毕之后，如果发现栈为空，按上面逻辑我们会返回字符 &quot;&quot; ，</span><br>        <span class="hljs-comment">// 但根据题目的示例 3，num = &quot;10&quot;， k = 2 时，从原数字移除所有的数字，剩余为空就是 0 </span><br>        <span class="hljs-comment">// 需要返回 &quot;0&quot;</span><br>        <span class="hljs-keyword">if</span> (stack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-comment">// 如果栈中还有元素</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">// 那么从栈顶到栈底把字符添加到 result 上</span><br>            result.append(stack.peek());<br>            <span class="hljs-comment">// 同时不断的弹出栈顶元素</span><br>            stack.pop();<br>        &#125;<br><br>        <span class="hljs-comment">// 由于 stack 中的栈底是数字的最高位，栈顶是最低位</span><br>        <span class="hljs-comment">// 所以此时 result 保存的顺序是最低位到最高位</span><br>        <span class="hljs-comment">// 需要执行一次翻转操作</span><br>        <span class="hljs-keyword">return</span> result.reverse().toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法48[力扣860]-柠檬水找零</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9548-%E5%8A%9B%E6%89%A3860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9548-%E5%8A%9B%E6%89%A3860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。</p><p>你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 用来记录 5 元钞票的数量</span><br>        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 用来记录 10 元钞票的数量</span><br>        <span class="hljs-keyword">int</span> ten = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 顾客开始按顺序购买，并找零</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; bills.length ; i++)&#123;<br>            <span class="hljs-comment">// 1、如果发现是 5 元面额</span><br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-comment">// 那么可以直接收钱，不需要找零</span><br>                <span class="hljs-comment">// 并且 5 元钞票的数量加 1</span><br>                five++;<br><br>                <span class="hljs-comment">// 2、如果发现是 10 元面额</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">10</span>)&#123;<br><br>                <span class="hljs-comment">// 如果手中有 5 元钞票，则找零 5 元</span><br>                <span class="hljs-keyword">if</span>(five &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 5 元钞票的数量减 1</span><br>                    five--;<br>                    <span class="hljs-comment">// 10 元钞票的数量加 1</span><br>                    ten++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果手中没有 5 元钞票，说明找零失败</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 3、如果发现是 20 元面额</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 如果手中有 10 元 和 5 元钞票，则找零 1 张 10 元和 1 张 5 元的钞票</span><br>                <span class="hljs-keyword">if</span>(ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 5 元钞票的数量减 1</span><br>                    five--;<br>                    <span class="hljs-comment">// 10 元钞票的数量减 1</span><br>                    ten--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果手中只有 5 元的，并且数量超过或者等于 3 张</span><br>                    <span class="hljs-comment">// 那么找零 3 张 5 元的钞票</span><br>                    <span class="hljs-keyword">if</span>(five &gt;= <span class="hljs-number">3</span>)&#123;<br>                        <span class="hljs-comment">// 5 元钞票的数量减 3</span><br>                        five -= <span class="hljs-number">3</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">// 说明这个时候顾客付 20 元的时候</span><br>                        <span class="hljs-comment">// 1、手中没有 1 张 10 元的和 1 张 5 元的</span><br>                        <span class="hljs-comment">// 2、手中没有 3 张 5 元的</span><br>                        <span class="hljs-comment">// 说明找零失败</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有顾客都找零了，成功</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法47[力扣455]-分发饼干</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9547-%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9547-%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。<strong>如果</strong> <strong>s[j] &gt;= g[i]<strong>，我们可以将这个饼干</strong>j</strong> 分配给孩子<strong>i</strong>，这个孩子会得到满足。</p><p>你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、将孩子们的胃口值按照从小到大的顺序排列</span><br>        <span class="hljs-comment">// 优先满足胃口小的孩子</span><br>        Arrays.sort(g);<br><br>        <span class="hljs-comment">// 2、将饼干按照从小到大的顺序排列</span><br>        Arrays.sort(s);<br><br>        <span class="hljs-comment">// child 代表 g 的下标，即表示有多少孩子的胃口得到满足</span><br>        <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// child 代表 s 的下标，即表示目前有多少饼干被使用了</span><br>        <span class="hljs-keyword">int</span> cookie = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历所有的饼干</span><br>        <span class="hljs-comment">// 遍历过后，饼干只有两种状态</span><br>        <span class="hljs-comment">// 1、要么找到了需要这个饼干的孩子</span><br>        <span class="hljs-comment">// 2、要么剩下的孩子中，胃口值最低的孩子都大于这个饼干的值，那么这个饼干没人要</span><br>        <span class="hljs-keyword">while</span>(cookie &lt; s.length &amp;&amp; child &lt; g.length)&#123;<br><br>            <span class="hljs-comment">// 孩子的胃口得到了满足</span><br>            <span class="hljs-keyword">if</span>(s[cookie] &gt;= g[child])&#123;<br>                <span class="hljs-comment">// 得到满足的孩子数量加 1</span><br>                child++;<br>            &#125;<br><br>            <span class="hljs-comment">// 查看下一个饼干能否找到需要的孩子</span><br>            cookie++;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回孩子数量</span><br>        <span class="hljs-keyword">return</span> child;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法46[力扣416]-分割等和子集</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9546-%E5%8A%9B%E6%89%A3416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9546-%E5%8A%9B%E6%89%A3416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 使用 sum 来保存数组中全部元素的和</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历 nums 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-comment">// 把 nums 数组上的所有元素值累加到 sum 上</span><br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 如果发现 sum 为奇数，那么必然无法拆分为两个相等的整数</span><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 所以无法将这个数组分割成两个子集，返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 获取数组中全部元素之后的一半</span><br>        <span class="hljs-comment">// 接下来需要在数组 nums 中寻找一些数字去拼凑为 target</span><br>        <span class="hljs-comment">// 如果能找到一些数字之和为 target，那么剩下的数字之和也是 target</span><br>        <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>        <span class="hljs-comment">// dp[0][0] 表示 nums 的前 0 个元素能否可以组成和为 0 的结果</span><br>        <span class="hljs-comment">// dp[2][6] 表示 nums 的前 2 个元素能否可以组成和为 6 的结果</span><br>        <span class="hljs-comment">// dp[n - 1][target ] 表示 nums 的前 n - 1 个元素能否可以组成和为 target 的结果</span><br>        <span class="hljs-comment">// i 的值从 0 到 n - 1</span><br>        <span class="hljs-comment">// j 的值从 0 到 target</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][target + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 先初始化  dp[0][nums[0]]</span><br>        <span class="hljs-comment">// 如果 nums 的第 0 个元素 nums[0] 小于 target</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= target) &#123;<br>            <span class="hljs-comment">// 那么 nums 的前 0 个元素能否可以组成和为 nums[0] 的结果是 true</span><br>            <span class="hljs-comment">// 因为 nums 的前 0 个元素就是 nums[0]</span><br>            dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 接下来开始往 dp 数组中填充结果</span><br>        <span class="hljs-comment">// i 的值从 1 到 n - 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// j 的值从 0 到 target</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;<br>                <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>                <span class="hljs-comment">// dp[i - 1][j] 表示 nums 的前 i - 1 个元素能否可以组成和为 j 的结果</span><br>                <span class="hljs-comment">// 对于 dp[i][j] 来说，如果 dp[i - 1][j] 为 true，那么 dp[i][j] 必然也为 true</span><br>                <span class="hljs-comment">// 所以，先初始化 dp[i][j] 的值为 dp[i - 1][j] 的值</span><br>                <span class="hljs-comment">// 再通过后面的代码修改 dp[i][j] 中还为 false 的值 </span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><br>                <span class="hljs-comment">// 如果此时 nums[i] 恰巧为 j</span><br>                <span class="hljs-comment">// 那么对于 dp[i][j] 来说，nums 的前 i 个元素可以组成和为 j 的结果</span><br>                <span class="hljs-keyword">if</span> (nums[i] == j) &#123;<br>                    <span class="hljs-comment">// 所以 dp[i][j] 为 true</span><br>                    dp[i][j] = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-comment">// 同时继续</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果发现 nums[i] 小于 j</span><br>                <span class="hljs-keyword">if</span> (nums[i] &lt; j) &#123;<br>                    <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>                    <span class="hljs-comment">// dp[i - 1][j] 表示 nums 的前 i - 1 个元素能否可以组成和为 j 的结果</span><br>                    <span class="hljs-comment">// dp[i - 1][j - nums[i]] 表示 nums 的前 i - 1 个元素能否可以组成和为 j - nums[i] 的结果</span><br>                    <span class="hljs-comment">// 那么 dp[i][j] 的结果要为 true</span><br>                    <span class="hljs-comment">// 1、nums 的前 i - 1 个元素可以组成和为 j </span><br>                    <span class="hljs-comment">// 2、nums 的前 i - 1 个元素可以组成和为 j - nums[i]</span><br>                    <span class="hljs-comment">// 对于 1 来说，不用使用 nums[i] 就组成了 j</span><br>                    <span class="hljs-comment">// 对于 2 来说，前 i - 1 个元素可以组成和为 j - nums[i]，那么加上此时的值 nums[i]，也组成了 j</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[n - 1][target ] 表示 nums 的前 n - 1 个元素能否可以组成和为 target 的结果</span><br>        <span class="hljs-comment">// 返回这个结果</span><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][target];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法45[力扣279]-完全平方数</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9545-%E5%8A%9B%E6%89%A3279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9545-%E5%8A%9B%E6%89%A3279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 <strong>最少数量</strong></p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 设置一个数组，用来存储小于 n 的那些完全平方数</span><br>        List&lt;Integer&gt; square = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 通过一个下标来计算</span><br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 直到 idx * idx 超过了 n 为止</span><br>        <span class="hljs-keyword">while</span> (idx * idx &lt;= n) &#123;<br>            <span class="hljs-comment">// square 存储小于 n 的那些完全平方数</span><br>            square.add(idx * idx);<br><br>            <span class="hljs-comment">// idx 累加</span><br>            idx++;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[0] 表示数字 0  需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// dp[1] 表示数字 0  需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// dp[i] 表示数字 i  需要完全平方数的最少数量</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">1</span> ];<br><br>        <span class="hljs-comment">// 先让 dp 初始化为 -1，代表 dp[i] 还没有计算</span><br>        Arrays.fill(dp,-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// dp[0] 表示数字 0  需要完全平方数的最少数量</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 开始填充 dp[]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ;i++)&#123;<br><br>            <span class="hljs-comment">// 在每次填充的过程中，都去遍历 square 数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ;j &lt; square.size();j++)&#123;<br>                <span class="hljs-comment">// 如果发现此时 square 的元素值大于了 i</span><br>                <span class="hljs-comment">// 那么 square 后面的那些元素没有必要参与进来计算 i 了</span><br>                <span class="hljs-comment">// 直接退出当前的 j 的循环判断，让 i++</span><br>                <span class="hljs-keyword">if</span>(square.get(j) &gt; i)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，如果 dp[i] 还没有找到数字 i 需要完全平方数的最少数量</span><br>                <span class="hljs-comment">// 或者此时计算的新值更小，那么更新 dp[i]</span><br>                <span class="hljs-keyword">if</span>(dp[i] == -<span class="hljs-number">1</span> || dp[i] &gt; dp[i-square.get(j)] + <span class="hljs-number">1</span>)&#123;<br><br>                    <span class="hljs-comment">// 更新 dp[i]</span><br>                    <span class="hljs-comment">// dp[i] 表示数字 i  需要完全平方数的最少数量</span><br>                    <span class="hljs-comment">// 这个时候 dp[i] 为获取数字为 square.get(j) 的那 1 个完全平方数</span><br>                    <span class="hljs-comment">// 加上获取数字为 i-square.get(j) 最少需要 dp[i-square.get(j)] 个数</span><br>                    dp[i] = dp[i-square.get(j)] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[n] 表示数字 n 需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// 返回这个结果就行</span><br>        <span class="hljs-keyword">return</span> dp[n];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法44[力扣300]-最长递增子序列</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9544-%E5%8A%9B%E6%89%A3300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9544-%E5%8A%9B%E6%89%A3300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置数组 dp，用来存储 nums 中以每个元素结尾的最长递增序列的程度</span><br>        <span class="hljs-comment">// dp[0] 表示以 nums[0] 结尾的最长递增序列的长度</span><br>        <span class="hljs-comment">// dp[1] 表示以 nums[1] 结尾的最长递增序列的长度</span><br>        <span class="hljs-comment">// dp[i] 表示以 nums[i] 结尾的最长递增序列的长度</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 首先将数组 dp 里面的值都初始化为 1</span><br>        <span class="hljs-comment">// 1 表示以当前元素结尾的最长递增序列的长度为 1</span><br>        <span class="hljs-comment">// 即最长递增序列就是当前元素本身</span><br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个变量用来存储最长递增序列的结果</span><br>        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从 1 开始，直到 dp.length ，往 dp 里面填充结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; dp.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 对于 dp[i] 来说，在 nums 中从 0 到 i - 1 都是在 i 的前面的</span><br>            <span class="hljs-comment">// 比如 nums 为 [1,5,2,5,3,7,2]</span><br>            <span class="hljs-comment">// 此时 i 为 3，那么 1,5,2 这些数字都在索引位置为 3 的前面</span><br>            <span class="hljs-comment">// 从 0 遍历到 i - 1，就可以从这些数字中选出小于 i 的数字</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i ;j++)&#123;<br><br>                <span class="hljs-comment">// 索引      0  1  2  3  4  5  6</span><br>                <span class="hljs-comment">// nums 为 [ 1, 5, 2, 5, 3, 7, 2 ]</span><br>                <span class="hljs-comment">// 此时 i 为 3，那么 1,5,2 这些数字都在索引位置为 3 的前面</span><br>                <span class="hljs-comment">// 1、从这些数字中选出小于 nums[i] 的数字</span><br>                <span class="hljs-comment">// 2、小于 nums[i] 的那些数字是 1 , 2 ，在之前都已经计算过以 1 或者 2 结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 并且这个结果存放在 dp[j] 中</span><br>                <span class="hljs-comment">// 如果数字为 1，那么此时 j 为 0，dp[0] 存放了以 1  结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 如果数字为 2，那么此时 j 为 2，dp[2] 存放了以 2  结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 3、如果发现此时 dp[i] 小于了 dp[j] + 1</span><br>                <span class="hljs-comment">// 4、说明此时 dp[i] 中的值就不是以 nums[i] 结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 需要更新 dp[i]</span><br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 4、更新 dp[i]</span><br>                    dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 在更新 dp[i] 的过程中，发现了一个更长的子序列</span><br>            <span class="hljs-keyword">if</span>(maxLength &lt; dp[i])&#123;<br>                <span class="hljs-comment">// 那么把更长的子序列的长度赋值给 maxLength</span><br>                maxLength = dp[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 maxLength 就行</span><br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法43[力扣322]-零钱兑换</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9543-%E5%8A%9B%E6%89%A3322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9543-%E5%8A%9B%E6%89%A3322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 初始化数组 dp，长度为 amount + 1，因为在 dp 数组中还会存储金额为 0 的情况</span><br>        <span class="hljs-comment">// dp[i] 表示想要凑齐 i 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[0] 表示想要凑齐 0 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[1] 表示想要凑齐 1 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[14] 表示想要凑齐 14 元需要的最少硬币个数</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 首先将数组 dp 里面的值都初始化为 -1</span><br>        <span class="hljs-comment">// -1 表示当前的金额还没有找到需要的最少硬币个数</span><br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 想要凑齐 0 元的最少硬币个数是 0 个</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 依次计算想要凑齐 1 元到 amount 的最少硬币个数是多少</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= amount ; i++)&#123;<br><br>            <span class="hljs-comment">// 对于每个金额 i 来说，coins 中的每个面值小于 i 的硬币都可以尝试去拼凑 i</span><br>            <span class="hljs-comment">// 比如 i = 8 ，coins 为 [1,2,5,7,10]</span><br>            <span class="hljs-comment">// 其中 1，2，5，7 都小于 8</span><br>            <span class="hljs-comment">// 1 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 2 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 5 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 7 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 所以，设置一个变量 j ，遍历数组 coins</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; coins.length;j++)&#123;<br><br>                <span class="hljs-comment">// 1、如果当前的硬币面值 coins[j] 小于了 i，表示这枚硬币有可能可以拼凑到 i</span><br>                <span class="hljs-comment">// 2、那么 i - coins[j] 表示面值 coins[j] 的硬币想要拼凑 i 需要那些面值的硬币金额</span><br>                <span class="hljs-comment">// 3、而 dp[i-coins[j]] 表示想要凑齐 i - coins[j] 元需要的最少硬币个数</span><br>                <span class="hljs-comment">// 4、如果 dp[i-coins[j]] != -1 ，表示想要凑齐 i - coins[j] 元需要的最少硬币个数有结果</span><br>                <span class="hljs-keyword">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != -<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 这个时候，对于金额 i 来说</span><br>                    <span class="hljs-comment">// 1、如果它之前还没有找到凑齐 i 元需要的最少硬币个数</span><br>                    <span class="hljs-comment">// 2、如果此时计算的最少硬币个数比之前保存的结果 dp[i] 更小</span><br>                    <span class="hljs-comment">// 那么更新 dp[i]</span><br>                    <span class="hljs-keyword">if</span>(dp[i] == -<span class="hljs-number">1</span> || dp[i-coins[j]] + <span class="hljs-number">1</span> &lt; dp[i])&#123;<br>                        <span class="hljs-comment">// 更新 dp[i]</span><br>                        <span class="hljs-comment">// dp[i] 表示想要凑齐 i 元需要的最少硬币个数</span><br>                        <span class="hljs-comment">// 这个时候 dp[i] 为获取面值为 j 的那 1 个硬币</span><br>                        <span class="hljs-comment">// 加上获取面值为 i - coins[j] 最少需要 dp[i - coins[j]] 个硬币</span><br>                        dp[i] = dp[i - coins[j]] + <span class="hljs-number">1</span>;<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[amount] 表示想要凑齐 amount 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// 返回这个结果就行</span><br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法42[力扣72]-编辑距离</title>
    <link href="/2021/09/13/%E7%AE%97%E6%B3%9542-%E5%8A%9B%E6%89%A372-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/09/13/%E7%AE%97%E6%B3%9542-%E5%8A%9B%E6%89%A372-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>1、插入一个字符</li><li>2、删除一个字符</li><li>3、替换一个字符</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 获取字符串 word1 的长度</span><br>        <span class="hljs-keyword">int</span> L1 = word1.length();<br><br>        <span class="hljs-comment">// 获取字符串 word2 的长度</span><br>        <span class="hljs-keyword">int</span> L2 = word2.length();<br><br>        <span class="hljs-comment">// 设置二维数组 dp 用来储存 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][0] 表示 word1 的前 0 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][j] 表示 word1 的前 0 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][0] 表示 word1 的前 i 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[L1][L2] 表示 word1 的前 L1 个字符转换为 word2 的前 L2 个字符最少操作数</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[L1 + <span class="hljs-number">1</span>][L2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// dp[i][0] 表示 word1 的前 i 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][0] 相当于给二维数组 dp 的第一列进行赋值操作</span><br>        <span class="hljs-comment">// 只需要每次执行删除操作，就可以把 word1 的字符删除到 0 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;= L1 ; i++)&#123;<br>            <span class="hljs-comment">// dp[1][0] 表示需要删除 1 次才能删除到 0 个字符</span><br>            <span class="hljs-comment">// dp[2][0] 表示需要删除 2 次才能删除到 2 个字符</span><br>            <span class="hljs-comment">// dp[i][0] 表示需要删除 i 次才能删除到 2 个字符</span><br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[0][j] 表示 word1 的前 0 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][j] 相当于给二维数组 dp 的第一行进行赋值操作</span><br>        <span class="hljs-comment">// 只需要每次执行插入操作，就可以把 word1 的字符转行为 j 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ;j &lt;= L2 ; j++)&#123;<br>            <span class="hljs-comment">// dp[0][1] 表示需要插入 1 次才能得到 1 个字符</span><br>            <span class="hljs-comment">// dp[0][2] 表示需要插入 2 次才能得到 2 个字符</span><br>            <span class="hljs-comment">// dp[0][j] 表示需要插入 j 次才能得到 j 个字符</span><br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 通过两个 for 循环，设置二维数组 dp 中的所有元素的值</span><br>        <span class="hljs-comment">// i 从 word1 的第 1 个字符一直到 L1 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= L1 ; i++)&#123;<br><br>            <span class="hljs-comment">// j 从 word2 的第 1 个字符一直到 L2 个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt;= L2 ; j++)&#123;<br><br>                <span class="hljs-comment">// 二维数组 dp 的下标是从 (0,0) 开始的</span><br>                <span class="hljs-comment">// 所以 dp[i][j] 表示的是 word1 中前 i 个字符即位置为 i - 1 的字符</span><br>                <span class="hljs-comment">// 转换为 word2 中前 j 个字符即位置为 j - 1 的字符所需要的最少操作数</span><br>                <span class="hljs-comment">// 如果此时 word1 中第 i - 1 个位置的字符（即当前遍历 i 时的字符）</span><br>                <span class="hljs-comment">// 与 word2 中第 j - 1 个位置的字符【相等】（即当前遍历 j 时的字符）</span><br>                <span class="hljs-comment">// 说明 word1 的前 i - 1 个字符转换为 word2 中前 j - 1 个字符成功后，</span><br>                <span class="hljs-comment">// word1 的前 i 个字符也就成功转换为 word2 的前 j 个字符了</span><br>                <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br><br>                    <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>                    <span class="hljs-comment">// dp[i - 1][j - 1] 表示 word1 的前 i - 1 个字符转换为 word2 的前 j -1 个字符最少操作数</span><br>                    <span class="hljs-comment">// 比如 word1 为 abcd，word2 为 efgd</span><br>                    <span class="hljs-comment">// 此时 i = 4，j = 4</span><br>                    <span class="hljs-comment">// 由于 word1.charAt(4 - 1) = d</span><br>                    <span class="hljs-comment">// word2.charAt(4 - 1) = d</span><br>                    <span class="hljs-comment">// 所以如果知道了 abc 转换为 efg 的最少操作数，那么结果也就出来了</span><br>                    <span class="hljs-comment">// d --&gt; d 不需要执行任何操作</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br>                    <span class="hljs-comment">// 否则，说明 word1 中第 i - 1 个位置的字符（即当前遍历 i 时的字符）</span><br>                    <span class="hljs-comment">// 与 word2 中第 j - 1 个位置的字符【不相等】（即当前遍历 j 时的字符）</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 那么 dp[i][j]  可以从以下三种状态转换过来</span><br>                    <span class="hljs-comment">// 1、word1(L1-1) ——&gt; word2(L2-1)</span><br>                    <span class="hljs-comment">// 2、word1(L1-1) ——&gt; word2(L2)</span><br>                    <span class="hljs-comment">// 3、word1(L1) ——&gt; word2(L2-1)</span><br>                    <span class="hljs-comment">// word1(L1-1) ——&gt; word2(L2-1) 的最少操作数是 dp[i - 1][j - 1]</span><br>                    <span class="hljs-comment">// word1(L1-1) ——&gt; word2(L2) 的最少操作数是 dp[i - 1][j]</span><br>                    <span class="hljs-comment">// word1(L1) ——&gt; word2(L2-1) 的最少操作数是 dp[i][j - 1])</span><br>                    <span class="hljs-comment">// 选这三种状态的较小值后，</span><br>                    <span class="hljs-comment">// 1、如果是 word1(L1-1) ——&gt; word2(L2-1) 过来的，再执行 1 次替换操作</span><br>                    <span class="hljs-comment">// 2、如果是 word1(L1-1) ——&gt; word2(L2)   过来的，再执行 1 次删除操作</span><br>                    <span class="hljs-comment">// 3、如果是 word1(L1) ——&gt; word2(L2-1)   过来的，再执行 1 次插入操作</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>],Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp[L1][L2] 表示 word1 的前 L1 个字符转换为 word2 的前 L2 个字符最少操作数</span><br>        <span class="hljs-comment">// 把这个结果进行返回</span><br>        <span class="hljs-keyword">return</span> dp[L1][L2];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法41[力扣64]-最小路径和</title>
    <link href="/2021/09/13/%E7%AE%97%E6%B3%9541-%E5%8A%9B%E6%89%A364-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/09/13/%E7%AE%97%E6%B3%9541-%E5%8A%9B%E6%89%A364-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br><br>        <span class="hljs-comment">// m 表示有多少行</span><br>        <span class="hljs-keyword">int</span> m = grid.length;<br><br>        <span class="hljs-comment">// n 表示每一行有多少个元素，即 n 表示有多少列</span><br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 设置二维数组 dp 用来储存每个位置的最优解</span><br>        <span class="hljs-comment">// dp[0][0] 表示第 0 行第 0 列的最优解</span><br>        <span class="hljs-comment">// dp[0][i] 表示第 0 行第 i 列的最优解</span><br>        <span class="hljs-comment">// dp[j][0] 表示第 j 行第 0 列的最优解</span><br>        <span class="hljs-comment">// dp[i][j] 表示第 i 行第 j 列的最优解</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-comment">// 初始化 dp[0][0]，由于只有一个元素</span><br>        <span class="hljs-comment">// 所以 dp[0][0] 的最优解就是 grid[0][0] 这个元素</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// i 从 1 遍历到 n - 1 </span><br>        <span class="hljs-comment">// 获取第 0 行中第 i 列的最优解</span><br>        <span class="hljs-comment">// 比如 grid[0] 为 [1,3,2...]</span><br>        <span class="hljs-comment">// 由于每次只能向下或者向右移动一步，此时只能向右移动一步</span><br>        <span class="hljs-comment">// 那么 dp[0][i] 依次为 [1,4,6...]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n ; i++)&#123;<br>            <span class="hljs-comment">// 所以对于只有一行的情况，当前位置的最优解等于前一列的最优解加上该列的值</span><br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];<br>        &#125;<br><br>        <span class="hljs-comment">// i 从 1 遍历到 n - 1 </span><br>        <span class="hljs-comment">// 获取第 i 行中第 0 列的最优解</span><br>        <span class="hljs-comment">// 比如 grid 为 </span><br>        <span class="hljs-comment">// [1,1,2.......]</span><br>        <span class="hljs-comment">// [5,2,2.......]</span><br>        <span class="hljs-comment">// [2,3,4.......]</span><br>        <span class="hljs-comment">// [..,..,..,...]</span><br>        <span class="hljs-comment">// 由于每次只能向下或者向右移动一步，此时只能向下移动一步</span><br>        <span class="hljs-comment">// 那么 dp[i][0] 就是</span><br>        <span class="hljs-comment">// [1,..........]</span><br>        <span class="hljs-comment">// [6,..........]</span><br>        <span class="hljs-comment">// [7,..........]</span><br>        <span class="hljs-comment">// [............]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m ;i++)&#123;<br>            <span class="hljs-comment">// 所以对于只有一列的情况，当前位置的最优解等于前一行的最优解加上该行的值</span><br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 接下来从第 1 行到第 m - 1 行</span><br>        <span class="hljs-comment">// 从第 1 列到底 n - 1 列</span><br>        <span class="hljs-comment">// 填充二维数组 dp 里面的值</span><br>        <span class="hljs-comment">// dp[i][j] 表示第 i 行第 j 列的最优解</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-comment">// 由于每次只能向下或者向右移动一步</span><br>                <span class="hljs-comment">// 位置 (i,j) 的最优解</span><br>                <span class="hljs-comment">// 等于当前位置上方位置(i-1,j)的最优解和左侧位置(i,j-1)的最优解的较小值</span><br>                <span class="hljs-comment">// 再加上当前位置的值</span><br>                dp[i][j] =  Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j] ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[m-1][n-1] 表示第 m - 1 行第 n - 1 列的最优解</span><br>        <span class="hljs-comment">// 返回这个结果即可</span><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法40[力扣120]-三角形最小路径和</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9540-%E5%8A%9B%E6%89%A3120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9540-%E5%8A%9B%E6%89%A3120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标</strong> <strong>+ 1</strong> 的两个结点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br><br>        <span class="hljs-comment">// triangle 是个二维数组</span><br>        <span class="hljs-comment">// 先获取 triangle 的层数，即一维数组的个数</span><br>        <span class="hljs-keyword">int</span> n  = triangle.size();<br><br>        <span class="hljs-comment">// 设置一个一维数组，动态的更新每一层中当前节点对应的最短路径</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">1</span> ];<br><br>        <span class="hljs-comment">// 从最后一层开始计算节点的最短路径，直到顶层 0 层为止</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i-- )&#123;<br>            <span class="hljs-comment">// dp 中存储的是前 i 个位置存储的是到达第 i 层各个节点的最小路径和</span><br>            <span class="hljs-comment">// 从每一层的第 0 个位置开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt;= i ; j++)&#123;<br>                <span class="hljs-comment">// dp[j] 表示第 i 层中第 j 个节点的最小路径和</span><br>                dp[j] = triangle.get(i).get(j) + Math.min(dp[j],dp[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法39[力扣198]-打家劫舍</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9539-%E5%8A%9B%E6%89%A3198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9539-%E5%8A%9B%E6%89%A3198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一</strong>晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 先获取全部房间的总数</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 如果数组为空，表示没有房间，那么自然偷不到东西，直接返回 0</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 如果数组只有 1 个元素，表示只有 1 个房间，那么只能偷这个房间的东西，直接返回这个房间的金额</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 设置一个数组 value 用来存放前 n 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[0] 表示前 0 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[1] 表示前 1 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[i] 表示前 i 个房间可以偷取的最大金额</span><br>        <span class="hljs-keyword">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// value[0] 表示前 0 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// 0 个房间自然偷不到东西，所以存放结果为 0</span><br>        value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// value[1] 表示前 1 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// 只有 1 个房间，那么只能偷这个房间的东西，所以存放结果为这个房间的金额</span><br>        value[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 从 i = 2 直到 i = n，value 中存放的结果由前 i - 2 和 i - 1 共同决定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i++)&#123;<br><br>            <span class="hljs-comment">// 转移方程：value[i] 等于 value[ i - 1 ]  和 value[ i - 2 ] + num[ i - 1] 中的较大值</span><br>            value[i] = Math.max(value[i - <span class="hljs-number">1</span>] ,value[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 value 的最后一个值</span><br>        <span class="hljs-keyword">return</span> value[n];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法38[力扣53]-最大子序数和</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9538-%E5%8A%9B%E6%89%A353-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E6%95%B0%E5%92%8C/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9538-%E5%8A%9B%E6%89%A353-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E6%95%B0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 因为后面会使用到 nums 的长度</span><br>        <span class="hljs-comment">// 所以先进行判空操作</span><br>        <span class="hljs-comment">// 如果数组 nums 为空，返回 0</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 设置一个数组 dp，长度和数组 nums 长度一致</span><br>        <span class="hljs-comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// dp[1] 表示以第 1 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// dp[i] 表示以第 i 个元素结尾的最大子数组的和</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// 初始化 dp[0]</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 变量 maxNum 表示数组 dp 中最大的那个值</span><br>        <span class="hljs-comment">// 即 maxNum 表示最大的连续字段和</span><br>        <span class="hljs-keyword">int</span> maxNum = dp[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 从 1 开始遍历数组 nums</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ;i++)&#123;<br><br>            <span class="hljs-comment">// 在遍历的过程中，去获取以第 i 个元素结尾的最大子数组的和</span><br>            <span class="hljs-comment">// 如果以 nums[i-1]结尾的最大字段和为正数</span><br>            <span class="hljs-comment">// 那么以第 i 个元素结尾的最大子数组的和就是自己本身加上以 nums[i-1]结尾的最大字段和</span><br>            <span class="hljs-keyword">if</span>(dp[i-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// dp[i-1] 是正数</span><br>                <span class="hljs-comment">// 所以 dp[i] 的值为 nums[i] 加上 dp[i-1]</span><br>                <span class="hljs-comment">// 因为 正数 + 变量 &gt; 变量</span><br>                <span class="hljs-comment">// dp[i -1] + nums[i] &gt; nums[i]</span><br>                dp[i] = dp[i -<span class="hljs-number">1</span>] + nums[i];<br><br>                <span class="hljs-comment">// 否则 dp[i-1] 不是正数，为负数或者 0</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 那么 dp[i] 的值为 nums[i]</span><br>                <span class="hljs-comment">// 因为 负数 + 变量 &lt; 变量</span><br>                <span class="hljs-comment">// dp[i -1] + nums[i] &lt; nums[i]</span><br>                dp[i] = nums[i];<br>            &#125;<br><br>            <span class="hljs-comment">// 在更新 dp[i] 的过程中，更新 maxNum 的值</span><br>            <span class="hljs-comment">// 如果此时 dp[i] 的值大于了 maxNum</span><br>            <span class="hljs-keyword">if</span>(maxNum &lt; dp[i])&#123;<br>                <span class="hljs-comment">// 那么 maxNum 更新为 dp[i]</span><br>                maxNum = dp[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 maxNum</span><br>        <span class="hljs-keyword">return</span> maxNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法37[力扣70]-爬楼梯</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9537-%E5%8A%9B%E6%89%A370-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9537-%E5%8A%9B%E6%89%A370-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 使用数组 dp 存储每一级台阶的爬法数量</span><br>        <span class="hljs-comment">// 由于后面初始化 dp[1] 和 dp[2] </span><br>        <span class="hljs-comment">// 为了让当 n = 0 时不越界，保证 dp[1] 和 dp[2] 都有值</span><br>        <span class="hljs-comment">// 所以 dp 的长度为 n + 2</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 初始化 dp[1] 和 dp[2] </span><br>        <span class="hljs-comment">// 一级台阶只有一种爬法</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 二级台阶有两种爬法</span><br>        <span class="hljs-comment">// 一种爬法是先爬 1 个台阶，再爬 1 个台阶</span><br>        <span class="hljs-comment">// 一种爬法是爬 2 个台阶</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 从 3 开始循环至 n，计算 dp[3] 至 dp[n]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 第 i 级台阶的结果 dp[i] 等于第 i-1 和 i-2 的结果之和</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 n 级台阶的结果</span><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法36[力扣450]-删除二叉搜索树中的节点</title>
    <link href="/2021/09/04/%E7%AE%97%E6%B3%9536-%E5%8A%9B%E6%89%A3450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/09/04/%E7%AE%97%E6%B3%9536-%E5%8A%9B%E6%89%A3450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>1、首先找到需要删除的节点；</p><p>2、如果找到了，删除它。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、如果 root 为空，那么直接返回空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果 root 的节点值等于需要删除的值，那么需要根据以下几种情况进行处理</span><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br><br>            <span class="hljs-comment">// 情况 1：当前节点的左子树为空，那么当前节点 root 由 root 的右子树占位就行</span><br>            <span class="hljs-comment">// 比如 key 为 8</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     7</span><br>            <span class="hljs-comment">//           \</span><br>            <span class="hljs-comment">//            8</span><br>            <span class="hljs-comment">// 直接将以 8 作为根节点的二叉树挪到 7 的位置</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     8</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br><br>            <span class="hljs-comment">// 情况 2：当前节点的右子树为空，那么当前节点 root 由 root 的左子树占位就行</span><br>            <span class="hljs-comment">// 比如 key 为 2</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     7</span><br>            <span class="hljs-comment">//   /        </span><br>            <span class="hljs-comment">//  1          </span><br>            <span class="hljs-comment">// 直接将以 1 作为根节点的二叉树挪到 2 的位置</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    1     7</span><br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br><br>            <span class="hljs-comment">// 情况 3：被删除节点既有左子树，又有右子树</span><br>            <span class="hljs-comment">// 比如 key 为 7</span><br>            <span class="hljs-comment">//          5</span><br>            <span class="hljs-comment">//       /     \</span><br>            <span class="hljs-comment">//      2       6</span><br>            <span class="hljs-comment">//    /   \       \</span><br>            <span class="hljs-comment">//   1     4       7</span><br>            <span class="hljs-comment">//        /</span><br>            <span class="hljs-comment">//       3</span><br>            <span class="hljs-comment">// 需要找到右子树最小的值，或者左子树中最大的值</span><br>            <span class="hljs-comment">// 这里我们去找右子树最小的值，为 3</span><br>            TreeNode minNodeOfRight = findMinNode(root.right);<br><br>            <span class="hljs-comment">// 找到右子树最小的值之后，修改当前节点 root 的值为右子树最小的值</span><br>            root.val = minNodeOfRight.val;<br><br>            <span class="hljs-comment">// 同时，记得删除掉 root 的右子树最小的值之</span><br>            <span class="hljs-comment">// 删除操作就是以 root 作为根节点，key 为右子树最小的值进行删除</span><br>            root.right = deleteNode(root.right, minNodeOfRight.val);<br><br>          <span class="hljs-comment">// 3、如果 root 的节点值小于需要删除的值，那么就在 root 的右子树中去查找</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>            <span class="hljs-comment">// 在 root 的右子树中去查找并删除 key </span><br>            root.right = deleteNode(root.right, key);<br><br>          <span class="hljs-comment">// 4、如果 root 的节点值大于需要删除的值，那么就在 root 的左子树中去查找</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>            <span class="hljs-comment">// 在 root 的左子树中去查找并删除 key </span><br>            root.left = deleteNode(root.left, key);<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回需要已经删除了 key 的二叉树的根节点</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过 findMinNode ，可以找到二叉搜索树中最小的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">findMinNode</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 由于二叉搜索树，左子树所有元素的值都小于根节点的值</span><br>        <span class="hljs-comment">// 所以可以不断的查找，直到为叶子节点，那么就找到了</span><br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 不断的去查找当前节点的左子树</span><br>            node = node.left;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回当前二叉搜索树中最小的元素</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法35[力扣236]-二叉树的最近公共祖先</title>
    <link href="/2021/09/04/%E7%AE%97%E6%B3%9535-%E5%8A%9B%E6%89%A3236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/09/04/%E7%AE%97%E6%B3%9535-%E5%8A%9B%E6%89%A3236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>最近公共祖先</strong>的定义为：“对于有根树 T 的两个节点 <strong>p</strong>、<strong>q</strong>，最近公共祖先表示为一个节点 x，满足 x 是 <strong>p</strong>、<strong>q</strong> 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、如果此时访问的节点 root 为 null，那么直接返回 null</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果此时访问的节点 root 为指定节点 p，那么返回 p 这个节点</span><br>        <span class="hljs-keyword">if</span>(root == p)  <span class="hljs-keyword">return</span> p;<br><br>        <span class="hljs-comment">// 3、如果此时访问的节点 root 为指定节点 q，那么返回 q 这个节点</span><br>        <span class="hljs-keyword">if</span>(root == q) <span class="hljs-keyword">return</span> q;<br><br>        <span class="hljs-comment">// 4、经过上面 1、2、3 的判断之后，root 这个节点必然不是 p、q、null 这三种情况的节点</span><br>        <span class="hljs-comment">// 接下来，去递归的判断当前节点 root 的左右子树是否包含 p 、q 这两个指定节点</span><br><br><br>        <span class="hljs-comment">// 5、递归的去查找 root 的左子树，判断是否包含p 、q 这两个指定节点</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中包含 p，那么 left 的值就是 p</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中包含 q，那么 left 的值就是 q</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中既不包含 p，也不包含 q，那么 left 的值就是 null</span><br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br><br><br>        <span class="hljs-comment">// 6、递归的去查找 root 的右子树，判断是否包含p 、q 这两个指定节点</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中包含 p，那么 right 的值就是 p</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中包含 q，那么 right 的值就是 q</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中既不包含 p，也不包含 q，那么 right 的值就是 null</span><br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br><br><br>        <span class="hljs-comment">// 7、判断完当前节点 root 、 root 的左子树 left、root 的右子树 right 的情况后</span><br>        <span class="hljs-comment">// 开始向父节点传递信息</span><br><br>        <span class="hljs-comment">// 8、如果 root 节点的左子树 left 和右子树 right 都没有找到指定节点 p、q</span><br>        <span class="hljs-comment">// 并且 root 自己本身也不是指定节点 p、q</span><br>        <span class="hljs-comment">// 那么它给父节点传递的信息就是以 root 为根节点的那颗二叉树没有指定节点 p、q </span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 null，告诉 root 的父节点，这里没找到指定节点 p、q</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 9、如果在 root 节点的左子树 left 中没有找到指定节点 p、q </span><br>        <span class="hljs-comment">// 那么以 root 为根节点的那颗二叉树能不能找到指定节点 p、q  完全取决于 right 了</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 right ，告诉 root 的父节点，能不能找到指定节点 p、q  完全取决于 right </span><br>            <span class="hljs-keyword">return</span> right;<br><br>        <span class="hljs-comment">// 10、如果在 root 节点的右子树 right 中没有找到指定节点 p、q </span><br>        <span class="hljs-comment">// 那么以 root 为根节点的那颗二叉树能不能找到指定节点 p、q  完全取决于 left 了</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 left ，告诉 root 的父节点，能不能找到指定节点 p、q  完全取决于 left </span><br>            <span class="hljs-keyword">return</span> left;<br><br>        <span class="hljs-comment">// 11、此时，left != null 并且 right != null</span><br>        <span class="hljs-comment">// 这说明在以 root 节点为根节点的那棵二叉树中找到了指定节点 p ，也找到了指定节点 q </span><br>        <span class="hljs-comment">// 那么就告诉父节点，root 就是 p、q 的最近公共祖先</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-comment">// 返回 root ，告诉 root 的父节点，root 就是 p、q 的最近公共祖先</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法34[力扣114]-二叉树展开为链表</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9534-%E5%8A%9B%E6%89%A3114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9534-%E5%8A%9B%E6%89%A3114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>1、展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</p><p>2、展开后的单链表应该与二叉树<strong>先序遍历</strong>顺序相同。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        backtrack(root);<br>    &#125;<br><br>    <span class="hljs-comment">// 传入二叉树的节点，把它转换为链表的形式，返回二叉树的尾节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br><br>        <span class="hljs-comment">// 1、如果 node 为空，返回 null</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果 node 为叶子节点，返回 node</span><br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> node;<br><br>        <span class="hljs-comment">// 下面开始设置几个指针</span><br><br>        <span class="hljs-comment">// 3、left 为当前节点 node 的左子树</span><br>        TreeNode left = node.left;<br><br>        <span class="hljs-comment">// 4、right 为当前节点 node 的右子树</span><br>        TreeNode right = node.right;<br><br>        <span class="hljs-comment">// 5、leftTail 指向当前节点左子树 left 转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode leftTail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 6、rightTail 指向当前节点右子树 right 转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode rightTail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 7、tail 指向以当前节点 node 为根节点转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode tail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 8、先将 node 的左子树指针置空</span><br>        <span class="hljs-comment">// 将 node 的左子树转换为链表之后，node 的右指针指向那个链表</span><br>        node.left = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 9、如果当前节点存在左子树的时候，那么把左子树转换为链表的形式</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 backtrack 函数递归的把当前节点的左子树转换为链表</span><br>            <span class="hljs-comment">// backtrack 函数指向完之后，left 已经是链表</span><br>            <span class="hljs-comment">// 根据第 5 点的代码，leftTail 指向左子树最后一个节点</span><br>            leftTail = backtrack(left);<br><br>            <span class="hljs-comment">// 此时，node 的左子树 left 已经是链表的形式</span><br>            <span class="hljs-comment">// 那么将当前节点 node 的 right 指针指向 left，完成了当前节点和左子树链表的拼接</span><br>            node.right = left;<br><br>            <span class="hljs-comment">// 根据第 7 ，tail 指向左子树最后一个节点</span><br>            tail = leftTail;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 10、如果当前节点存在右子树的时候，那么把左子树转换为链表的形式</span><br>        <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 backtrack 函数递归的把当前节点的右子树转换为链表</span><br>            <span class="hljs-comment">// backtrack 函数指向完之后，right 已经是链表</span><br>            <span class="hljs-comment">// 根据第 6 点的代码，rightTail 指向右子树最后一个节点</span><br>            rightTail = backtrack(right);<br><br>            <span class="hljs-comment">// 此时，node 的右子树 right 已经是链表的形式</span><br>            <span class="hljs-comment">// 如果当前节点 node 不存在左子树，那么 node.left = null</span><br>            <span class="hljs-comment">// 由于 node 的右指针就是 right，所以不需要执行其它操作</span><br>            <span class="hljs-comment">// 但如果存在左子树，就需要把 left 链表和 right 链表串联起来</span><br>            <span class="hljs-comment">// 也就是把 left 链表的尾节点和 right 的头节点拼接起来</span><br>            <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 将 leftTail 和 right 转换成的链表链接起来</span><br>                leftTail.right = right;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果存在右子树，那么根据第 7 点的代码，tail 指向右子树最后一个节点</span><br>            tail = rightTail;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回链表的尾节点位置继续去拼接其它的递归链表</span><br>        <span class="hljs-keyword">return</span> tail;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法33[力扣538]-把二叉搜索树转换为累加树</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9533-%E5%8A%9B%E6%89%A3538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9533-%E5%8A%9B%E6%89%A3538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">// 定义一个变量，用来记录已经访问的所有节点值的总和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、从根节点开始，修改二叉树上的每一个节点的值</span><br>        modify(root);<br><br>        <span class="hljs-comment">// 返回修改后的二叉树的根节点</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 按照右根左的顺序，遍历二叉树上的每一个节点，将每个节点的值累加到 sum 上面</span><br>    <span class="hljs-comment">// 同时把 sum 累加到当前节点上</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(TreeNode node )</span></span>&#123;<br><br>        <span class="hljs-comment">// 如果当前节点为空，那么就不需要计算了</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-comment">// 2、去修改当前节点的右子树上面的节点</span><br>        <span class="hljs-comment">// 修改的过程中，会不断的累加当前节点右子树上所有的节点值之和</span><br>        modify(node.right);<br><br>        <span class="hljs-comment">// 3、把当前节点右子树上所有的节点值之和在加上当前节点的值更新到 sum 上</span><br>        sum += node.val;<br><br>        <span class="hljs-comment">// 4、 修改当前节点的值为 sum</span><br>        node.val = sum;<br><br>        <span class="hljs-comment">// 5、去修改当前节点的左子树上面的节点</span><br>        <span class="hljs-comment">// 修改的过程中，会不断的累加当前节点左子树上所有的节点值之和</span><br>        modify(node.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法32[力扣108]-将有序数组转换为二叉搜索树</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9532-%E5%8A%9B%E6%89%A3108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9532-%E5%8A%9B%E6%89%A3108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><h3 id="二、代码参考"><a href="#二、代码参考" class="headerlink" title="二、代码参考"></a>二、代码参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> toBST(nums,<span class="hljs-number">0</span>,nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 将升序排序数组 nums，从下标 begin 到 end 的部分元素转换为平衡二叉排序树</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">toBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span>&#123;<br><br>        <span class="hljs-comment">// 整个递归的终止条件是 begin 的位置超过了 end</span><br>        <span class="hljs-comment">// 比如对于排序数组 [ 7，8 ]，它的起始位置 begin 为 0，结束位置 end 为 1</span><br>        <span class="hljs-comment">// 所以 mid 为 （ 0 + 1 ）/ 2 = 0</span><br>        <span class="hljs-comment">// 这个时候根据 mid 的位置划分为两个子区域</span><br>        <span class="hljs-comment">// [begin , mid - 1] 和 [ mid + 1 , end ]</span><br>        <span class="hljs-comment">// 即 7 的左区域位置为 [ 0 ，-1]，这个区域的 begin 为 0 ，end 为 -1</span><br>        <span class="hljs-comment">// 所以返回 null，结束了递归</span><br>        <span class="hljs-comment">// 很直观的可以看到对于排序数组 [ 7，8 ]来说，在数组中没有小于 7 的元素</span><br>        <span class="hljs-keyword">if</span>(begin &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 获取从 begin 到 end 排序数组中中间元素的下标</span><br>        <span class="hljs-keyword">int</span> mid = (begin + end) / <span class="hljs-number">2</span> ;<br><br>        <span class="hljs-comment">// 获取以 mid 下标的元素</span><br>        <span class="hljs-comment">// 把这个元素作为转换后的二叉树根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br><br>        <span class="hljs-comment">// 递归的将 mid 左侧所有元素转换为平衡二叉排序树</span><br>        TreeNode left = toBST(nums,begin,mid - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归的将 mid 右侧所有元素转换为平衡二叉排序树</span><br>        TreeNode right = toBST(nums,mid + <span class="hljs-number">1</span>,end);<br><br>        <span class="hljs-comment">// 将 mid 左侧所有元素转换为平衡二叉排序树后作为 root 的左子树</span><br>        root.left = left;<br><br>        <span class="hljs-comment">// 将 mid 右侧所有元素转换为平衡二叉排序树后作为 root 的右子树</span><br>        root.right = right;<br><br>        <span class="hljs-comment">// 返回转换好的平衡二叉排序树</span><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法31[力扣113]-路径总和Ⅱ</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9531-%E5%8A%9B%E6%89%A3113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9531-%E5%8A%9B%E6%89%A3113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> targetSum) &#123;<br><br>        <span class="hljs-comment">// 构建一个 value，用来计算当前路径下节点的总和</span><br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 构建一个 path，用来记录满足条件的路径</span><br>        List&lt;List&lt;Integer&gt;&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个栈，用来保存当前路径下的节点</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 从根节点开始搜索</span><br>        search(root,value,targetSum,stack,path);<br><br>        <span class="hljs-comment">// 返回满足条件的路径</span><br>        <span class="hljs-keyword">return</span> path;<br><br>    &#125;<br><br>    <span class="hljs-comment">// node 为正在遍历的节点</span><br>    <span class="hljs-comment">// value 为栈中各个节点值的总和</span><br>    <span class="hljs-comment">// targetSum 为目标路径的和</span><br>    <span class="hljs-comment">// stack 存储该路径上的所有节点</span><br>    <span class="hljs-comment">// path 存储满足条件，即路径上的各个节点之和为 targetSum 的那些路径</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">int</span> targetSum ,Stack&lt;Integer&gt; stack,List&lt;List&lt;Integer&gt;&gt; path)</span></span>&#123;<br><br>            <span class="hljs-comment">// 如果节点为空，那么就不需要再访问下去了</span><br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 将当前访问节点的值累加到 value 上</span><br>            value += node.val;<br><br>            <span class="hljs-comment">// 把当前的节点值添加到栈中，栈中保存的就是从根节点到当前节点的路径</span><br>            stack.push(node.val);<br><br>            <span class="hljs-comment">// 如果当前节点的左子树为空</span><br>            <span class="hljs-comment">// 并且当前节点的右子树也为空</span><br>            <span class="hljs-comment">// 即当前节点为叶子节点</span><br>            <span class="hljs-comment">// 同时当前路径下的节点值之和 value 与目标值 targetSum 相等</span><br>            <span class="hljs-comment">// 说明找到了一条符合条件的路径</span><br>            <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span> &amp;&amp; value == targetSum)&#123;<br><br>                <span class="hljs-comment">// 把这条路径添加到 path 中</span><br>                path.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(stack));<br>            &#125;<br><br>            <span class="hljs-comment">// 继续递归的搜索当前节点 node 的左子树</span><br>            search(node.left,value,targetSum,stack,path);<br><br>            <span class="hljs-comment">// 继续递归的搜索当前节点 node 的右子树</span><br>            search(node.right,value,targetSum,stack,path);<br><br>            <span class="hljs-comment">// 搜索完当前节点的左右子树之后，当前节点已经完成了访问，需要返回到它的父节点</span><br>            <span class="hljs-comment">// 所以 value 减去当前节点的值</span><br>            value -= node.val;<br><br>            <span class="hljs-comment">// 栈也弹出当前的节点值</span><br>            stack.pop();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法30[力扣199]-二叉树的右视图</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9530-%E5%8A%9B%E6%89%A3199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9530-%E5%8A%9B%E6%89%A3199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树的 <strong>根节点</strong> root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置一个数组用来存储二叉树的右视图结果</span><br>        <span class="hljs-comment">// 题目要求存储的是节点的值，所以类型是 Integer</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个队列，用来保存二叉树每一层的节点</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 边界判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;<br><br>        <span class="hljs-comment">// 首先，把二叉树的根节点加入到队列中</span><br>        que.add(root);<br><br>        <span class="hljs-comment">// 观察队列是否为空</span><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br><br>            <span class="hljs-comment">// 1、获取队列的长度</span><br>            <span class="hljs-keyword">int</span> levelSize = que.size();<br><br>            <span class="hljs-comment">// 2、通过一个循环，获取队列中每个节点的左右子树，把这些左右子树节点也添加到队列中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) &#123;<br><br>                <span class="hljs-comment">// 3、弹出队列的队首元素</span><br>                TreeNode node = que.poll();<br><br>                <span class="hljs-comment">// 4、判断弹出的节点是否有左子树</span><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果有左子树，把它加入到队列中</span><br>                    que.add(node.left);<br>                &#125;<br><br>                <span class="hljs-comment">// 5、判断弹出的节点是否有右子树</span><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果有右子树，把它加入到队列中</span><br>                    que.add(node.right);<br>                &#125;<br><br>                <span class="hljs-comment">// 对于每一层的二叉树节点，我们是从左到右依次添加，所以末尾的节点的顺序是 levelSize - 1</span><br>                <span class="hljs-comment">// 6、这个末尾的节点就是这一层中最右侧的节点 </span><br>                <span class="hljs-keyword">if</span> (i == levelSize - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 把最右侧的节点值加入到结果中</span><br>                    list.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法29[力扣105]-根据前序与中序遍历序列构造二叉树</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9529-%E5%8A%9B%E6%89%A3105-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9529-%E5%8A%9B%E6%89%A3105-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 题目中说 preorder 和 inorder 均无重复元素</span><br>        <span class="hljs-comment">// 通过哈希表把中序遍历序列中的值和顺序建立映射关系</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 通过 for 循环，遍历完中序遍历序列中的所有元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>             <span class="hljs-comment">// 以中序序列中的元素值 inorder[i] 作为 key</span><br>             <span class="hljs-comment">// 以位置 i 作为 value</span><br>             <span class="hljs-comment">// 存放到哈希表中</span><br>             <span class="hljs-comment">// 比如中序遍历序列中的元素是 [   A  ,   D  ,   E  ,   F  ,   G  ,   H  ,   M  ,   Z  ]</span><br>             <span class="hljs-comment">// 那么这个哈希表就是以下的样子</span><br>             <span class="hljs-comment">// | 索引 | 位置  |</span><br>             <span class="hljs-comment">// | A | 0  |</span><br>             <span class="hljs-comment">// | D | 1  |</span><br>             <span class="hljs-comment">// | E | 2  | </span><br>             <span class="hljs-comment">// | F | 3  | </span><br>             <span class="hljs-comment">// | G | 4  | </span><br>             <span class="hljs-comment">// | H | 5  | </span><br>             <span class="hljs-comment">// | M | 6  | </span><br>             <span class="hljs-comment">// | Z | 7  |            </span><br>             map.put(inorder[i], i);<br>        &#125;<br><br>        <span class="hljs-comment">// 下面开始构建二叉树</span><br>        <span class="hljs-comment">// 把前序遍历序列中的第一个元素 preorder[0] 作为二叉树的根节点</span><br>        <span class="hljs-comment">// 因为任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br><br><br>        <span class="hljs-comment">// 继续遍历前序遍历序列中的其它元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; preorder.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 把当前遍历的元素构造为一个二叉树的节点</span><br>            TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[i]);<br><br>            <span class="hljs-comment">// 把构造的节点插入到以 root 为根节点的二叉树中</span><br>            insertNode(root,node,map);<br><br>        &#125;<br><br>        <span class="hljs-comment">// 当 preorder 中所有元素都构造并且插入完毕之后</span><br>        <span class="hljs-comment">// 二叉树就完成了构建</span><br>        <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// root : 二叉树的根节点</span><br>    <span class="hljs-comment">// node : 待插入的节点</span><br>    <span class="hljs-comment">// map : 节点值和中序遍历序列位置的映射</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(TreeNode root,TreeNode node,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;<br><br>            <span class="hljs-comment">// 当 root 和 node 指向的节点相同时，跳出循环</span><br>            <span class="hljs-keyword">while</span>(root != node)&#123;<br><br>                <span class="hljs-comment">// 如果 node 的中序遍历序列位置小于 root 的中序遍历序列位置</span><br>                <span class="hljs-comment">// 说明 node 应该在 root 的左子树中</span><br>                <span class="hljs-keyword">if</span>(map.get(node.val) &lt; map.get(root.val))&#123;<br><br>                    <span class="hljs-comment">// 如果此时 root 没有左子树</span><br>                    <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>                        <span class="hljs-comment">// 那么就把 node 设置为 root 的左子树</span><br>                        root.left = node;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 1、如果之前 root 没有左子树，那么通过上面的代码，就设置好了 root 的左子树</span><br>                    <span class="hljs-comment">// 也就是说 node 是 root 的一个叶子节点，完成了插入操作</span><br>                    <span class="hljs-comment">// 把 root 指向 root.left 后，root 为 node，跳出了循环</span><br><br>                    <span class="hljs-comment">// 2、如果之前 root 已经有左子树，那么就不能直接把 node 插入到 root 的左子树上</span><br>                    <span class="hljs-comment">// 需要判断应该把 node 插入到 root 左子树上的孩子节点的那个位置上</span><br>                    <span class="hljs-comment">// 比如现在的 root 是这个样子，node 为 A</span><br>                    <span class="hljs-comment">//        G</span><br>                    <span class="hljs-comment">//       /</span><br>                    <span class="hljs-comment">//      D</span><br>                    <span class="hljs-comment">//     /  \</span><br>                    <span class="hljs-comment">//    ①   ②</span><br>                    <span class="hljs-comment">// root 已经有左子树 D 了，所以 node 应该考虑插入到 D 中的 ① 还是 ② 上面</span><br>                    <span class="hljs-comment">// 所以，把 root 指向 root.left ，继续遍历 root 的左子树的情况</span><br>                    root = root.left;<br><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 如果 node 的中序遍历序列位置大于 root 的中序遍历序列位置</span><br>                    <span class="hljs-comment">// 说明 node 应该在 root 的右子树中</span><br><br>                    <span class="hljs-comment">// 如果此时 root 没有右子树</span><br>                    <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>)&#123;<br>                        <span class="hljs-comment">// 那么就把 node 设置为 root 的右子树</span><br>                        root.right = node;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 把 root 指向 root.right ，继续遍历 root 的右子树的情况</span><br>                    root = root.right;<br><br>                &#125;<br><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法28一套模板解决二叉树的前序、中序、后序遍历</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9528%E4%B8%80%E5%A5%97%E6%A8%A1%E6%9D%BF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9528%E4%B8%80%E5%A5%97%E6%A8%A1%E6%9D%BF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序、中序、后序</strong> 遍历。</p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树前序遍历的结果</span><br>        List&lt;Integer&gt; preorderReslut = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树中序遍历的结果</span><br>        List&lt;Integer&gt; inorderResult = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树后序遍历的结果</span><br>        List&lt;Integer&gt; postorderResult = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个栈，用来保存路径</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个节点，一开始指向根节点</span><br>        TreeNode node = root;<br><br>        <span class="hljs-comment">// 设置三种状态，方便表示当前遍历当前节点的时候进行到哪一步了</span><br>        <span class="hljs-comment">// 每个节点都有 左、右、上 这三种状态</span><br>        <span class="hljs-comment">// 按照 左 --&gt; 右 --&gt; 上 的顺序观察每个节点</span><br><br>        <span class="hljs-comment">// 左代表该节点的左右孩子节点都没有遍历</span><br>        <span class="hljs-keyword">int</span> nodeLeft = <span class="hljs-number">100</span>;<br><br>        <span class="hljs-comment">// 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历</span><br>        <span class="hljs-keyword">int</span> nodeRight = <span class="hljs-number">200</span>;<br><br>        <span class="hljs-comment">// 上代表左右孩子节点都已经遍历，需要返回到它的父节点</span><br>        <span class="hljs-keyword">int</span> nodeUp = <span class="hljs-number">300</span>;<br><br>        <span class="hljs-comment">// 每个节点的初始化状态都是从 左 开始</span><br>        <span class="hljs-keyword">int</span> nodeState = nodeLeft;<br><br><br>        <span class="hljs-comment">// 对二叉树进行遍历</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 位置 ① </span><br><br>            <span class="hljs-comment">// 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历</span><br>            <span class="hljs-keyword">if</span>(nodeState == nodeLeft)&#123;<br>                <span class="hljs-comment">// 把当前节点加入到二叉树前序遍历的结果数组中</span><br>                preorderReslut.add(node.val);<br><br>                <span class="hljs-comment">// 如果当前节点有左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br><br>                    <span class="hljs-comment">// 先把当前节点加入到栈中，用来记录节点移动的路径</span><br>                    stack.push(node);<br><br>                    <span class="hljs-comment">// 开始观察当前节点的左孩子节点，代码来到了位置 ① </span><br>                    node = node.left;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 如果当前节点没有左子树，切换当前节点的状态为【右】</span><br>                    <span class="hljs-comment">// 代码来到了位置 ① </span><br>                    nodeState = nodeRight;<br>                &#125;<br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nodeState == nodeRight)&#123; <span class="hljs-comment">// 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历</span><br><br>                <span class="hljs-comment">// 把当前节点加入到二叉树中序遍历的结果数组中</span><br>                <span class="hljs-comment">// inorderResult.add(node.val);</span><br><br>                <span class="hljs-comment">// 如果当前节点有右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br><br>                    <span class="hljs-comment">// 先把当前节点加入到栈中，用来记录节点移动的路径</span><br>                    stack.push(node);<br><br>                    <span class="hljs-comment">// 开始观察当前节点的右孩子节点</span><br>                    node = node.right;<br><br>                    <span class="hljs-comment">// 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态</span><br>                    nodeState = nodeLeft;<br><br>                    <span class="hljs-comment">// 执行完上面三行代码，代码来到了位置 ①     </span><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果当前节点没有右子树，切换当前节点的状态为【上】</span><br>                    <span class="hljs-comment">// 代码来到了位置 ①</span><br>                    nodeState = nodeUp;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nodeState == nodeUp)&#123; <span class="hljs-comment">// 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点</span><br>                <span class="hljs-comment">// 把当前节点加入到二叉树后序遍历的结果数组中</span><br>                <span class="hljs-comment">//postorderResult.add(node.val);</span><br><br>                <span class="hljs-comment">// 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点</span><br>                <span class="hljs-comment">// 首先构建一个空的节点</span><br>                TreeNode parent = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-comment">// 如果栈中有元素</span><br>                <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br><br>                    <span class="hljs-comment">// 那么，栈顶元素就是当前节点的父节点</span><br>                    parent = stack.pop();<br><br>                    <span class="hljs-comment">// 判断一下父节点的左节点是否为当前节点</span><br>                    <span class="hljs-comment">// 比如这颗二叉树</span><br>                    <span class="hljs-comment">//           1</span><br>                    <span class="hljs-comment">//         /   \</span><br>                    <span class="hljs-comment">//        2     3</span><br>                    <span class="hljs-comment">//       / \     \</span><br>                    <span class="hljs-comment">//      4   5     6</span><br>                    <span class="hljs-comment">//  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】</span><br>                    <span class="hljs-comment">//  如果当前节点是 5 ，那么 5 的父节点是 2，2 的左孩子节点是 4，此时不需要切换状态</span><br><br>                    <span class="hljs-comment">// 如果父节点的左节点为当前节点</span><br>                    <span class="hljs-keyword">if</span>(parent.left == node)&#123;<br>                        <span class="hljs-comment">// 切换当前节点的状态为【右】</span><br>                        nodeState = nodeRight;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 开始观察当前节点的父节点</span><br>                <span class="hljs-comment">// 如果上述代码中栈中有元素，那么 parent 有值，代码来到了位置 ①</span><br>                <span class="hljs-comment">// 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环</span><br>                node = parent;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 根据题目要求，返回二叉树前序、中序、后序遍历的结果</span><br>        <span class="hljs-keyword">return</span> preorderReslut;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法27[力扣102]-二叉树的层序遍历</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9527-%E5%8A%9B%E6%89%A3102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9527-%E5%8A%9B%E6%89%A3102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 设置 res 用来保存输出结果</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 边界情况处理</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-comment">// 设置一个队列，用来存储二叉树中的元素</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 队列添加二叉树的根节点</span><br>        queue.add(root);<br><br>        <span class="hljs-comment">// 遍历队列，直到队列为空，说明访问了二叉树中所有的节点</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;  <br>            <span class="hljs-comment">// 用来记录 queue 的长度，即每层节点的个数</span><br>            <span class="hljs-keyword">int</span> size = queue.size();  <br><br>            <span class="hljs-comment">// 用来保存每一层节点，保存成功后添加到 res 中</span><br>            List&lt;Integer&gt; temp =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br><br>            <span class="hljs-comment">// 使用 for 循环，将 queue 中的元素添加的 temp 中</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size ;  i++ )&#123;     <br>                <span class="hljs-comment">// 从 queue 中取出一个节点         </span><br>                TreeNode node = queue.poll();  <br>                <span class="hljs-comment">// 把节点存放到 list 中</span><br>                temp.add(node.val);  <span class="hljs-comment">//将节点值加入list</span><br><br>                <span class="hljs-comment">// 判断当前节点的左子节点是否有值，如果有，则添加到 queue 中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)<br>                    queue.add(node.left);<br><br>                <span class="hljs-comment">// 判断当前节点的右子节点是否有值，如果有，则添加到 queue 中    </span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)<br>                    queue.add(node.right);<br>            &#125;<br><br>            <span class="hljs-comment">// 把存放了每一层元素的数组 temp 添加到 res 中</span><br>            res.add(temp);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回 res</span><br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法26[力扣104]-二叉树的最大深度</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9526-%E5%8A%9B%E6%89%A3104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9526-%E5%8A%9B%E6%89%A3104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 如果 root 为空，直接返回 0</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 递归调用 maxDepth，求出当前节点的左子树的最大深度</span><br>        <span class="hljs-keyword">int</span> left = maxDepth(root.left);<br><br>        <span class="hljs-comment">// 递归调用 maxDepth，求出当前节点的右子树的最大深度</span><br>        <span class="hljs-keyword">int</span> right = maxDepth(root.right);<br><br>        <span class="hljs-comment">// 求出当前节点的左右子树中较大的值</span><br>        <span class="hljs-keyword">int</span> childMaxDepth = Math.max(left,right);<br><br>        <span class="hljs-comment">// 二叉树的最大深度就是它的左右子树中较大的值加上 1</span><br>        <span class="hljs-keyword">return</span> childMaxDepth + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法25[力扣445]-两数相加Ⅱ</title>
    <link href="/2021/08/21/%E7%AE%97%E6%B3%9525-%E5%8A%9B%E6%89%A3445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/"/>
    <url>/2021/08/21/%E7%AE%97%E6%B3%9525-%E5%8A%9B%E6%89%A3445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 构建两个栈，用来储存两个链表中的元素</span><br><br>        <span class="hljs-comment">// stack1 用来存储链表 l1 中的元素</span><br>        Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// stack2 用来存储链表 l2 中的元素</span><br>        Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 依次把链表 l1 中的元素加入到 stack1 中</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把当前节点加入到 stack1 中</span><br>            stack1.push(l1.val);<br>            <span class="hljs-comment">// 继续向后遍历</span><br>            l1 = l1.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 依次把链表 l2 中的元素加入到 stack2 中</span><br>        <span class="hljs-keyword">while</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把当前节点加入到 stack2 中</span><br>            stack2.push(l2.val);<br>            <span class="hljs-comment">// 继续向后遍历</span><br>            l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置一个进位，初始化为 0</span><br>        <span class="hljs-comment">// 两个个位数相加，进位只能是 1 或者 0</span><br>        <span class="hljs-comment">// 比如 7 + 8 = 15，进位是 1</span><br>        <span class="hljs-comment">// 比如 2 + 3 = 6，没有进位，或者说进位是 0</span><br>        <span class="hljs-keyword">int</span> carryBit = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 构建一个链表用来存放 l1 和 l2 两个链表相加的结果</span><br>        <span class="hljs-comment">// 其中 dummy 这个节点为虚拟头结点</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 只要任意一个栈或者 carryBit 有值，那么就需要求和</span><br>        <span class="hljs-keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carryBit != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-comment">// 三目运算符，如果栈为空，就用 0 来占位，否则使用栈顶元素值</span><br><br>            <span class="hljs-comment">// 获取 stack1 的栈顶元素值</span><br>            <span class="hljs-keyword">int</span> x = stack1.isEmpty() ? <span class="hljs-number">0</span> : stack1.pop();<br><br>            <span class="hljs-comment">// 获取 stack2 的栈顶元素值</span><br>            <span class="hljs-keyword">int</span> y = stack2.isEmpty() ? <span class="hljs-number">0</span> : stack2.pop();<br><br>            <span class="hljs-comment">// 每一位计算的同时需要考虑上一位的进位情况</span><br>            <span class="hljs-keyword">int</span> sum = x + y + carryBit;<br><br>            <span class="hljs-comment">// 获取当前计算结果的十位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum / 10 = 1，进位为 1</span><br>            carryBit = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 获取当前计算结果的个位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum % 10 = 5</span><br>            <span class="hljs-keyword">int</span> diget =  sum % <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 构建一个节点用来存放这个个位数</span><br>            ListNode digetNode = <span class="hljs-keyword">new</span> ListNode(diget);<br><br>            <span class="hljs-comment">// 把这个节点插入到结果链表中</span><br>            <span class="hljs-comment">// 注意是插入，越后面计算的结果越在链表的前面</span><br><br>            <span class="hljs-comment">// 一开始，dummy 后面没有其它节点，当发生求和计算时</span><br>            <span class="hljs-keyword">if</span>(dummy.next == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 第一个计算结果直接加入到 dummy 后面</span><br>                dummy.next = digetNode;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 新的节点的 next 指针为之前的虚拟头节点 dummy 后面的那个节点</span><br>                digetNode.next = dummy.next;<br><br>                <span class="hljs-comment">// 更新 dummy 的 next 指针指向的节点</span><br>                dummy.next = digetNode;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回结果链表的头节点就行，即虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法24[力扣2]-两数相加</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9524-%E5%8A%9B%E6%89%A32-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9524-%E5%8A%9B%E6%89%A32-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://img-blog.csdnimg.cn/3f6824460384408e859c1a70233eeaf2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 构建一个链表用来存放 l1 和 l2 两个链表相加的结果</span><br>        <span class="hljs-comment">// 其中 dummy 这个节点为虚拟头结点</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个进位，初始化为 0</span><br>        <span class="hljs-comment">// 两个个位数相加，进位只能是 1 或者 0</span><br>        <span class="hljs-comment">// 比如 7 + 8 = 15，进位是 1</span><br>        <span class="hljs-comment">// 比如 2 + 3 = 6，没有进位，或者说进位是 0</span><br>        <span class="hljs-keyword">int</span> carryBit = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// l1 和 l2 有可能为空，所以先默认结果链表从虚拟头结点位置开始</span><br>        ListNode cur = dummy;<br><br>        <span class="hljs-comment">// 同时遍历 l1 和 l2</span><br>        <span class="hljs-comment">// 只要此时 l1 和 l2 两个链表中的任意链表中节点有值，就一直加下去</span><br>        <span class="hljs-comment">// 直到两个链表中的所有节点都遍历完毕为止</span><br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 获取 l1 链表中节点的值</span><br>            <span class="hljs-keyword">int</span> x;<br><br>            <span class="hljs-comment">// 观察此时 l1 中的节点是否有值</span><br>            <span class="hljs-comment">// 如果节点不存在，那么就用 0 来占位</span><br>            <span class="hljs-keyword">if</span>( l1 == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 用 0 来占位</span><br>                x = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则，将 l1 的节点值赋值给 x</span><br>                x = l1.val;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取 l2 链表中节点的值</span><br>            <span class="hljs-keyword">int</span> y;<br><br>            <span class="hljs-comment">// 观察此时 l2 中的节点是否有值</span><br>            <span class="hljs-comment">// 如果节点不存在，那么就用 0 来占位</span><br>            <span class="hljs-keyword">if</span>( l2 == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 用 0 来占位</span><br>                y = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则，将 l2 的节点值赋值给 y</span><br>                y = l2.val;<br>            &#125;<br><br>            <span class="hljs-comment">// 每一位计算的同时需要考虑上一位的进位情况</span><br>            <span class="hljs-keyword">int</span> sum = x + y + carryBit;<br><br>            <span class="hljs-comment">// 获取当前计算结果的十位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum / 10 = 1，进位为 1</span><br>            carryBit = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 获取当前计算结果的个位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum % 10 = 5</span><br>            <span class="hljs-keyword">int</span> digit = sum % <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 构建一个节点用来存放这个个位数</span><br>            ListNode digitNode = <span class="hljs-keyword">new</span> ListNode(digit);<br><br>            <span class="hljs-comment">// 把这个节点加入到结果链表中</span><br>            cur.next = digitNode;<br><br>            <span class="hljs-comment">// 移动 cur 的位置，观察后面应该存放什么节点</span><br>            cur = cur.next;<br><br>            <span class="hljs-comment">// l1 链表中还有节点未遍历完毕就继续遍历下去</span><br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>) l1 = l1.next;<br><br>            <span class="hljs-comment">// l2 链表中还有节点未遍历完毕就继续遍历下去</span><br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 两个链表的尾节点相加之后，有可能产生进位的情况</span><br>        <span class="hljs-comment">// 所以，需要构建一个新的节点用来存放这个进位的结果</span><br>        <span class="hljs-keyword">if</span>(carryBit == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 构建一个节点用来存放这个进位</span><br>            ListNode carryBitNode = <span class="hljs-keyword">new</span> ListNode(carryBit);<br><br>            <span class="hljs-comment">// 把这个节点加入到结果链表中</span><br>            cur.next = carryBitNode;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回结果链表的头节点就行，即虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法23[力扣142]-环形链表Ⅱ</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9523-%E5%8A%9B%E6%89%A3142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9523-%E5%8A%9B%E6%89%A3142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h3><p>给定一个链表，<strong>返回链表开始入环的第一个节点</strong>。</p><p>如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</p><p>如果 pos 是 -1，则在该链表中没有环。</p><p>注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>1、通过快慢指针的方式，在环中寻找它们的第一次相遇的节点位置</p><p>2、当快慢指针相遇的时候：</p><p><img src="https://img-blog.csdnimg.cn/98527c5216194aca93970af2575ee1f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>x 代表从头节点到环形入口节点的节点数（不包含头节点）</p><p>y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</p><p>z 代表从第一次相遇节点到环形入口的节点数（不包含第一次相遇节点）</p><p>此时，快指针走了 x + y + n (y + z)，其中，x + y 表示快指针第一次到达相遇节点，n 代表快指针在环里面绕了多少圈。</p><p>而慢指针走了 x + y 步。</p><p>那么就出现了一个等式 <code>x + y = [x + y + n (y + z)] / 2</code>，即<code>x = n（y + z）- y</code>。</p><p><strong>n（y + z）- y</strong> 代表的含义是<strong>一个指针从相遇节点开始出发，走了 n 圈之后回到原来的出发位置，往后退 y 步</strong>。</p><p>由于 x 代表从头节点到环形入口节点的节点数，并且<code>x = n（y + z）- y</code>，所以<strong>n（y + z）- y</strong> 代表的含义就是<strong>一个指针从相遇节点开始出发，走了 n 圈之后回到原来的出发位置，往后退 y 步来到了环的入口位置</strong>。</p><p>那么，我们就可以设置两个指针，一个从链表的头节点开始出发，一个指针从相遇节点开始出发，当它们相遇的时候，代表着环的入口节点找到了。</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、通过快慢指针的方式，在环中寻找它们的第一次相遇的节点位置</span><br><br>        <span class="hljs-comment">// 2、定义一个慢指针，每次只会向前移动 1 步</span><br>        ListNode slow = head;<br>        <span class="hljs-comment">// 3、定义一个快指针，每次只会向前移动 2 步</span><br>        ListNode fast = head;<br><br>        <span class="hljs-comment">// 4、如果链表有环，那么无论怎么移动，fast 指向的节点都是有值的</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 慢指针每次只会向前移动 1 步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 快指针每次只会向前移动 2 步</span><br>            fast = fast.next.next;<br><br>            <span class="hljs-comment">// 快慢指针相遇，说明有环</span><br>            <span class="hljs-comment">// x 代表从头节点到环形入口节点的节点数（不包含头节点）</span><br>            <span class="hljs-comment">// y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</span><br>            <span class="hljs-comment">// z 代表从第一次相遇节点到环形入口的节点数（不包含第一次相遇节点）</span><br>            <span class="hljs-comment">// y + z 代表环的节点总数</span><br>            <span class="hljs-comment">// 此时，快指针走了 x + y + n (y + z)</span><br>            <span class="hljs-comment">// 其中，x + y 表示快指针第一次到达相遇节点，n 代表快指针在环里面绕了多少圈</span><br>            <span class="hljs-comment">// 此时，慢指针走了 x + y 步</span><br><br>            <span class="hljs-comment">// 由于快指针每次走 2 步，所以快慢指针第一次相遇的时候出现一个等式</span><br>            <span class="hljs-comment">// x + y = [x + y + n (y + z)] / 2</span><br>            <span class="hljs-comment">// 即 2 * (x + y) = x + y + n (y + z)</span><br>            <span class="hljs-comment">// 即 x + y = n（y + z）</span><br>            <span class="hljs-comment">// 即 x = n（y + z）- y</span><br>            <span class="hljs-comment">// 我们的目的就是去求 x</span><br><br>            <span class="hljs-comment">// 定义两个指针，一个指向相遇节点，定义为 b，一个指向链表头节点，定义为 a</span><br><br>            <span class="hljs-comment">// b 在环中绕圈圈，走了 n（y + z）步会回到原处，即回到相遇节点处</span><br>            <span class="hljs-comment">// 由于 y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</span><br>            <span class="hljs-comment">// 所以 n（y + z） - y 时，b 到达了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 由于 x 代表从头节点到环形入口节点的节点数（不包含头节点）</span><br>            <span class="hljs-comment">// 所以 a 走了 x 步时，a 到达了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 当 x = n（y + z）- y 时，找到了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 5、开始寻找环入口</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br><br>                <span class="hljs-comment">// 定义两个指针，一个指向相遇节点，定义为 b，一个指向链表头节点，定义为 a</span><br>                <span class="hljs-comment">// 一个指向相遇节点，定义为 b</span><br>                ListNode b = fast;<br><br>                <span class="hljs-comment">// 一个指向链表头节点，定义为 a</span><br>                ListNode a = head;<br><br>                <span class="hljs-comment">// 让 a 、b 两个指针向前移动，每次移动一步，直到相遇位置</span><br>                <span class="hljs-comment">// 由于有环，必然相遇</span><br>                <span class="hljs-comment">// 当 b 走了 n（y + z） - y 时，b 到达了环形入口节点位置</span><br>                <span class="hljs-comment">// 当 a 走了 x 步时，a 到达了环形入口节点位置</span><br>                <span class="hljs-comment">// a 与 b 相遇</span><br>                <span class="hljs-keyword">while</span> (a != b) &#123;<br>                    <span class="hljs-comment">// a 指针每次只会向前移动 1 步</span><br>                    a = a.next;<br>                    <span class="hljs-comment">// b 指针每次只会向前移动 1 步</span><br>                    b = b.next;<br>                &#125;<br><br>                <span class="hljs-comment">// 6、返回 a 和 b 相遇的节点位置就是环形入口节点位置</span><br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有环，返回 null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法22[剑指offer22]-链表中倒数k个节点</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9522-%E5%89%91%E6%8C%87offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0k%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9522-%E5%89%91%E6%8C%87offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0k%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h3><p>输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6 。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>一般来说，链表相关的算法题考察的知识点有以下几个：</p><ul><li>递归</li><li>反转</li><li>双指针</li><li>环</li></ul><p>本题解题思路如下：</p><ul><li>1、初始化两个指针 <code>former</code> 和 <code>latter</code>，一开始都指向链表的头节点</li><li>2、前指针 <code>former</code> 先向前走 k 步</li><li>3、两个指针 <code>former</code> 和 <code>latter</code> 同时向前移动，直到前指针 <code>former</code> 指向 <code>NULL</code></li><li>4、由于 former 和 latter 之间的距离为 k，所以 latter 指向的节点即是倒数第 k 个节点，最后返回 <code>latter</code></li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化两个指针 former 和 latter，一开始都指向链表的头节点</span><br><br>        <span class="hljs-comment">// 指针 former 指向链表的头节点</span><br>        ListNode former = head;<br><br>        <span class="hljs-comment">// 指针 latter 指向链表的头节点</span><br>        ListNode latter = head;<br><br>        <span class="hljs-comment">// 让 former 指针先向前走 k 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; k; i++)&#123;<br>            <span class="hljs-comment">// former 指针向后移动</span><br>            former = former.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 接下来，让这两个指针 former 和 latter 同时向前移动，直到前指针 former 指向 NULL</span><br>        <span class="hljs-keyword">while</span>(former != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// former 指针向后移动</span><br>            former = former.next;<br>            <span class="hljs-comment">// latter 指针向后移动</span><br>            latter = latter.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 此时，由于 former 和 latter 之间的距离为 k</span><br>        <span class="hljs-comment">// 所以 latter 指向的节点即是倒数第 k 个节点</span><br>        <span class="hljs-keyword">return</span> latter;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法21[面试题35]-复杂链表的复制</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9521-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9521-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目算法"><a href="#一、题目算法" class="headerlink" title="一、题目算法"></a>一、题目算法</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/053d8772392f430fa909c1d0a0b412ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>对于链表中的每个节点来说，它都有三个特征：</p><ul><li>值为 val</li><li>一个指向下一个节点的指针 <code>next</code></li><li>一个指向随机节点的指针 <code>random</code></li></ul><p><img src="https://img-blog.csdnimg.cn/1d7aeb183d55481b8b61308912b93730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><p>要想<strong>复制这样一个复杂链表</strong>必须要考虑到这三个特征。</p><p>如果没有 <code>random</code> 指针的话，那就是普通的链表，只需要遍历链表，然后每轮创建新节点，同时赋值 val 和调整前驱指针指向当前节点就行。</p><p>这题出现了 <code>random</code> 指针，由于它可以指向 null 、前面的节点或者后面的节点， 无法做到在一次遍历的过程中就确定下来，因为如果是<strong>指向后面的节点</strong>，但后面的节点还没有创建生成，无法确定。</p><p><img src="https://img-blog.csdnimg.cn/59dd792808be496ca281f89bbe1da7c6.png" alt="3"></p><p>所以，我们需要在<strong>一开始把所有的节点都创建出来</strong>，避免 <code>random</code> 找不到指向，同时观察上图，<strong>每个节点都通过 random 对应着一个新的节点</strong>，这种一一对应的关系，符合<strong>哈希表</strong>的特征。</p><p>此时的哈希表<strong>以原链表的节点作为键，新创建的节点作为值</strong>。</p><p><img src="https://img-blog.csdnimg.cn/54b0ad5bf8f6498ea57be731e7ea0127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="4"></p><p>原链表（Key）中的每个节点都有 next 和 random 指针，而新链表（Value） 没有 next 和 random 指针。</p><p>需要通过第二次的遍历过程进行指针指向的调整。</p><p>在第二次遍历过程中，以原链表中的节点作为键，查找当前<strong>原节点</strong>的指针指向，然后调整<strong>新节点</strong>的指针指向。</p><p><img src="https://img-blog.csdnimg.cn/238575bec17846bb9092945dedce67be.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="5"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界判断，一般链表的题目都需要判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 从链表的头节点开始遍历</span><br>        Node cur = head;<br><br>        <span class="hljs-comment">// 使用一一对应的哈希表结构 Map 存放已经创建的节点</span><br>        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 遍历原链表</span><br>        <span class="hljs-keyword">while</span>( cur != <span class="hljs-keyword">null</span> ) &#123;<br>            <span class="hljs-comment">// 以原链表的节点为 Key，构建一个 Map</span><br>            <span class="hljs-comment">// Map 的 Value 为一个新链表中的节点</span><br>            <span class="hljs-comment">// 新节点的值 val 和原链表的值 val 一样</span><br>            <span class="hljs-comment">// 但原链表中的每个节点都有 next 和 random 指针，而 Map 中的 Value 没有 next 和 random 指针</span><br>            <span class="hljs-comment">// map.put(Key,Value)</span><br>            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));<br>            <span class="hljs-comment">// 查看下一个节点的情况</span><br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 再次从链表的头节点开始遍历</span><br>        cur = head;<br><br>        <span class="hljs-comment">// 遍历原链表</span><br>        <span class="hljs-keyword">while</span>( cur != <span class="hljs-keyword">null</span> ) &#123;<br><br>            <span class="hljs-comment">// 原链表节点 ----  新链表节点</span><br>            <span class="hljs-comment">// key      ----- value</span><br>            <span class="hljs-comment">// cur      ----- map.get(cur)</span><br><br>            <span class="hljs-comment">// 0、在字典中找到一个 cur 为 key 对应的那个 value 值</span><br>            Node valueCur = map.get(cur);<br><br>            <span class="hljs-comment">// 接下来，需要去寻找 valueCur 的 next 节点和 random 节点</span><br><br>            <span class="hljs-comment">// 寻找 valueCur 的 next 节点</span><br>            <span class="hljs-comment">// 1、获取当前节点 cur 在原链表中的 next 指针指向的节点</span><br>            Node keyNextNode = cur.next;<br><br>            <span class="hljs-comment">// 2、在字典中找到以 keyNextNode 为 key 对应的那个 value 值</span><br>            Node valueNextNode = map.get(keyNextNode);<br><br>            <span class="hljs-comment">// 3、那么新链表中的这个节点的 next 指针就是 valueNextNode</span><br>            valueCur.next = valueNextNode;<br><br>            <span class="hljs-comment">// 寻找 valueCur 的  节点</span><br>            <span class="hljs-comment">// 1、获取当前节点 cur 在原链表中的 random 指针指向的节点</span><br>            Node keyRandomNode = cur.random;<br><br>            <span class="hljs-comment">// 2、在字典中找到以 valueRandomNode 为 key 对应的那个 value 值</span><br>            Node valueRandomNode = map.get(keyRandomNode);<br><br>            <span class="hljs-comment">// 4、那么新链表中的这个节点的 next 指针就是 valueNextNode</span><br>            valueCur.random = valueRandomNode;<br><br><br>            <span class="hljs-comment">//遍历下去，查看下一个节点</span><br>            cur = cur.next;<br><br>        &#125;<br>        <span class="hljs-comment">// 原链表节点 ----  新链表节点</span><br>        <span class="hljs-comment">// key      ----- value</span><br>        <span class="hljs-comment">// cur      ----- map.get(cur)</span><br>        <span class="hljs-comment">// head     ----- map.get(head)</span><br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法20[力扣328]-奇偶链表</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9520-%E5%8A%9B%E6%89%A3328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9520-%E5%8A%9B%E6%89%A3328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;NULL <br>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 边界情况处理，如果链表为空或者只有一个节点，返回 head 就行</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> ) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头节点，odd 代表奇数节点的头节点</span><br>        ListNode odd = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头节点的下一个节点，even 代表偶数节点的头节点</span><br>        ListNode even = head.next; <br><br>        <span class="hljs-comment">// 设置一个指针，指向偶数节点的头节点，最终让奇数节点的尾节点的 next 指针指向它</span><br>        ListNode evenHead = even;<br><br>        <span class="hljs-comment">// 从偶数链表的头节点开始向后遍历</span><br>        <span class="hljs-comment">// 如果当前节点为空，或者后一节点为空，那么说明整个链表已经查看完毕，不需要再遍历了</span><br>        <span class="hljs-keyword">while</span>(even != <span class="hljs-keyword">null</span> &amp;&amp; even.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 原先奇数节点的下一个节点是偶数节点，即 even 这个节点</span><br>            <span class="hljs-comment">// 根据数学知识，奇数后面一定是偶数，偶数后面一定是奇数</span><br>            <span class="hljs-comment">// 那么 even.next 节点必然是奇数节点</span><br>            <span class="hljs-comment">// 所以让 odd 这个奇数节点的 next 指针指向 even.next 这个奇数节点</span><br>            <span class="hljs-comment">// 这样，odd 上面都是奇数</span><br>            odd.next = even.next;<br>            <span class="hljs-comment">// 让 odd 移动到最新的由奇数节点组成的链表的尾部位置</span><br>            odd = odd.next;<br><br>            <span class="hljs-comment">// 这个时候，odd.next 必然是偶数节点</span><br>            <span class="hljs-comment">// 所以让 even 这个偶数节点的 next 指针指向 odd.next 这个偶数节点</span><br>            even.next = odd.next;<br>            <span class="hljs-comment">// 让 even 移动到最新的由偶数节点组成的链表的尾部位置</span><br>            even = even.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 此时，原链表所有的节点已经遍历完毕</span><br>        <span class="hljs-comment">// odd 上都是奇数节点</span><br>        <span class="hljs-comment">// even 都是偶数节点</span><br>        <span class="hljs-comment">// 根据题目要求，奇数节点都在偶数节点之前</span><br>        <span class="hljs-comment">// 所以让此时右奇数节点组成的链表的尾部的 next 指针指向由偶数节点组成的链表的头部</span><br>        odd.next = evenHead;<br><br>        <span class="hljs-comment">// 最后返回原链表的头部节点就可以了</span><br>        <span class="hljs-comment">// 链表的头部节点没有发生过变化，因为它是奇数节点，并且是第一个奇数节点</span><br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法19[剑指offer06]-从尾到头打印链表</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9519-%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9519-%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li>0 &lt;= 链表长度 &lt;= 10000</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>链表都是从头读到尾依次访问每个节点，题目要求我们 <strong>从尾到头</strong> 打印链表，这种逆序的操作很显然可以考虑使用</p><p>具有 <strong>先入后出</strong> 特点的数据结构，那就是 <strong>栈</strong>。</p><p>具体操作如下：</p><ul><li><strong>入栈：</strong> 遍历链表，将各节点值 <code>push</code> 入栈。</li><li><strong>出栈：</strong> 将各个节点值 <code>pop</code> 出栈，存储于数组并返回。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br><br>        <span class="hljs-comment">// 构建一个栈，用来存储链表中每个节点的值</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个指针，指向链表的头结点位置，从它开始向后遍历</span><br>        ListNode curNode = head;<br><br>        <span class="hljs-comment">// 不断的遍历原链表中的每个节点，直到为 null</span><br>        <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 把每个节点的值加入到栈中</span><br>            stack.push(curNode.val);<br>            <span class="hljs-comment">// curNode 向后移动</span><br>            curNode = curNode.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取栈的长度</span><br>        <span class="hljs-keyword">int</span> size = stack.size();<br><br>        <span class="hljs-comment">// 通过栈的长度，定义一个同样长度的数组 res</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br><br>        <span class="hljs-comment">// 遍历栈，从栈顶挨个弹出每个值，把这些值依次加入到数组 res 中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i++)&#123;<br>            <span class="hljs-comment">// 数组接收栈顶元素值</span><br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-comment">// 最后返回结果数组就行</span><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法18[力扣25]-k个一组翻转链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9518-%E5%8A%9B%E6%89%A325-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9518-%E5%8A%9B%E6%89%A325-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 虚拟头节点的下一节点指向 head 节点</span><br>        <span class="hljs-comment">// 如果原链表是  1 --&gt;  2 --&gt;  3</span><br>        <span class="hljs-comment">// 那么加上虚拟头节点就是  -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br><br>        dummy.next = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点，pre 表示每次要翻转的链表的头结点的【上一个节点】</span><br>        <span class="hljs-comment">// pre: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点，end 表示每次要翻转的链表的尾节点</span><br>        <span class="hljs-comment">// end: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>        ListNode end = dummy;<br><br>        <span class="hljs-comment">// 通过 while 循环，不断的找到翻转链表的尾部</span><br>        <span class="hljs-keyword">while</span>( end.next != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 for 循环，找到【每一组翻转链表的尾部】</span><br>            <span class="hljs-comment">// 由于原链表按照 k 个一组进行划分会可能出现有一组的长度不足 k 个</span><br>            <span class="hljs-comment">// 比如原链表 1 --&gt;  2 --&gt;  3 --&gt;  4 --&gt;  5</span><br>            <span class="hljs-comment">// k = 2，划分了三组 1 --&gt;  2， 3 --&gt;  4， 5</span><br>            <span class="hljs-comment">// 所以得确保 end 不为空才去找它的 next 指针，否则 null.next 会报错</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; k &amp;&amp; end != <span class="hljs-keyword">null</span> ; i++)&#123;<br>                <span class="hljs-comment">// end 不断的向后移动，移动 k 次到达【每一组翻转链表的尾部】</span><br>                end = end.next ;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果发现 end == null，说明此时翻转的链表的节点数小于 k ，保存原有顺序就行</span><br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 直接跳出循环，只执行下面的翻转操作</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br><br>            <span class="hljs-comment">// next 表示【待翻转链表区域】里面的第一个节点</span><br>            ListNode next = end.next;<br><br>            <span class="hljs-comment">// 【翻转链表区域】的最尾部节点先断开</span><br>            end.next = <span class="hljs-keyword">null</span> ;<br><br>            <span class="hljs-comment">// start 表示【翻转链表区域】里面的第一个节点</span><br>            ListNode start = pre.next;<br><br><br><br>            <span class="hljs-comment">// 【翻转链表区域】的最头部节点和前面断开</span><br>            pre.next = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// 这个时候，【翻转链表区域】的头节点是 start，尾节点是 end</span><br>            <span class="hljs-comment">// 开始执行【反转链表】操作</span><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br><br>            <span class="hljs-comment">// 要翻转的链表的头结点的【上一个节点】的 next 指针指向这次翻转的结果</span><br>            pre.next = reverse(start);<br><br>            <span class="hljs-comment">// 接下来的操作是在为【待翻转链表区域】的反转做准备</span><br><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br>            <span class="hljs-comment">// 【翻转链表区域】里面的尾节点的 next 指针指向【待翻转链表区域】里面的第一个节点</span><br>            start.next = next ;<br><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br>            <span class="hljs-comment">// pre 表示每次要翻转的链表的头结点的【上一个节点】</span><br>            pre = start;<br><br>            <span class="hljs-comment">// 将 end 重置为【待翻转链表区域】的头结点的上一个节点。</span><br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br><br><br>    &#125;<br>    <span class="hljs-comment">// 反转链表的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverse(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法17[力扣234]-回文链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9517-%E5%8A%9B%E6%89%A3234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9517-%E5%8A%9B%E6%89%A3234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>请判断一个链表是否为回文链表。    </p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 边界情况判断</span><br><br>        <span class="hljs-comment">// 链表为空或者只有一个节点的情况，属于回文链表</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 链表只有两个节点的时候，判断这两个节点值是否相等</span><br>        <span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head.val == head.next.val;<br><br>        <span class="hljs-comment">// 通过快慢指针寻找链表的中心点</span><br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头部</span><br>        <span class="hljs-comment">// fast 这个指针每次都向后移动两步</span><br>        ListNode fast = head;<br><br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头部</span><br>        <span class="hljs-comment">// slow 这个指针每次都向后移动一步</span><br>        ListNode slow = head;<br><br>        <span class="hljs-comment">// 让 fast 和 slow 同时向后移动</span><br>        <span class="hljs-comment">// 其中，fast 这个指针每次都向后移动两步，slow 这个指针每次都向后移动一步</span><br>        <span class="hljs-comment">// 直到 fast 这个指针指向了链表的尾节点，即 fast.next = null</span><br>        <span class="hljs-comment">// 或者 fast 这个指针指向了链表的尾节点的前一个节点，即 fast.next.next = null</span><br>        <span class="hljs-comment">// 这个时候，fast 这个指针无法向后移动两位，跳出循环，找到了中间点</span><br>        <span class="hljs-comment">// 如果链表长度为偶数，则 slow 指向了中间节点前的那个节点</span><br>        <span class="hljs-comment">// 比如链表为  1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; null</span><br><br>        <span class="hljs-comment">// 一开始，slow 和 fast 同时指向 1，slow 移动一位到 2，fast 移动两位到 3</span><br>        <span class="hljs-comment">// 由于 3.next.next 为空，所以跳出 while，此时 slow 指向了中间节点前的那个节点</span><br><br>        <span class="hljs-comment">// 如果链表长度为奇数，则 slow 指向了中间节点</span><br>        <span class="hljs-comment">// 比如链表为  1 --&gt; 2 --&gt; 3 </span><br>        <span class="hljs-comment">// 一开始，slow 和 fast 同时指向 1，slow 移动一位到 2，fast 移动两位到 3</span><br>        <span class="hljs-comment">// 由于 3.next 为空，所以跳出 while，此时 slow 指向了中间节点</span><br><br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// slow 这个指针每次都向后移动一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// fast 这个指针每次都向后移动两步</span><br>            fast = fast.next.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 这个时候，slow 指向的那个节点把链表划分为两个区域</span><br>        <span class="hljs-comment">// 翻转右区域的链表</span><br>        <span class="hljs-comment">// 获取右区域的链表翻转之后的头节点</span><br>        ListNode rightHead =  reverse(slow.next);<br><br>        <span class="hljs-comment">// 获取左区域的链表的头节点</span><br>        ListNode leftHead = head;<br><br>        <span class="hljs-comment">// 让 leftHead 和 rightHead 同时向后移动，直到 rightHead 指向 null 为止</span><br>        <span class="hljs-comment">// 说明比较完了所有的节点</span><br>        <span class="hljs-keyword">while</span>(rightHead != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 如果它们的节点值不一样，那么就不是回文链表</span><br>            <span class="hljs-keyword">if</span>(leftHead.val != rightHead.val)&#123;<br>                <span class="hljs-comment">// 不是回文链表，返回 false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则，让 rightHead 继续向右移动</span><br>            rightHead = rightHead.next;<br><br>            <span class="hljs-comment">// 否则，让 rightHead 继续向右移动</span><br>            leftHead = leftHead.next;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 比较完所有的节点，说明是回文链表，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverse(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法16[力扣面试题02.04]-分割链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9516-%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%9802-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9516-%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%9802-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 <strong>小于</strong> x 的节点都出现在 <strong>大于或等于</strong> x 的节点之前。</p><p>你不需要 <strong>保留</strong> 每个分区中各节点的初始相对位置。</p><p>1—–&gt;4—–&gt;<strong>3</strong>—–&gt;2—–&gt;5—–&gt;2</p><p>1—–&gt;2—–&gt;2—–&gt;4—–&gt;<strong>3</strong>—–&gt;5</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>通过构建两个链表来分别处理大于等于 x 的那些节点和小于 x 的那些节点。</p><ul><li>大链表：大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</li><li>小链表：小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</li></ul><p>在遍历原链表的过程中，让大链表去接收那些大于等于 x 的节点，用小链表去接收那些小于 x 的节点，接着让小链表的尾部接上大链表的虚拟头节点的下一个节点，然后让大链表的尾部节点的 next 指针指向 null，最后返回小链表的虚拟头节点的下一个节点就行。</p><h3 id="三、题目代码"><a href="#三、题目代码" class="headerlink" title="三、题目代码"></a>三、题目代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 构建两个新链表</span><br>        <span class="hljs-comment">// 大链表：大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 小链表：小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</span><br><br>        <span class="hljs-comment">// 设置一个指针，执行大链表的头结点</span><br>        ListNode bigHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，执行大链表的尾结点</span><br>        ListNode bigTail = bigHead;<br><br>        <span class="hljs-comment">// 设置一个指针，执行小链表的头结点</span><br>        ListNode smallHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，执行小链表的尾结点</span><br>        ListNode smallTail = smallHead;<br><br>        <span class="hljs-comment">// 开始遍历原链表 head，直到遍历到尾部位置</span><br>        <span class="hljs-comment">// 在遍历的过程查看当前节点的值</span><br>        <span class="hljs-keyword">while</span> ( head != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-comment">// 如果当前节点的值小于了特定值 x</span><br>            <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;<br>                <span class="hljs-comment">// 那么我们就把这个节点添加到小链表中</span><br>                <span class="hljs-comment">// 操作就是让小链表中的尾节点的 next 指针指向这个节点</span><br>                smallTail.next = head;<br><br>                <span class="hljs-comment">// 同时，小链表中的尾节点位置发生了变化，也移动到 head 这个位置</span><br>                smallTail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-comment">// 否则，如果当前节点的值大于或者等于了特定值 x</span><br>                 <span class="hljs-comment">// 那么我们就把这个节点添加到大链表中</span><br>                 <span class="hljs-comment">// 操作就是让大链表中的尾节点的 next 指针指向这个节点                 </span><br>                 bigTail.next = head;<br><br>                 <span class="hljs-comment">// 同时，大链表中的尾节点位置发生了变化，也移动到 head 这个位置</span><br>                 bigTail = head;<br>            &#125;<br><br>            <span class="hljs-comment">// 操作完当前节点的值之后，继续去查看链表中的下一个节点</span><br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 通过上面的循环，原链表已经被分割为两个部分</span><br>        <span class="hljs-comment">// 其中，大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 接下来，我们把大小链表串联起来</span><br><br>        <span class="hljs-comment">// 让小链表的尾节点的 next 指针指向大链表虚拟头节点的下一个节点</span><br>        smallTail.next = bigHead.next;<br><br>        <span class="hljs-comment">// 让大链表的尾节点的 next 指针指向 null</span><br>        bigTail.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 最后返回小链表的虚拟头节点的下一个节点就行</span><br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法15[力扣160]-相交链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9515-%E5%8A%9B%E6%89%A3160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9515-%E5%8A%9B%E6%89%A3160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://img-blog.csdnimg.cn/866d054fee8a4e2394c2d27df596adf8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>在节点 c1 开始相交。</p><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 null。</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><h4 id="1、模拟"><a href="#1、模拟" class="headerlink" title="1、模拟"></a>1、模拟</h4><p>首先假设 A 、B 两个链表是有<strong>相交节点</strong>的情况。</p><p><img src="https://img-blog.csdnimg.cn/3cdc5cf2e6a84144b501a5b14ad35609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><p><img src="https://img-blog.csdnimg.cn/e9149b232ce54441884c3754b6e15e58.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="3"></p><p><img src="https://img-blog.csdnimg.cn/92457e3ef68647f4b8abfdf9a4e07168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="4"></p><p><img src="https://img-blog.csdnimg.cn/eefe202962b44c9fabc14f1fa7aca9da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="5"></p><p><img src="https://img-blog.csdnimg.cn/3fb1bbb86ea14d7d881f44fe37c1aac4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="6"></p><p>再假设 A 、B 两个链表是<strong>没有相交节点</strong>的情况。</p><p><img src="https://img-blog.csdnimg.cn/2fd058aef79e470ba8a7d6dc354bccb2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="7"></p><p><img src="https://img-blog.csdnimg.cn/4bde317acefa4abf9dfecef6c9336026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="8"></p><h4 id="2、规律"><a href="#2、规律" class="headerlink" title="2、规律"></a>2、规律</h4><p>也就是说，无论 A、B 两个链表是否有相交点，最终都会指向一个相同的节点，要么是它们的公共尾部，要么是 NULL。</p><p>让指针 <code>pointA</code> 和 <code>pointB</code> 分别指向链表 A 和链表 B 的头结点，之后两个指针分别以步幅为 1 的速度向链表的尾部遍历。</p><ul><li>当指针 <code>pointA</code> 遍历到链表 A 的尾节点时，此时指针 <code>pointA</code> 走了 a 个节点，将指针 <code>pointA</code> 指向链表 B 的头部，继续向后遍历，直至走到 <code>c1</code>，此时指针 <code>pointA</code> 总共走了 <code>a + ( b - c )</code> 步。</li><li>当指针 <code>pointB</code> 遍历到链表 B 的尾节点时，此时指针 <code>pointB</code> 走了 b 个节点，将指针 <code>pointB</code> 指向链表 A 的头部，继续向后遍历，直至走到 <code>c1</code>，此时指针 <code>pointB</code> 总共走了 <code>b + ( a - c )</code> 步。</li></ul><p>根据数学知识，<code>a + ( b - c ) = b + ( a - c )</code> ，如果 c &gt; 0，表明两链表有公共尾部， <code>c1</code> 存在，两两链表同时到达 <code>c1</code>；如果 c = 0，表明两链表没有公共尾部，指针 <code>pointA</code> 和 <code>pointB</code> 都指向 <code>NULL</code>。</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界判断</span><br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 设置一个指针 pointA，指向链表 A 的头节点</span><br>        ListNode pointA = headA;<br><br>        <span class="hljs-comment">// 设置一个指针 pointB，指向链表 B 的头节点</span><br>        ListNode pointB = headB;<br><br>        <span class="hljs-comment">// 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点</span><br>        <span class="hljs-comment">// 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的最小公倍数的情况下</span><br>        <span class="hljs-comment">// pointA 和 pointB 都会同时指向 null</span><br>        <span class="hljs-comment">// 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交</span><br>        <span class="hljs-comment">// 那么 pointA 移动了 7 * 11 = 77 次之后，会指向 null</span><br>        <span class="hljs-comment">// pointB 移动了 7 * 11 = 77 次之后，也指向 null</span><br>        <span class="hljs-comment">// 这个时候就跳出了循环</span><br>        <span class="hljs-keyword">while</span> (pointA != pointB) &#123;<br>            <span class="hljs-comment">// 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 </span><br>            <span class="hljs-keyword">if</span>( pointA == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 指针 pointA 跳转到链表 B 上  </span><br>                pointA = headB;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则的话 pointA 不断的向后移动</span><br>                pointA = pointA.next;<br>            &#125;<br><br>             <span class="hljs-comment">// 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 </span><br>            <span class="hljs-keyword">if</span>( pointB == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 指针 pointA 跳转到链表 B 上  </span><br>                pointB = headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则的话 pointB 不断的向后移动</span><br>                pointB = pointB.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可</span><br>        <span class="hljs-comment">// 2、此时，headA 和 headB 不想交，那么 pointA 和 pointB 均为 null，也返回任意一个均可</span><br>        <span class="hljs-keyword">return</span> pointA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法14[力扣203]-移除链表元素</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9514-%E5%8A%9B%E6%89%A3203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9514-%E5%8A%9B%E6%89%A3203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val val 的节点，并返回 <strong>新的头节点</strong> 。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>移除的节点有两种情况。</p><p>1、移除的是头节点</p><p>2、移除的是其它节点</p><p>对于<strong>移除其它节点</strong>这种情况，我们可以让它的前一个节点指向移除节点的下一节点来解决。</p><p><img src="https://img-blog.csdnimg.cn/e26296f32514448686d9787357fdc663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>对于<strong>移除头节点</strong>这种情况，为了让解决情况和上面的逻辑一样，我们借助一个<strong>虚拟节点</strong>来解决。</p><p>我们给链表添加一个虚拟头节点作为新的头节点。</p><p><img src="https://img-blog.csdnimg.cn/1cffa5517d014bf3a2d7d0a9810bd231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 边界情况，如果链表为空，那么没有元素可以删除，直接返回空</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>    <span class="hljs-comment">// 设置虚拟节点的目的是为了让原链表中所有节点就都可以按照统一的方式进行移除</span><br>    <span class="hljs-comment">// 因为如果不设置虚拟节点，如果删除的元素是原链表中的头节点，那么需要额外的做一些判断，比较繁琐</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 虚拟头节点的下一节点指向 head 节点</span><br>    <span class="hljs-comment">// 如果原链表是  1 --&gt;  2 --&gt;  3</span><br>    <span class="hljs-comment">// 那么加上虚拟头节点就是  -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>    dummy.next = head;<br><br>    <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点</span><br>    <span class="hljs-comment">// pre: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>    ListNode pre = dummy;<br><br>    <span class="hljs-comment">// 设置一个指针，指向原链表 head</span><br>    ListNode cur = head;<br><br>    <span class="hljs-comment">// 让 cur 不断的向后移动，直到移动到链表的最尾部，指向 null 的那个位置</span><br>    <span class="hljs-comment">// 此时 pre 还在指向 dummy</span><br>    <span class="hljs-comment">// 也就是说一开始 pre 落后 cur 一个节点</span><br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-comment">// 移动的过程中，如果发现当前的节点值和目标值一样</span><br>        <span class="hljs-comment">// 我们就让指针 pre 所指向的节点的下一节点跳过这个值</span><br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            <span class="hljs-comment">// 让指针 pre 所指向的节点的下一节点跳过这个值</span><br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则的话，pre 跟上 cur 的位置</span><br>            pre = cur;<br>        &#125;<br>        <span class="hljs-comment">// 判断完当前的节点情况后，让 cur 向后移动</span><br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后返回 dummy 节点的下一节点</span><br>    <span class="hljs-comment">// 因为这个时候 dummy 指向的是一个我们设置的节点，它的下一节点才是原链表中的节点</span><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法13[力扣92]-反转链表Ⅱ</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9513-%E5%8A%9B%E6%89%A392-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9513-%E5%8A%9B%E6%89%A392-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><img src="https://img-blog.csdnimg.cn/9402f191ec7a4f64bb30c3f9c849624d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>1、构建一个虚拟节点，让它指向原链表的头节点。</p><p>2、设置两个指针，pre 指针指向以虚拟头节点为链表的头部位置，cur 指针指向原链表的头部位置。</p><p>3、让着两个指针向前移动，直到 pre 指向了第一个要反转的节点的前面那个节点，而 cur 指向了第一个要反转的节点。</p><p>4、开始指向翻转操作</p><ul><li>1）、设置临时变量 temp，temp 是 cur 的 next 位置，保存当前需要翻转节点的后面的节点，我们需要交换 temp 和 cur</li><li>2）、让 cur 的 next 位置变成 temp 的下一个节点</li><li>3）、让 temp 的 next 位置变成 cur</li><li>4）、让 pre 的 next 位置变成 temp</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        <span class="hljs-comment">// 设置虚拟节点的目的是为了让原链表中所有节点就都可以按照统一的方式进行翻转</span><br>        <span class="hljs-comment">// 比如如果翻转的区间包含了原链表中的第一个位置，那么如果不设置 dummy</span><br>        <span class="hljs-comment">// 在翻转的过程中需要设置其它的临时变量来保持第一位置节点的指针</span><br>        <span class="hljs-comment">// 具体可以通过动画来理解</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 让虚拟节点指向原链表的头部</span><br>        dummy.next = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向以虚拟头节点为链表的头部位置</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 设置一个指针，指向原链表的头部位置</span><br><br>        ListNode cur = head;<br><br><br>        <span class="hljs-comment">// 从虚拟头节点出发，pre 走 left - 1 步找到需要翻转的左区间</span><br>        <span class="hljs-comment">// for 循环结束后，pre 的右节点是需要翻转的节点</span><br>        <span class="hljs-comment">// for 循环结束后，cur 指向的就是需要翻转的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br><br><br>            <span class="hljs-comment">// pre 不断的向右移动，直到走到翻转的左区间为止</span><br>            pre = pre.next;<br>            <span class="hljs-comment">// cur 不断的向右移动，找到了需要翻转的第一个节点</span><br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始翻转这些节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br><br>            <span class="hljs-comment">// 设置临时变量，保存当前需要翻转节点的后面的节点</span><br>            ListNode temp = cur.next;<br><br>            <span class="hljs-comment">// 这个时候，让 temp 和 cur 两个节点翻转一下</span><br>            <span class="hljs-comment">// 比如，一开始 i = 0 的时候 cur 为 2， temp 为 3</span><br>            <span class="hljs-comment">// 执行完下面的代码，如果原链表是</span><br>            <span class="hljs-comment">// 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>            <span class="hljs-comment">// 变成了</span><br>            <span class="hljs-comment">// 1 --&gt; 3 --&gt; 2 --&gt; 4 --&gt; 5</span><br><br>            <span class="hljs-comment">// cur 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， cur 为 2，cur.next.next 的值是 4</span><br>            <span class="hljs-comment">// 所以，这行代码让 cur 的下一节点不是 3 ，而是 4 </span><br>            <span class="hljs-comment">// 2 --&gt; 4</span><br>            <span class="hljs-comment">// 等价于 cur.next = temp.next</span><br>            cur.next = cur.next.next;<br><br>            <span class="hljs-comment">// temp 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， temp 为 3，pre 为 1，pre 下一节点的值是 2</span><br>            <span class="hljs-comment">// 所以，这行代码让 temp 的下一节点不是 4 ，而是 2 </span><br>            <span class="hljs-comment">// 3 --&gt; 2</span><br>            temp.next = pre.next;<br><br>            <span class="hljs-comment">// pre 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， pre 为 1，temp 的值是 3</span><br>            <span class="hljs-comment">// 所以，这行代码让 pre 的下一节点为 3</span><br>            <span class="hljs-comment">// 1 --&gt; 3</span><br><br>            pre.next =temp;<br><br>            <span class="hljs-comment">// i = 0 结束之后，链表变成了</span><br>            <span class="hljs-comment">// 1 --&gt; 3 --&gt; 2 --&gt; 4 --&gt; 5</span><br><br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回虚拟头节点的下一个节点，因为虚拟节点不在链表中</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法12[力扣21]-合并两个有序链表</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9512-%E5%8A%9B%E6%89%A321-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9512-%E5%8A%9B%E6%89%A321-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，指向虚拟节点</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 通过一个循环，不断的比较 l1 和 l2 中当前节点值的大小，直到 l1 或者 l2 遍历完毕为止</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 l1 当前节点的值小于等于了 l2 当前节点的值</span><br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                <span class="hljs-comment">// 让 pre 指向节点的 next 指针指向这个更小值的节点</span><br>                <span class="hljs-comment">// 即指向 l1</span><br>                pre.next = l1;<br>                <span class="hljs-comment">// 让 l1 向后移动</span><br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 让 pre 指向节点的 next 指针指向这个更小值的节点</span><br>                <span class="hljs-comment">// 即指向 l2</span><br>                pre.next =l2;<br>                <span class="hljs-comment">// 让 l2 向后移动</span><br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">// 让 pre 向后移动</span><br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 跳出循环后，l1 或者 l2 中可能有剩余的节点没有被观察过</span><br>        <span class="hljs-comment">// 直接把剩下的节点加入到 pre 的 next 指针位置</span><br><br>        <span class="hljs-comment">// 如果 l1 中还有节点</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把 l1 中剩下的节点全部加入到 pre 的 next 指针位置</span><br>            pre.next = l1;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果 l2 中还有节点</span><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把 l2 中剩下的节点全部加入到 pre 的 next 指针位置</span><br>            pre.next = l2;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回虚拟节点的 next 指针</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法11[力扣206]-反转链表</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9511-%E5%8A%9B%E6%89%A3206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9511-%E5%8A%9B%E6%89%A3206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; null</p><p>5 –&gt; 4 –&gt; 3 –&gt; 2 –&gt; 1 –&gt; null</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>这道题目有很多种解法，递归解法最难以理解整个过程，今天我就带大家来探究一次！</p><p>先来看分析过程，这里看不懂没关系，一定要看最后的<strong>动画过程</strong>。</p><ul><li>1、通过<strong>递归函数</strong>，一直递归到链表的最后一个结点为止，此时，<strong>该结点就是反转成功后的头结点</strong>，是最终的返回结果。</li><li>2、在递归函数中，让当前节点的下一个节点的 <code>next</code> 指针指向当前节点。</li><li>3、在递归函数中，让当前节点的 <code>next</code> 指针指向 <code>null</code></li><li>4、通过二三步的操作，已经让递归函数中的链表实现了<strong>局部反转</strong>，将结果返回给上一层递归函数</li><li>5、所有递归结束后，链表反转成功。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverseList(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法10[力扣239]-滑动窗口的最大值</title>
    <link href="/2021/08/09/%E7%AE%97%E6%B3%9510-%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2021/08/09/%E7%AE%97%E6%B3%9510-%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,3,-1,-3,5,3,6,7]</span>, 和 k = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">[3,3,5,5,6,7]</span> <br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1crv4.png" alt="1"></p><p><strong>提示：</strong></p><ul><li>你可以假设 <code>k</code> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p><strong>滑动窗口</strong>这个词包含两个概念，一个是<strong>滑动</strong>，一个是<strong>窗口</strong>。</p><p>首先是窗口需要生成，一开始里面是没有任何元素的。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/p57vp.jpg" alt="2"></p><p>然后再<strong>滑动</strong>，随着窗口不断的滑动，窗口里面的元素个数从 0 到 1，再到 2，再到 3，此时，从窗口里面宣传最大值。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/624h8.jpg" alt="3"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/f9wt0.jpg" alt="4"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/zdyac.jpg" alt="ww"></p><p>想要找出当前窗口里面的<strong>最大值</strong>，自然而然的想法就是<strong>遍历窗口中的所有元素</strong>，从中选出最大值，这样的复杂度是 <code>O（k*n）</code> 级别，复杂度有点高。</p><p>首先滑动窗口滑过所有的元素必然要经历 <code>O(n)</code> 的时间，这没法调整，所以可以优化的方向在于<strong>获取当前窗口的最大值</strong>，即想办法从 <code>O(k)</code> 优化到 <code>O(logk）</code>或者直接优化到 <code>O(1)</code>。</p><p>使用<strong>双端队列</strong>！</p><p>让窗口移动的过程，维护好队列里面的元素，做到<strong>每次窗口移动后</strong>都能马上知道当前窗口的最大值，由于想要做到 <strong>O(1)</strong> 的级别拿到最大值，那么必须是它的<strong>队首始终是最大值</strong>，也就是说我们需要维护一个<strong>递减队列</strong>用来保存队列中 <strong>所有递减的元素</strong> 。</p><p>一开始，窗口中只有 1，队列中放入 1。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/bhbju.jpg" alt="wq"></p><p>窗口滑动，包含了 1 和 3，3 大于 1，如果直接放入队列，队列为 1 3，不是递减队列，所以需要先将 1 移除再放入 3 。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/kge6l.jpg" alt="we"></p><p>继续滑动，窗口元素为 1 3 -1 。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/6v3hl.jpg" alt="wx"></p><p>滑动窗口已经有三个元素，是合格的窗口，获取它的最大值只需要获取队列的<strong>队首</strong>元素就行.</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ua2gr.jpg" alt="wc"></p><p>同样的，窗口不断的向右移动，每次窗口都会增加新的元素，为了让队列中的<strong>队首</strong>元素始终是<strong>当前窗口</strong>的最大值，需要把队列中所有小于新元素值的那些元素移除。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/0scjx.jpg" alt="wv"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/n7x1j.jpg" alt="dvr"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ia1zp.jpg" alt="wfr"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/o0qtc.jpg" alt="wewq"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/lc0g3.jpg" alt="2w"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/pdy68.jpg" alt="wad30"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 登录 AlgoMooc 官网获取更多算法图解</span><br><span class="hljs-comment">// https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// 边界情况</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 构建双端队列</span><br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 构建存储最大值的数组</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 一开始滑动窗口不包含 K 个元素，不是合格的滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// 在滑动过程中，维护好 deque，确保它是单调递减队列</span><br><br>            <span class="hljs-comment">// 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span><br>            <span class="hljs-comment">// 直到考察元素可以放入到队列中</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>                deque.removeLast();<br>            &#125;<br><br>            <span class="hljs-comment">// 考察元素可以放入到队列中</span><br>            deque.addLast(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 这个时候，滑动窗口刚刚好有 k 个元素，是合格的滑动窗口，那么最大值就是队列中的队首元素</span><br>        res[<span class="hljs-number">0</span>] = deque.peekFirst();<br><br><br>        <span class="hljs-comment">// 现在让滑动窗口滑动</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 滑动窗口已经装满了元素，向右移动会把窗口最左边的元素抛弃</span><br>            <span class="hljs-comment">// i - k 为滑动窗口的最左边</span><br>            <span class="hljs-comment">// 如果队列的队首元素和窗口最左边的元素相等，需要将队首元素抛出</span><br>            <span class="hljs-comment">// 如果不写这个判断，会导致队列中会包含非当前窗口的元素</span><br>            <span class="hljs-comment">// 比如窗口大小为 1，队列为 1 -1，此时窗口为 【 1 】,队列为 1，输出最大值 1，下一个窗口为 【 -1 】，准备移动的时候队列 1 和数组最左端元素一样，必须移除，否则队列中是 【 1，-1 】，输出的结果是 1，而 1 不在窗口 【 -1 】中</span><br>            <span class="hljs-keyword">if</span>(deque.peekFirst() == nums[i - k])&#123;<br>                deque.removeFirst();<br>            &#125;<br><br><br>            <span class="hljs-comment">// 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span><br>            <span class="hljs-comment">// 直到考察元素可以放入到队列中</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>                deque.removeLast();<br>            &#125;<br><br>            <span class="hljs-comment">// 考察元素可以放入到队列中</span><br>            deque.addLast(nums[i]);<br>            <span class="hljs-comment">// 此时，结果数组的值就是队列的队首元素</span><br>            res[i - k + <span class="hljs-number">1</span>] = deque.peekFirst();<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 res</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法9[力扣739]-每日温度</title>
    <link href="/2021/08/09/%E7%AE%97%E6%B3%959-%E5%8A%9B%E6%89%A3739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2021/08/09/%E7%AE%97%E6%B3%959-%E5%8A%9B%E6%89%A3739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：<code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>这道题目最 “难” 的一个点是题目的理解。</p><p>给定列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，为啥输出就是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code> ？</p><p>下面来一个个进行解释。</p><p>对于输入 73，它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第二天的时候，温度升高到 74 ，所以对应的结果是 1。</p><p>对于输入 74，它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第三天的时候，温度升高到 75 ，所以对应的结果是 1。</p><p>对于输入 75，它经过 1 天后发现温度是 71，没有超过它，继续等，一直 <strong>等了四天</strong>，在第七天才等到温度的升高，温度升高到 76 ，所以对应的结果是 4 。</p><p>对于输入 71，它经过 1 天后发现温度是 69，没有超过它，继续等，一直 <strong>等了两天</strong>，在第六天才等到温度的升高，温度升高到 72 ，所以对应的结果是 2 。</p><p>对于输入 69，它 <strong>经过一天</strong> 后发现温度是 72，已经超过它，所以对应的结果是 1 。</p><p>对于输入 72，它 <strong>经过一天</strong> 后发现温度是 76，已经超过它，所以对应的结果是 1 。</p><p>对于输入 76，后续 <strong>没有温度</strong> 可以超过它，所以对应的结果是 0 。</p><p>对于输入 73，后续 <strong>没有温度</strong> 可以超过它，所以对应的结果是 0 。</p><p>也就是说，这道题目就是<strong>给你一个值，让你找到右边第一个比它大的数，它们两则的下标差就是输出结果</strong>。</p><p>好了，理解了题意我们来思考如何求解：借助<strong>单独递增栈</strong>来处理。</p><p>具体操作如下：</p><p>遍历整个数组，如果栈不空，且<strong>当前数字大于栈顶元素</strong>，那么如果直接入栈的话就不是 <strong>递增栈</strong> ，所以需要取出栈顶元素，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。</p><p>继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，再将数字入栈，这样就可以一直保持递增栈，且每个数字和第一个大于它的数的距离也可以算出来。</p><h4 id="2-1放入元素"><a href="#2-1放入元素" class="headerlink" title="2.1放入元素"></a>2.1放入元素</h4><p>它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第二天的时候，温度升高到 74 ，所以对应的结果是 1。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/402235a4f6f3238e10b82a01a95e963.png" alt="73"></p><p>替换掉73</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/e80828d7fa387bab730a1da6a94703b.png" alt="替换73"></p><p>放入的比原先在栈中的小时</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/b32d13d60898eabdf758947689fad4f.png" alt="小"></p><p>当放入76后替换</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/31fa09bbd04f5778f1a4003f379ee35.png" alt="76"></p><h3 id="三、代码演示"><a href="#三、代码演示" class="headerlink" title="三、代码演示"></a>三、代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维护一个单调递增栈，栈内元素从栈底到栈顶依次减小</span><br><span class="hljs-comment">     * 入栈的元素要和当前栈内栈首元素进行比较</span><br><span class="hljs-comment">     * 如果大于栈首元素，说明温度比之前更高，那么它们的下标差就是栈首元素等了多少天等到的更高温度的结果</span><br><span class="hljs-comment">     * 如果小于栈首元素，说明温度比之前更低，说明还没有等到更高的温度，直接放入到栈中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br><br>        <span class="hljs-comment">// 构建一个栈,用来存放每日温度的下标</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个数组，用来保存输出结果</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br><br>        <span class="hljs-comment">// 从头开始遍历每天的温度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br><br>            <span class="hljs-comment">// 拿到当天的温度，需要和栈首元素进行比较</span><br>            <span class="hljs-comment">// 如果此时栈不为空并且当天的温度大于栈首元素</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br><br>                <span class="hljs-comment">// 首先获取栈首元素的值，并将元素从栈中移除</span><br>                <span class="hljs-keyword">int</span> preIndex = stack.pop();<br><br>                <span class="hljs-comment">// 它们的下标差就是栈首元素等了多少天等到的更高温度的结果，保存到输出数组 res 中</span><br>                res[preIndex] = i - preIndex;<br>            &#125;<br><br>            <span class="hljs-comment">// 再把当天的温度的下标值存放到栈中</span><br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-comment">// 最后输出 res 数组即可</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法8[力扣155]-最小栈</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%958-%E5%8A%9B%E6%89%A3155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%958-%E5%8A%9B%E6%89%A3155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>设计一个支持 push ，pop ，top 操作，并能在<strong>常数时间</strong>内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>由于需要在常数时间内找到最小的元素，那么说明肯定是不能使用遍历，因为遍历是 O(n) 级别的时间，那么只能使用辅助空间进行存储，这是一种<strong>空间换时间</strong>的思想。</p><p>这里我们设置两个栈：<strong>普通栈</strong>和<strong>辅助栈</strong>。</p><h4 id="1、push-操作"><a href="#1、push-操作" class="headerlink" title="1、push 操作"></a>1、push 操作</h4><p>普通栈：直接添加 push 进来的值</p><p>辅助栈：每次 push 一个新元素的时候，将普通栈中最小的元素 push 进辅助栈中</p><h4 id="2、pop-操作"><a href="#2、pop-操作" class="headerlink" title="2、pop 操作"></a>2、pop 操作</h4><p>普通栈：直接移除普通栈中的栈顶元素</p><p>辅助栈：判断<strong>普通栈</strong>中刚刚移除的栈顶元素值是否和此时<strong>辅助栈</strong>中的栈顶元素相同，如果是则将<strong>辅助栈</strong>中的栈顶元素移除，否则不执行操作，这样的目的是为了让<strong>辅助栈中的栈顶元素始终是普通栈中的最小值</strong>。</p><h4 id="3、top-操作"><a href="#3、top-操作" class="headerlink" title="3、top 操作"></a>3、top 操作</h4><p>普通栈：返回<strong>普通栈</strong>的栈顶元素</p><p>辅助栈：不执行操作</p><h4 id="4、getMin-操作"><a href="#4、getMin-操作" class="headerlink" title="4、getMin 操作"></a>4、getMin 操作</h4><p>普通栈：不执行操作</p><p>辅助栈：返回<strong>辅助栈</strong>的栈顶元素</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br>    <span class="hljs-comment">// 首先定义好两个栈</span><br><br>    <span class="hljs-comment">// 一个栈叫做 stack，负责栈的正常操作</span><br>    Stack&lt;Integer&gt; stack;<br>    <span class="hljs-comment">// 一个栈叫做 minStack，负责获取 stack 中的最小值，它等价于遍历 stack 中的所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈</span><br>    Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 在这个函数中初始化两个栈，传入的参数为空，返回也为空</span><br><br>        <span class="hljs-comment">// 初始化 stack</span><br>        stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 初始化 minStack</span><br>        minStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 新添加的元素添加到 stack 中</span><br>        stack.push(x);<br><br>        <span class="hljs-comment">// 判断 minStack 是否为空，如果为空，直接同时把新添加的元素添加到 minStack 中</span><br><br>        <span class="hljs-comment">// 如果 minStack 不为空</span><br>        <span class="hljs-keyword">if</span> (!minStack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 获取 minStack 的栈顶元素</span><br>            <span class="hljs-keyword">int</span> top = minStack.peek();<br>            <span class="hljs-comment">// 只有新添加的元素不大于 top 才允许添加到 minStack 中，目的是为了让 minStack 从栈底到栈顶是降序的</span><br>            <span class="hljs-keyword">if</span> (x &lt;= top) &#123;<br>                <span class="hljs-comment">// 此时，新添加的元素 x 小于 top，加入到 minStack 后依旧是从栈底到栈顶是降序的</span><br>                minStack.push(x);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 此时，minStack 中没有元素，所以直接把新添加的元素添加到 minStack 中</span><br>            minStack.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// 让 stack 执行正常的 pop 操作就行</span><br>        <span class="hljs-keyword">int</span> pop = stack.pop();<br><br>        <span class="hljs-comment">// 由于 minStack 中的所有元素都是来自于 stack 中，所以 stack 删除元素后，minStack 也要考虑是否需要删除元素</span><br>        <span class="hljs-comment">// 否则的话，minStack 有可能保存一个 stack 中不存在的元素</span><br><br>        <span class="hljs-comment">// 首先，获取 minStack 的栈顶元素</span><br>        <span class="hljs-keyword">int</span> top = minStack.peek();<br>        <span class="hljs-comment">// 再判断 top 这个栈顶元素是否和 stack 移除的元素相等，如果相等，那么需要把 minStack 中的栈顶元素一并移除 </span><br>        <span class="hljs-keyword">if</span> (pop == top) &#123;<br>            <span class="hljs-comment">// 移除 minStack 的栈顶元素</span><br>            minStack.pop();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回 stack 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回 minStack 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法7[力扣232]-用栈实现队列</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%957-%E5%8A%9B%E6%89%A3232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%957-%E5%8A%9B%E6%89%A3232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>请你仅使用两个栈实现先入先出队列。</p><p>队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><ul><li><code>void push(int x)</code>将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code>如果队列为空，返回 true ；否则，返回 false</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><p>如果是栈的插入操作，那我们可以把元素都先插入到 stackIn 中，也就实现了队列的 <strong>入队操作</strong> 。</p><h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><ul><li>当 stackOut 中不为空时，直接操作，此时在 stackOut 中的栈顶元素是最先进入队列的元素，返回该元素即可；</li><li>如果 stackOut 为空且 stackIn 不为空，首先需要把 stackIn 中的元素逐个弹出并压入到 stackOut 中，然后返回 stackOut 的栈顶元素即可。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 首先定义好两个栈</span><br><br>    <span class="hljs-comment">// 一个栈叫做 stackIn，负责进栈操作，相当于队列 queue 中的入队操作</span><br>    Stack&lt;Integer&gt; stackIn;<br>    <span class="hljs-comment">// 一个栈叫做 stackOut，负责出栈操作，相当于队列 queue 中的出队操作</span><br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 在这个函数中初始化两个栈，传入的参数为空，返回也为空</span><br><br>        <span class="hljs-comment">// 初始化 stackIn</span><br>        stackIn = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 初始化 stackOut</span><br>        stackOut = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 新添加的元素添加到 stackIn 中</span><br>        stackIn.push(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// 如果 stackOut 为空，首先需要将 stackIn 中的所有元素添加到 stackOut 中</span><br>        <span class="hljs-comment">// 注意 stackIn 是栈，栈的性质是先进后出，后进先出，所以是不断的将 stackIn 中的栈顶元素添加进 stackOut 中</span><br>        <span class="hljs-keyword">if</span> (stackOut.isEmpty()) &#123;<br>            <span class="hljs-comment">// 通过 while 循环将 stackIn 中的所有元素都取出</span><br>            <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>                <span class="hljs-comment">// stackOut 不断的添加 stackIn 的栈顶元素</span><br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 此时，stackIn 已经为空，直接「移除」 stackOut 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// peek 和 pop 的区别在于是返回栈顶元素而非删除栈顶元素</span><br>        <span class="hljs-comment">// 如果 stackOut 为空，首先需要将 stackIn 中的所有元素添加到 stackOut 中</span><br>        <span class="hljs-comment">// 注意 stackIn 是栈，栈的性质是先进后出，后进先出，所以是不断的将 stackIn 中的栈顶元素添加进 stackOut 中</span><br>        <span class="hljs-keyword">if</span> (stackOut.isEmpty()) &#123;<br>            <span class="hljs-comment">// 通过 while 循环将 stackIn 中的所有元素都取出</span><br>            <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>                <span class="hljs-comment">// stackOut 不断的添加 stackIn 的栈顶元素</span><br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// peek 和 pop 的区别在于是返回栈顶元素而非删除栈顶元素</span><br>        <span class="hljs-comment">// 此时，stackIn 已经为空，直接「返回」 stackOut 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stackOut.peek();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 队列是否为空，判断 stackIn 和 stackOut 是否同时不存在元素</span><br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法6[力扣20]-有效的括号</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%956-%E5%8A%9B%E6%89%A320-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%956-%E5%8A%9B%E6%89%A320-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>1、左括号必须用相同类型的右括号闭合。</li><li>2、左括号必须以正确的顺序闭合。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>有效的括号满足以下几个条件：</p><ul><li>1、字符串的长度一定是偶数。</li><li>2、括号的匹配<strong>遵循右括号和最近的一个左括号进行匹配</strong>，它们匹配成功才有可能是有效的括号</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 当字符串长度为奇数的时候，属于无效情况，直接返回 false</span><br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-comment">// 无效情况，返回 false</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//构建一个栈，用来存储括号</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-comment">// 把字符串转换为数组的形式，方便获取字符串中的每个字符</span><br>        <span class="hljs-keyword">char</span> charArray[] = s.toCharArray();<br><br>        <span class="hljs-comment">// 遍历字符串数组中的所有元素</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; charArray.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 获取此时的字符</span><br>            <span class="hljs-keyword">char</span> c = charArray[i];   <br><br>            <span class="hljs-comment">// 如果字符为左括号 ( ，那么就在栈中添加对左括号 （</span><br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对左括号 （</span><br>               stack.push(<span class="hljs-string">&#x27;(&#x27;</span>);<br><br>             <span class="hljs-comment">// 如果字符为左括号 [ ，那么就在栈中添加对左括号 [</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对应的右括号 ]</span><br>               stack.push(<span class="hljs-string">&#x27;[&#x27;</span>);<br><br>             <span class="hljs-comment">// 如果字符为左括号 &#123; ，那么就在栈中添加对左括号 &#123;</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对应的右括号 &#125;</span><br>               stack.push(<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br><br>               <span class="hljs-comment">// 否则的话，说明此时 c 是 ）] &#125; 这三种符号中的一种</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br><br>               <span class="hljs-comment">// 如果栈已经为空，而现在遍历的字符 c 是 ）] &#125; 这三种符号中的一种</span><br>               <span class="hljs-comment">// 找不到可以匹配的括号，返回 false</span><br>               <span class="hljs-comment">// 比如这种情况  &#125;&#123;，直接从右括号开始，此时栈为空</span><br>               <span class="hljs-keyword">if</span>(stack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>               <span class="hljs-comment">// 如果栈不为空，获取栈顶元素</span><br>               <span class="hljs-keyword">char</span> top = stack.peek();<br><br>               <span class="hljs-comment">// 将栈顶元素和此时的元素 c 进行比较，如果相同，则将栈顶元素移除</span><br>               <span class="hljs-keyword">if</span>( top == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span> || top == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span> || top == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span> )&#123;<br>                   <span class="hljs-comment">// 移除栈顶元素</span><br>                   stack.pop();<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-comment">// 如果不相同，说明不匹配，返回 false</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>               &#125;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 遍历完整个字符数组，判断栈是否为空</span><br>        <span class="hljs-comment">// 如果栈为空，说明字符数组中的所有括号都是闭合的</span><br>        <span class="hljs-comment">// 如果栈为空，说明有未闭合的括号</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法5[力扣11]-盛最多水的容器</title>
    <link href="/2021/08/02/%E7%AE%97%E6%B3%955-%E5%8A%9B%E6%89%A311-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/08/02/%E7%AE%97%E6%B3%955-%E5%8A%9B%E6%89%A311-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>一开始，我们先去考虑<strong>相距最远</strong>的两个柱子所能容纳水的面积。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/0gwk7.jpg" alt="1"></p><p>接下来去思考，我们去移动哪根柱子会更加合适?</p><p>这里我们需要注意一点：<strong>无论移动哪根柱子，柱子之间的宽度都是变小的</strong>。</p><p><strong>移动右边那根更高的柱子？</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/94usx.jpg" alt="移动高柱子"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/gzwnl.jpg" alt="移动高柱字2"></p><p>由于水面高度是由最短的柱子决定的，<strong>所以移动右边那根更高的柱子的时候，水面高度一定是不会增加，甚至有可能遇到更短的柱子而变小，而宽度有一定再减少，所以水的面积也一定减少</strong>。</p><p><strong>移动左边那根更短的柱子？</strong></p><p>这时候，水的高度是不确定的，那么面积也是不确定的，有可能比之前更大，也有可能更小或者相等。</p><p>所以，我们可以得出一个结论：<strong>移动两根柱子之间更短的那根柱子，才有可能在宽度一定变小的情况下，找到一个更高的水面，从而使得面积有可能更大</strong>。</p><p>那接下来这道题目的解法也就有了：</p><p>1、设置两个索引，分别指向容器的两侧，即索引 <code>left</code> 指向最左边的柱子，索引 <code>right</code> 指向最右边的柱子。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/opp73.jpg" alt="移动低柱子"></p><p>2、记录下此时的水的面积，可以定义为 res</p><p>3、<strong>观察需要向内移动哪根柱子</strong></p><ul><li>1）如果移动<strong>较高</strong>的柱子，由于水的宽度在变小，而水的高度一定不会增加，所以最终水的面积不会超过之前记录的水的面积 res</li><li>2）所以，只能移动较短的柱子，然后计算此时水的面积，再与之前记录的水的面积 res 进行比较，保存那个更大的值</li></ul><p>4、再去判断应该向内移动哪根柱子</p><p>5、直到 <code>left</code> 和 <code>right</code> 相遇为止</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br><br>       <span class="hljs-comment">// 设置两个索引，分别指向容器的两侧</span><br><br>       <span class="hljs-comment">// 索引 left 指向最左边的柱子</span><br>       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">// 索引 right 指向最右边的柱子</span><br>       <span class="hljs-keyword">int</span> right = height.length - <span class="hljs-number">1</span>;<br><br>       <span class="hljs-comment">// 设置一个变量用来保存当下水的最大面积</span><br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">// 移动 left 和 right，直到 left 和 right 相遇为止</span><br>       <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>           <span class="hljs-comment">// 水的宽度是 right - left</span><br>           <span class="hljs-keyword">int</span> width = right - left;<br><br>           <span class="hljs-comment">// 水的高度由两根柱子最短的那根决定</span><br>           <span class="hljs-keyword">int</span> h = Math.min(height[left],height[right]);<br><br>           <span class="hljs-comment">// 计算此时水的面积</span><br>           <span class="hljs-keyword">int</span> area = width * h;<br><br>           <span class="hljs-comment">// 如果此时水的面积大于了我们之前保存的那个值，我们需要更新一下</span><br>           <span class="hljs-keyword">if</span>(area &gt;= res)&#123;<br>               <span class="hljs-comment">// 更新 res 的值为 area，确保 res 一直都是最大的值</span><br>               res = area;<br>           &#125;<br><br>           <span class="hljs-comment">// 接下来去观察需要移动哪根柱子：必定是最短的那根柱子</span><br><br>           <span class="hljs-comment">// 如果左边的柱子更短，那么向内移动左边的柱子，因为只有这样，才有可能找到一个更高的水面</span><br>           <span class="hljs-comment">// 在宽度一定变小的情况下，水的面积才有可能增大</span><br>           <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>               <span class="hljs-comment">// 向内移动左边的柱子</span><br>               left++;<br><br>           <span class="hljs-comment">// 如果右边的柱子更短，那么向内移动右边的柱子，因为只有这样，才有可能找到一个更高的水面</span><br>           <span class="hljs-comment">// 在宽度一定变小的情况下，水的面积才有可能增大</span><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 向内移动右边的柱子</span><br>               right--;<br>           &#125;<br><br>       &#125;<br><br>       <span class="hljs-comment">// 最后返回最大的面积 res 即可</span><br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法4[力扣977]-有序数组的平方</title>
    <link href="/2021/08/02/%E7%AE%97%E6%B3%954-%E5%8A%9B%E6%89%A3977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/2021/08/02/%E7%AE%97%E6%B3%954-%E5%8A%9B%E6%89%A3977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>数组本身是有序的，对于一堆正数来说，平方之后顺序不会发生改变；而对于一堆负数来说，平方之后顺序发生了反转。</p><p>对于夹杂着正数和负数的数组来说，里面的负数平方之后有可能变成最大数。</p><p>所以，数组平方的最大值<strong>在数组的两端</strong>，不是最左边（负数）就是最右边（正数），不可能是中间的数字。</p><p>这样，我们设置两个索引，分别指向数组的两端，比如 <code>left</code> 指向起始位置，<code>right</code> 指向终止位置。</p><p>同时在设置一个新数组 <code>result</code> 用来存放最终的输出结果，让 <code>index</code> 指向 <code>result</code> 数组的终止位置。</p><ul><li>如果 <code>A[left] * A[left] &lt; A[right] * A[right]</code>，说明右边数的平方大于左边数的平方，那么 <code>index</code> 存放的数字是更大的那个数 <code>A[right] * A[right]</code>，并且将 <code>right</code> 向内移动，此时，<code>index</code> 已经放置好了正确的数字，将它向前移动，判断接下来应该放那个数字</li><li>如果 <code>A[left] * A[left] &gt;= A[right] * A[right]</code>，说明左边数的平方大于右边数的平方，那么 <code>index</code> 存放的数字是更大的那个数 <code>A[left] * A[left]</code>，并且将 <code>left</code> 向内移动，此时，<code>index</code> 已经放置好了正确的数字，将它向前移动，判断接下来应该放那个数字</li><li>直到新数组 <code>result</code> 存放了所有的平方数</li></ul><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;<br><br>        <span class="hljs-comment">// 我们设置两个索引，分别指向数组的两端</span><br><br>        <span class="hljs-comment">// right 指向终止位置</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// left 指向起始位置</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置一个新数组 result 用来存放最终的输出结果</span><br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 让 index 指向 result 数组的终止位置，观察这个位置应该存放什么数字</span><br>        <span class="hljs-keyword">int</span> index = result.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// left 向右移动，right 向左移动，当 left 大于 right 时，说明已经观察遍历了 nums 数组中的所有元素，跳出循环</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><br>            <span class="hljs-comment">// 说明左边的平方数大于右边</span><br>            <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;<br><br>                <span class="hljs-comment">// result 数组中 index 位置要存放更大的那个数，即 nums[left] * nums[left]</span><br>                result[index] = nums[left] * nums[left];<br><br>                <span class="hljs-comment">// 由于相对较大的数是在 left 位置，上一行代码已经将它赋值到 index 位置</span><br>                <span class="hljs-comment">// 所以此时 left 位置的数已经失去作用，将它向后移动</span><br>                left++;<br><br>                <span class="hljs-comment">// 此时，index 位置已经存放好数，将它向前移动，观察下一个位置应该存放哪个数</span><br>                index--;<br><br>              <span class="hljs-comment">// 说明右边的平方数大于左边</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// result 数组中 index 位置要存放更大的那个数，即 nums[right] * nums[right]</span><br>                result[index] = nums[right] * nums[right];<br><br>                <span class="hljs-comment">// 由于相对较大的数是在 right 位置，上一行代码已经将它赋值到 index 位置</span><br>                <span class="hljs-comment">// 所以此时 right 位置的数已经失去作用，将它向前移动</span><br>                right--;<br><br>                <span class="hljs-comment">// 此时，index 位置已经存放好数，将它向前移动，观察下一个位置应该存放哪个数</span><br>                index--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回我们设置的结果数组即可</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法3[力扣16.16]-部分排序</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%953-%E5%8A%9B%E6%89%A316-16-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%953-%E5%8A%9B%E6%89%A316-16-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个整数数组，编写一个函数，找出索引 m 和 n ，只要将索引区间 [m,n] 的元素排好序，整个数组就是有序的。（默认是递增有序数组）</p><p>注意：n – m 尽量最小，也就是说，找出符合条件的最短序列。</p><p>函数返回值为 [m,n] ，若不存在这样的 m 和 n（例如整个数组是有序的），请返回 [-1,-1] 。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>对于元素 <code>a[i]</code> 来说，如果它左边存在大于 <code>a[i]</code> 的元素，那么 <code>a[i]</code> 是一定要加入到<strong>被排序的序列内</strong>。</p><p>如果它右边存在小于 <code>a[i] 的元素，那么</code>a[i]` 也要加入到<strong>被排序的序列内</strong>。</p><p>所以，我们的目的很明确。</p><p>1、寻找最靠右的那个数，即它的左边存在大于它的数</p><p>2、寻找最靠左的那个数，即它的右边存在小于它的数</p><p><strong>这两个数之间就是要排序的区间</strong>。</p><p>最靠右的数具备以下特征：</p><p>1、它的左边存在大于它的数</p><p>2、它的右边数都比它更大</p><p>3、相对于多个符合 1、2 要求的数，它是最靠右的</p><p>同样的，最靠左的数具备以下特征：</p><p>1、它的右边存在小于它的数</p><p>2、它的左边数都比它更小</p><p>3、相对于多个符合 1、2 要求的数，它是最靠左的</p><h4 id="2-1寻找最左边的数"><a href="#2-1寻找最左边的数" class="headerlink" title="2.1寻找最左边的数"></a>2.1寻找最左边的数</h4><p>它的右侧有一个比它小的时候，他一定在被排序数列中</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/1e2048bcc18dac9c192eb99bffcb39b.png" alt="最左边数"></p><p>此时m值变化，在被排序数列中，继续向左遍历</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/29a0db4fab7d533291ee1ef6ff39466.png" alt="左边的数"></p><p>此时m是最左边的数</p><h4 id="2-2寻找最右边的数"><a href="#2-2寻找最右边的数" class="headerlink" title="2.2寻找最右边的数"></a>2.2寻找最右边的数</h4><p>它左边的数有以一个比它大的时候，他也一定在被排序序列内</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c9837e5a6da0d573e3a91c9dde069f5.png" alt="最右边"></p><p>此时m值变化，继续向右遍历</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/bd3eb1ead543ce1ea6aa589c2981584.png" alt="最右边的数"></p><p>此时n是最右边的数</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] subSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><br>        <span class="hljs-comment">// 如果数组为空、或者数组没有元素、或者数组只有一个元素，找不出符合要求的序列，根据题目要求返回 [-1,-1]</span><br>        <span class="hljs-keyword">if</span>(array == <span class="hljs-keyword">null</span> || array.length == <span class="hljs-number">0</span> || array.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 正常来说，整个数组是递增有序的，比如 1 3 5 9 10 这种</span><br>        <span class="hljs-comment">// 如果某个元素的左边存在比它更大的元素，比如  1 10 5  </span><br>        <span class="hljs-comment">// 5 这个元素的左边存在 10 这个元素比它更大，一定 5 要参与到排序里去的</span><br><br>        <span class="hljs-comment">// 如果某个元素的右边存在比它更小的元素，比如  1 10 5  </span><br>        <span class="hljs-comment">// 10 这个元素的右边存在 5 这个元素比它更小，所以 10 一定要参与到排序里去的</span><br><br>        <span class="hljs-comment">// 所以我们只需要寻找最靠右的那个数（满足左边存在大于它的数）</span><br>        <span class="hljs-comment">// 和最靠左的那个数（满足右边存在小于它的数）</span><br>        <span class="hljs-comment">// 那么这两个数之间就是要排序的区间了</span><br><br>        <span class="hljs-comment">// 第一次遍历是从尾到头进行遍历，目的是为了找出最靠左的那个数，即满足右边存在小于它的数</span><br><br>        <span class="hljs-comment">// 一开始默认最右边的数为最小值</span><br>        <span class="hljs-keyword">int</span> min = array[array.length - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 默认找不到的情况下 m 为 -1</span><br>        <span class="hljs-keyword">int</span> m = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从尾到头进行遍历，直到遍历到数组的开始位置</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = array.length - <span class="hljs-number">2</span> ; j &gt;= <span class="hljs-number">0</span> ; j-- )&#123;<br>            <span class="hljs-comment">// 获取当前遍历的元素值</span><br>            <span class="hljs-keyword">int</span> cur = array[j] ;<br>            <span class="hljs-comment">// 如果此时当前的元素值小于等于最小值，需要更新最小值</span><br>            <span class="hljs-keyword">if</span>(cur &lt;= min)&#123;<br>                <span class="hljs-comment">// 更新最小值</span><br>                min = cur;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果当前元素大于了最小值，由于我们是从尾到头进行遍历，说明当前元素的右边存在小于它的数，这个元素需要加入到排序的区间</span><br>                <span class="hljs-comment">// 比如  10 9 7</span><br>                <span class="hljs-comment">// 最小值是 7 ，而 9 大于 7，所以 9 需要加入到排序的区间</span><br>                <span class="hljs-comment">// 因此更新 m 的值为 j，说明此时遍历的那些元素中 j 是最靠左的那个数</span><br>                m = j;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 第二次遍历是从尾到头进行遍历，目的是为了找出最靠右的那个数，即满足左边存在大于它的数</span><br><br>        <span class="hljs-comment">// 一开始默认最左边的数为最大值</span><br>        <span class="hljs-keyword">int</span> max = array[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 默认找不到的情况下 n 为 -1</span><br>        <span class="hljs-keyword">int</span> n = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从头进行遍历，直到遍历到数组的结束位置</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; array.length ; i++ )&#123;<br>            <span class="hljs-comment">// 获取当前遍历的元素值</span><br>            <span class="hljs-keyword">int</span> cur = array[i] ;<br>            <span class="hljs-comment">// 如果此时当前的元素值大于等于最大值，需要更新最大值</span><br>            <span class="hljs-keyword">if</span>(cur &gt;= max)&#123;<br>                <span class="hljs-comment">// 更新最大值</span><br>                max = array[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果当前元素小于了最大值，由于我们是从头到尾进行遍历，说明当前元素的左边存在大于它的数，这个元素需要加入到排序的区间</span><br>                <span class="hljs-comment">// 比如  10 9 7</span><br>                <span class="hljs-comment">// 最小值是 10 ，而 7 小于 10，所以 7 需要加入到排序的区间</span><br>                <span class="hljs-comment">// 因此更新 n 的值为 i，说明此时遍历的那些元素中 i 是最靠右的那个数</span><br>                n = i;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// m 和 n 这两个数之间就是要排序的区间，返回即可</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;m,n&#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法2[力扣75]-颜色分类</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%952-%E5%8A%9B%E6%89%A375-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%952-%E5%8A%9B%E6%89%A375-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<strong>原地对它们进行排序</strong>，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>设置 3 个索引，<code>left</code> 指向数组的开始位置，<code>right</code> 指向数组的结束位置，<code>index</code> 指向数组的开始位置。</p><p>我们让 <code>index</code> 从头开始向后移动，在移动的过程中，它指向的元素会出现三种情况：</p><ul><li>如果 <code>index</code>位置上的元素值为 0，则说明是红色，要放在<strong>最前面</strong>去，此时最前面的那个元素被 <code>left</code> 指着，所以让 <code>index</code> 指向的元素和 <code>left</code> 指向位置上的元素进行交换，<strong>交换完毕之后</strong>，说明 0 已经在它应该在的位置，即在整个数组的左区域，所以 <code>left</code> 可以向后移动，<code>index</code> 也向后移动</li><li>如果若 <code>index</code> 位置上的元素值为 1，则说明是白色，就应该放在中间，不用管它，继续移动 <code>index</code></li><li>如果 <code>index</code> 位置上的元素值为 2，则说明是蓝色，要放在<strong>最后面</strong>，此时<strong>最后面</strong>的那个元素被 <code>right</code> 指着，所以让 <code>index</code> 指向的元素和 <code>right</code> 指向位置上的元素进行交换，<strong>交换完毕之后</strong>，说明 2 已经在它改在的位置，即在整个数组的右区域，<code>right</code> 向前移动，但由于原先 <code>right</code> 指向的元素可能为 0、1、2 这三种的任何一种，到了 <code>index</code> 后，还需要继续观察一轮，所以 <code>index</code> 先不移动</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// left  指向数组的开始的位置，它指向的位置左侧都是 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right  指向数组的结束的位置，它指向的位置右侧都是 2</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// index 指向数组的开始位置</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// index 向后移动，当它越过 right 时跳出循环，不需要再判断了</span><br>        <span class="hljs-comment">// 因为此时说明 index 右侧的都已经是 2</span><br>        <span class="hljs-keyword">while</span>(index &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 获取当前的元素值</span><br>            <span class="hljs-keyword">int</span> cur = nums[index];<br><br>            <span class="hljs-comment">// 如果 index 位置上的元素值为 0</span><br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-comment">// 说明是红色，要放在最前面去</span><br>              <span class="hljs-comment">// 最前面的那个元素被 left 指着，所以让 index 指向的元素和 left 指向位置上的元素进行交换</span><br>              swap(nums,left,index);<br><br>              <span class="hljs-comment">// index 可以向后移动</span><br>              index++;<br>              <span class="hljs-comment">// left 可以向后移动，它的左侧区域都是 0</span><br>              left++;<br><br>              <span class="hljs-comment">// 如果 index 位置上的元素值为 1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 说明是白色，就应该放在中间，不用管它，继续移动 index</span><br>                index++;<br><br>                <span class="hljs-comment">// 如果 index 位置上的元素值为 2</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">2</span>)&#123;<br><br>                <span class="hljs-comment">// 说明是蓝色，要放在最后面</span><br>                <span class="hljs-comment">// 所以让 index 指向的元素和 right 指向位置上的元素进行交换</span><br>                swap(nums,index,right);<br><br>                <span class="hljs-comment">// 由于原先 right 指向的元素可能为 0、1、2 这三种的任何一种</span><br>                <span class="hljs-comment">// 交换到了 index 后，还需要继续观察一轮，所以 index 先不移动</span><br>                right--;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 通过中间变量，交换两个元素的值</span><br>    <span class="hljs-comment">// nums[i] 的值变为了 nums[j] 的值 </span><br>    <span class="hljs-comment">// nums[j] 的值变为了 nums[i] 的值 </span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i ,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">// 使用临时变量 temp，保存 nums[i] 的值</span><br>        <span class="hljs-keyword">int</span> temp = nums[i];<br><br>        <span class="hljs-comment">// nums[i] 的值修改为 nums[j] 的值</span><br>        nums[i] = nums[j];<br><br>        <span class="hljs-comment">// nums[i] 的值修改为 temp 的值</span><br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法1[力扣88]-合并两个有序数组</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%951-%E5%8A%9B%E6%89%A388-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%951-%E5%8A%9B%E6%89%A388-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>nums1</code> 成为一个<strong>有序数组</strong>。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 m 和 n 。</p><p>你可以假设 <code>nums1</code> 的空间大小等于 m + n，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>设置两个索引 <code>i</code> 和 <code>j</code> 分别指向 nums1 和 nums2 的有效元素的尾部，从它们的尾部开始向前遍历，同时设置索引 <code>cur</code> 指向 <code>nums1</code> 的<strong>最末尾</strong>，在每次遍历过程中，比较 <code>i</code> 和 <code>j</code> 指向的元素值大小，把大的元素填充到 <code>cur</code> 的位置，填充完毕说明那个元素已经放置在它应该放置的位置，不需要在管它了，把 <code>cur</code> 向前移动，同时把 <code>i</code> 或者 <code>j</code> 向前移动，继续比较 <code>i</code> 和 <code>j</code> 指向的元素值大小，把大的元素填充到 <code>cur</code> 的位置。</p><h3 id="2-1初始化数组"><a href="#2-1初始化数组" class="headerlink" title="2.1初始化数组"></a>2.1初始化数组</h3><p>设置两个索引 <code>i</code> 和 <code>j</code> 分别指向 nums1 和 nums2 的有效元素的尾部，从它们的尾部开始向前遍历，同时设置索引 <code>cur</code> 指向 <code>nums1</code> 的<strong>最末尾</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c155109372f4e152dcc4a5ef6713396.png" alt="初始化数组"></p><h4 id="2-2比较索引值的大小"><a href="#2-2比较索引值的大小" class="headerlink" title="2.2比较索引值的大小"></a>2.2比较索引值的大小</h4><h5 id="Ⅰ-当i-lt-j时，将j的值赋值给cur，同时j–，cur–"><a href="#Ⅰ-当i-lt-j时，将j的值赋值给cur，同时j–，cur–" class="headerlink" title="Ⅰ.当i&lt;j时，将j的值赋值给cur，同时j–，cur–"></a>Ⅰ.当i&lt;j时，将j的值赋值给cur，同时j–，cur–</h5><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c2b1a5e394e191456d23267e951b9fc.png" alt="i&lt;j"></p><h5 id="Ⅱ-当i-gt-j时，将i的值赋值给cur，同时i–，cur–"><a href="#Ⅱ-当i-gt-j时，将i的值赋值给cur，同时i–，cur–" class="headerlink" title="Ⅱ.当i &gt;j时，将i的值赋值给cur，同时i–，cur–"></a>Ⅱ.当i &gt;j时，将i的值赋值给cur，同时i–，cur–</h5><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/79097048f87a74ddd14e51d294249d5.png" alt="i&gt;j"></p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 索引从有序数组 nums1 有效元素的末端开始</span><br>        <span class="hljs-comment">// 数组的下标索引从零开始计数</span><br>        <span class="hljs-comment">// 索引   0    1     2</span><br>        <span class="hljs-comment">// 数组 [ 1 ,  2  ,  3 ]</span><br>        <span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 索引从有序数组 nums2 的末端开始</span><br>        <span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从有序数组 nums1 最末端的位置开始保存元素</span><br>        <span class="hljs-keyword">int</span> cur = nums1.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 通过循环把 num2 的元素都移动到 num1 中</span><br>        <span class="hljs-keyword">while</span>( j &gt;= <span class="hljs-number">0</span>  )&#123;<br><br>            <span class="hljs-comment">// 比较 num1 和 num2 中当前的元素大小</span><br><br>            <span class="hljs-comment">// 如果 num1 中的索引位置为 i 的元素大于 num2 中索引位置为 j 的元素</span><br>            <span class="hljs-comment">// 为了防止越界 i 必须是大于等于 0 </span><br>            <span class="hljs-keyword">if</span>( i &gt;=<span class="hljs-number">0</span> &amp;&amp; nums1[i] &gt; nums2[j] )&#123;<br><br>             <span class="hljs-comment">// 把 num1 中的索引位置为 i 的元素复制到索引为 cur 的位置</span><br>             <span class="hljs-comment">// 此时 cur 的元素已经确定下来</span><br>             nums1[cur] = nums1[i];<br><br>             <span class="hljs-comment">// 接下来去确定 cur 前面一个元素应该放什么数字</span><br>             cur--;<br>             <span class="hljs-comment">// 此时，索引 i 需要向前移动</span><br>             i--;<br>             <span class="hljs-comment">// 否则，如果 num1 中的索引位置为 i 的元素小于或者等于 num2 中索引位置为 j 的元素</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>             <span class="hljs-comment">// 把 num2 中的索引位置为 j 的元素复制到索引为 cur 的位置</span><br>             nums1[cur] = nums2[j];<br>             <span class="hljs-comment">// 接下来去确定 cur 前面一个元素应该放什么数字</span><br>             cur--;<br>             <span class="hljs-comment">// 此时，索引 j 需要向前移动</span><br>             j--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记2</title>
    <link href="/2021/06/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2021/06/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h3 id="一、直接内存"><a href="#一、直接内存" class="headerlink" title="一、直接内存"></a>一、直接内存</h3><h4 id="1-Direct-Memory"><a href="#1-Direct-Memory" class="headerlink" title="1.Direct Memory"></a>1.Direct Memory</h4><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-直接内存的基本使用"><a href="#2-直接内存的基本使用" class="headerlink" title="2.直接内存的基本使用"></a>2.直接内存的基本使用</h4><p><strong>文件读写流程：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210629101348239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="文件读写流程"></p><p>java本身不具备磁盘读写的能力，需要调用操作系统的本地方法(用户态——&gt;内核态)。转换到内核态之后读取磁盘文件，会在系统内存中创建一个缓存区，将数据读到内存缓存区，最后再将系统缓存区数据复制到java堆内存中。</p><p>这个缺点是数据存储了两份，在系统内存中有一份，java堆内存中有一份，造成了不必要的复制。</p><p><strong>使用DirectBuffer文件读取流程</strong></p><p><img src="https://img-blog.csdnimg.cn/20210629101710200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="DirectBuffer读取文件"></p><p>在调用directbuffer的allocateDirect方法时，会在操作系统里划出一个缓冲区(direct memory)，能够使操作系统和java代码共享访问，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h4 id="3-直接内存回收原理"><a href="#3-直接内存回收原理" class="headerlink" title="3.直接内存回收原理"></a>3.直接内存回收原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectMemory</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1GB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException </span>&#123;<br><span class="hljs-comment">//        method();</span><br>        method1();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 直接内存 是被 unsafe 创建与回收</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException </span>&#123;<br><br>        Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe = (Unsafe)field.get(Unsafe.class);<br><br>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1GB);<br>        unsafe.setMemory(base,_1GB, (<span class="hljs-keyword">byte</span>)<span class="hljs-number">0</span>);<br>        System.in.read();<br><br>        unsafe.freeMemory(base);<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 直接内存被 释放</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 手动 gc</span><br>        System.in.read();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>直接内存的回收不是通过JVM的垃圾回收来释放的，而是要通过unsafe的freeMemory方法来手动释放。</strong></p><p>第一步：allocateDirect的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>底层创建了一个DirectByteBuffer对象</p><p>第二步：DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">// 申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个 Cleaner 的 create 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是 DirectByteBuffer ）被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 都用函数的 run 方法, 释放内存</span><br>               <span class="hljs-keyword">this</span>.thunk.run();<br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到关键的一行代码， this.thunk.run()，thunk 是 Runnable 对象。run 方法就是回调 Deallocator 中的 run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// Paranoia</span><br>              <span class="hljs-keyword">return</span>;<br>          &#125;<br>          <span class="hljs-comment">// 释放内存</span><br>          unsafe.freeMemory(address);<br>          address = <span class="hljs-number">0</span>;<br>          Bits.unreserveMemory(size, capacity);<br>      &#125;<br></code></pre></td></tr></table></figure><p> <strong>直接内存的回收机制总结</strong></p><ul><li>使用了unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner(虚引用)来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler（守护线程）来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p><strong>注意</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * -XX:+DisableExplicitGC 显示的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 手动 gc 失效</span><br>        System.in.read();<br>    &#125;<br></code></pre></td></tr></table></figure><p>一般用jvm调优时，会加上下面的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+DisableExplicitGC  <span class="hljs-comment">// 静止显示的 GC</span><br></code></pre></td></tr></table></figure><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p><h3 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h3><h4 id="1-判断对象是否可以回收"><a href="#1-判断对象是否可以回收" class="headerlink" title="1.判断对象是否可以回收"></a>1.判断对象是否可以回收</h4><p><strong>1.1引用计数法</strong></p><p>当一个对象被引用一次时，将计数加一，如果不在引用了，则让计数减一。当对象的引用计数为0时，可以被垃圾对象回收。</p><p>但是这种方法有一个弊端，循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。造成内存泄露</p><p><img src="https://img-blog.csdnimg.cn/20210629145523179.png" alt="引用计数法弊端"></p><p><strong>1.2可达性分析算法</strong></p><ul><li>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象作为起点的引用链接找到该对象，如果找不到，则表示可以回收</li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native的方法）引用的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-number">1</span>);<br>        System.in.read();<br><br>        list = <span class="hljs-keyword">null</span>;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以使用如下命令将堆内存信息转储成一个文件，然后使用<br>Eclipse Memory Analyzer 工具进行分析。</p><p>1.使用jps命令，查看程序的进程</p><p><img src="https://img-blog.csdnimg.cn/20210209111015399.png" alt="1.jps"></p><p>2.</p><p><img src="https://img-blog.csdnimg.cn/20210209111229838.png" alt="2"></p><p>使用 jmap -dump:format=b,live,file=1.bin 16104 命令转储文件<br>dump：转储文件<br>format=b：二进制文件<br>file：文件名<br>16104：进程的id</p><p>3.打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析。</p><p><img src="https://img-blog.csdnimg.cn/20210209111656952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="3"></p><p>分析的 gc root，找到了 ArrayList 对象，然后将 list 置为null，再次转储，那么 list 对象就会被回收。</p><p><strong>1.3四种引用</strong></p><p>1）强引用</p><p>2）软引用</p><p>3）弱引用</p><p>4）虚引用</p><p>5）终结器引用</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/ee9e00ff99fecf43b55497950fc6b88.png" alt="四种引用"></p><p>1.强引用</p><p>只要所有的GC Root对象都不通过<strong>强引用</strong>引用该对象，该对象才能被垃圾回收</p><p>2.软引用</p><p><strong>没有直接的被强引用引用时，当垃圾回收后，内存不够时</strong>会再次垃圾回收，回收软引用对象</p><p>可以配合引用队列来释放引用对象</p><p>3.弱引用</p><p><strong>没有直接的被强引用引用时，只要发生了垃圾回收，无论内存是否充足</strong>，都会回收弱引用对象</p><p>可以配合引用队列来释放引用对象</p><p>4.虚引用</p><p>主要配合ByteBuffer使用，被引用对象回收时，会将虚引用进入引用队列，在由Reference Handler线程调用虚引用相关方法释放直接内存</p><p><strong>必须配合队列引用队列使用</strong></p><p>5.终结器引用</p><p><strong>无需手动编码，其内部配合引用队列使用</strong>，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalize线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象。</p><h6 id="演示软引用"><a href="#演示软引用" class="headerlink" title="演示软引用"></a>演示软引用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoSoft</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        method2();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 -Xmx20m , 演示堆内存不足,</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 软引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>method1方法:</p><p>先设置一个堆内存的大小为20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p><p><img src="https://img-blog.csdnimg.cn/20210209125537878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="强引用"></p><p>method2方法:</p><p>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p><p><img src="https://img-blog.csdnimg.cn/20210209130334776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="软引用对象"></p><p>当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用</p><p>修改method2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示 软引用 搭配引用队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209140627985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="结果"></p><h6 id="弱引用演示"><a href="#弱引用演示" class="headerlink" title="弱引用演示"></a>弱引用演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_09_WeakReferenceTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        method1();</span><br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> *<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// 演示 弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(weakReference);<br><br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 弱引用搭配 引用队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            list.add(weakReference);<br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===========================================&quot;</span>);<br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>            System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h4><p><strong>2.1标记清除</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/fe4c2ccf00be3e57ee83dd295024627.png" alt="标记清除"></p><p>优点</p><ul><li>速度较快</li></ul><p>缺点</p><ul><li>会产生内存碎片</li></ul><p><strong>2.2标记整理</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/008510919468859c938504cf17749f7.png" alt="标记整理"></p><p>优点</p><ul><li>没有内存片</li></ul><p>缺点</p><ul><li>速度慢</li></ul><p><strong>2.3复制</strong></p><p><img src="https://img-blog.csdnimg.cn/20210209144026784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt=" 复制"></p><p>优点</p><ul><li>不会有内存碎片</li></ul><p>缺点</p><ul><li>需要占用两倍内存空间</li></ul><h4 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h4><p><img src="https://img-blog.csdnimg.cn/20210209161407621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="分代回收"></p><p>机制</p><ul><li>新创建的对象分配到伊甸园（Eden）区</li><li>当新生代空间不足时，会触发minor gc，伊甸园区（Eden）和幸存区中的from区存活的对象使用<strong>复制</strong>方法复制到幸存区中的to区中，存货对象年龄加一，然后再交换from和to区位置</li><li>minor gc会引发stop the world，暂停其他线程，等待垃圾回收结束后，在恢复线程运行</li><li>当幸存区中的对象年龄超过阈值时（最大为15 （4bit）），会晋升为老年代</li><li>当老年代空间不足时，会先触发minor gc，如果空间仍然不足，则触发full gc，但STW停止的时间更长。</li></ul><p><strong>3.1相关JVM参数</strong></p><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center">-Xms</td></tr><tr><td align="center">堆最大大小</td><td align="center">-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td align="center">新生代大小</td><td align="center">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td align="center">幸存区比例（动态）</td><td align="center">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td align="center">幸存区比例</td><td align="center">-XX:SurvivorRatio=ratio</td></tr><tr><td align="center">晋升阈值</td><td align="center">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td align="center">晋升详情</td><td align="center">-XX:+PrintTenuringDistribution</td></tr><tr><td align="center">GC详情</td><td align="center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td align="center">FullGC 前 MinorGC</td><td align="center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><p><strong>3.2gc分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_10_GCTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，使用前需要设置 jvm 参数。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="/2021/06/10/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/10/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、JVM是什么"><a href="#一、JVM是什么" class="headerlink" title="一、JVM是什么"></a>一、JVM是什么</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>Java Virtual Machine ，Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）。</p><h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h4><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h4 id="3-JVM、JDK、JRE的关系"><a href="#3-JVM、JDK、JRE的关系" class="headerlink" title="3.JVM、JDK、JRE的关系"></a>3.JVM、JDK、JRE的关系</h4><p><img src="https://img-blog.csdnimg.cn/20210207154634171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="JVM、JDK、JRE的关系"></p><h4 id="4-学习路线"><a href="#4-学习路线" class="headerlink" title="4.学习路线"></a>4.学习路线</h4><p><img src="https://img-blog.csdnimg.cn/20210207155820178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="学习路线"></p><ul><li>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</li><li>Method Area：类是放在方法区中。</li><li>Heap：类的实例对象。</li></ul><p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p><h3 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h3><h4 id="Ⅰ-程序计数器"><a href="#Ⅰ-程序计数器" class="headerlink" title="Ⅰ.程序计数器"></a>Ⅰ.程序计数器</h4><p>Program Counter Register 程序计数器（寄存器）</p><p><strong>作用</strong> 记录下一条jvm指令的执行地址行号</p><p><strong>特点</strong> </p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">0: getstatic #20 // PrintStream out = System.out; <br><span class="hljs-number">3</span>: astore_1 <span class="hljs-comment">// -- </span><br><span class="hljs-number">4</span>: aload_1 <span class="hljs-comment">// out.println(1); </span><br><span class="hljs-number">5</span>: iconst_1 <span class="hljs-comment">// -- </span><br>6: invokevirtual #26 // -- <br><span class="hljs-number">9</span>: aload_1 <span class="hljs-comment">// out.println(2); </span><br><span class="hljs-number">10</span>: iconst_2 <span class="hljs-comment">// -- </span><br>11: invokevirtual #26 // -- <br><span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// out.println(3); </span><br><span class="hljs-number">15</span>: iconst_3 <span class="hljs-comment">// -- </span><br>16: invokevirtual #26 // -- <br><span class="hljs-number">19</span>: aload_1 <span class="hljs-comment">// out.println(4); </span><br><span class="hljs-number">20</span>: iconst_4 <span class="hljs-comment">// -- </span><br>21: invokevirtual #26 // -- <br><span class="hljs-number">24</span>: aload_1 <span class="hljs-comment">// out.println(5); </span><br><span class="hljs-number">25</span>: iconst_5 <span class="hljs-comment">// -- </span><br>26: invokevirtual #26 // -- <br><span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</li></ul><h3 id="Ⅱ-虚拟机栈"><a href="#Ⅱ-虚拟机栈" class="headerlink" title="Ⅱ.虚拟机栈"></a>Ⅱ.虚拟机栈</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><p><img src="https://img-blog.csdnimg.cn/2021062110122114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="栈"></p><h4 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        method1();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        method2(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = a + b;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>演示效果</p><p><img src="https://img-blog.csdnimg.cn/20210610175334410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>问题解析</strong></p><ol><li><p>垃圾回收是否涉及栈内存？</p><ul><li>不会，栈内存是方法调用产生的，方法调用结束后会自动弹出栈。</li></ul></li><li><p>栈内存分配越大越好吗？</p><ul><li>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。例如物理内存500M 一个线程占用1M 可以运行500个线程，如果改为2M，则运行250个线程。</li></ul></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p><strong>如果方法内局部变量没用逃离方法的作用访问，它是线程安全的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>StringBuilder是线程内的一个局部变量，属于每个线程私有的，其他线程不能同时访问</li></ul></li><li><p><strong>如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span></span>&#123;<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>StringBuilder对象是作为方法的参数传递进来，有可能有其他的线程能访问到他。需要改成StringBuffer来保证线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>  <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虽然SrtingBuilder是方法内的局部变量，但是把它当初返回结果返回了，这就意味着其他线程可能会拿到这个对象的引用。</li></ul></li></ul></li></ol><h4 id="3-栈内存溢出"><a href="#3-栈内存溢出" class="headerlink" title="3.栈内存溢出"></a>3.栈内存溢出</h4><ol><li>栈帧过多导致内存溢出（递归调用太多）</li></ol><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/49MBC%25%60QS%7BYDUK%7EZ822J%7BQH.png" alt="栈内存溢出1"></p><ol start="2"><li><p>栈帧过大导致内存溢出</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/05/06/B6EFD%5DJ6XL1S%5DFF184YQK%281.png" alt="栈内存溢出2"></p><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小</p><h4 id="4-线程运行诊断"><a href="#4-线程运行诊断" class="headerlink" title="4.线程运行诊断"></a>4.线程运行诊断</h4><p>[案例1]：CPU占用太多</p><p>Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><p><strong>解决方法</strong></p><ul><li>top 命令，查看是哪个进程占用 CPU 过高</li><li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</li><li>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ul><p>[案例2]：程序运行很长时间没有结果</p><p>多个线程发生死锁</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/P%5DYL2PNK%25WQ0W4D_8%5D%60%28%29FT.png" alt="死锁"></p><p>​</p></li></ol><h3 id="Ⅲ-本地方法栈"><a href="#Ⅲ-本地方法栈" class="headerlink" title="Ⅲ.本地方法栈"></a>Ⅲ.本地方法栈</h3><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h3 id="Ⅳ-堆"><a href="#Ⅳ-堆" class="headerlink" title="Ⅳ.堆"></a>Ⅳ.堆</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><p>Heap 堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li></ul><p><strong>特点</strong></p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h4 id="2-堆内存溢出"><a href="#2-堆内存溢出" class="headerlink" title="2.堆内存溢出"></a>2.堆内存溢出</h4><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出，可以使用 -Xmx8m 来指定堆内存大小。</p><h4 id="3-堆内存诊断"><a href="#3-堆内存诊断" class="headerlink" title="3.堆内存诊断"></a>3.堆内存诊断</h4><ul><li>jps工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li>jmap工具<ul><li>查看堆内存占用情况 jmap - heap 进程id</li></ul></li><li>jconsole工具<ul><li>图形界面的，多功能的检测工具，可以连续监测</li></ul></li><li>jvisualvm 工具</li></ul><h3 id="Ⅴ-方法区"><a href="#Ⅴ-方法区" class="headerlink" title="Ⅴ.方法区"></a>Ⅴ.方法区</h3><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h4><p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/G9%2817Z%2462XV0JK5RNTC3GL7.png" alt="Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图"></p><h4 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h4><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h4 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h4><p>二进制字节码包含（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）<br>首先看看常量池是什么，编译如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用javap -v Hello.class 命令反编译查看结果。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/53Q%281%609K_UN%7D%29%24RTS%7BF%28R%7DA.png" alt="编译结果"></p><p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/%5DK13P%7E3%24RJJ%40XWT01NFNSL0.png" alt="常量池"></p><ul><li><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li><li><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul><h4 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h4><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><p><strong>intern方法 1.8</strong><br>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li><p>如果串池中没有该字符串对象，则放入成功</p></li><li><p>如果有该字符串对象，则放入失败</p><p>无论放入是否成功，都会返回串池中的字符串对象</p></li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p>[案例1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span><br>String st2 = str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>[案例2]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span><br>String str2 = str.intern();<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">// true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试案例题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// ab</span><br>        String s4 = s1 + s2; <span class="hljs-comment">// new String(&quot;ab&quot;)</span><br>        String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s6 = s4.intern();<br><br>        <span class="hljs-comment">//=====================问======================//</span><br>        System.out.println(s3 == s4); <span class="hljs-comment">//false</span><br>        System.out.println(s3 == s5); <span class="hljs-comment">//true</span><br>        System.out.println(s3 == s6); <span class="hljs-comment">//true</span><br><br><br>        String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>        x2.intern();<br><br>        <span class="hljs-comment">//=======问 如果调换x1，x2位置?,如果是jdk1.6?======//</span><br>        System.out.println(x1 == x2); <span class="hljs-comment">//false</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>s3为常量字符串拼接，在编译器优化为ab，此时常量池没有ab，会入池。s4为两个变量的拼接，在运行期间通过StringBulider进行拼接，最后产生新的字符串放在堆中(new String(“ab”))。 </p><p><strong>String Table的位置</strong></p><p>jdk1.6中 String Table在永久代中，jdk1.8 String Table在堆中</p><p><strong>String Table垃圾回收</strong></p><ul><li>Xmx10m –&gt; 指定堆内存大小</li><li>XX:+PrintStringTableStatistics –&gt;打印字符串常量池信息</li><li>XX:+PrintGCDetails</li><li>verbose:gc –&gt;打印 gc 的次数，耗费时间等信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_05_StringTableTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123; <span class="hljs-comment">// j = 100, j = 10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>String Table内存调优</strong></p><p>因为String Table是HashTable实现的，可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</p><p>-XX:StringTableSize=桶个数（最少设置为 1009 以上）</p><ul><li>考虑是否需要将字符串对象入池，可以通过 intern 方法减少重复入池</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记5 集合类的一些常见问题</title>
    <link href="/2021/04/27/Java%E7%AC%94%E8%AE%B05-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/27/Java%E7%AC%94%E8%AE%B05-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h3><ol><li>容量自增长</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="java集合的快速失败机制“fail-fast”？"><a href="#java集合的快速失败机制“fail-fast”？" class="headerlink" title="java集合的快速失败机制“fail-fast”？"></a>java集合的快速失败机制“fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变操作时，有可能会产生fail-fast机制</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p><strong>原因</strong>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发送变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>解决办法</strong></p><ol><li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol><h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>可以使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class="hljs-string">&quot;y&quot;</span>);<span class="hljs-comment">//运行此行时报错</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure><h3 id="迭代器Iterator是什么"><a href="#迭代器Iterator是什么" class="headerlink" title="迭代器Iterator是什么"></a>迭代器Iterator是什么</h3><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration，迭代器允许调用者在迭代过程中移除元素</p><h4 id="1-Iterator怎么使用，有什么特点"><a href="#1-Iterator怎么使用，有什么特点" class="headerlink" title="1.Iterator怎么使用，有什么特点"></a>1.Iterator怎么使用，有什么特点</h4><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  String obj = it.next();<br>  System.out.println(obj)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><p>Iterator的特点是只能单向遍历，但是更加安全，它可以确保在当前遍历的集合元素被更改的时候，会抛出 ConcurrentModificationException 异常。</p><h4 id="2-Iterator和Listiterator有什么区别"><a href="#2-Iterator和Listiterator有什么区别" class="headerlink" title="2.Iterator和Listiterator有什么区别"></a>2.Iterator和Listiterator有什么区别</h4><ul><li>Iterator可以遍历Set和List集合，而ListIterator只能遍历List</li><li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/向后遍历）</li><li>ListIterator实现Iterator接口，然后添加了一些额外的功能，比如添加一个元素，替换一个元素，获取前面或后面元素的索引位置。</li></ul><h3 id="如何边遍历边移除Collection中的元素"><a href="#如何边遍历边移除Collection中的元素" class="headerlink" title="如何边遍历边移除Collection中的元素"></a>如何边遍历边移除Collection中的元素</h3><p>边遍历边修改Collection的唯一正确方式是使用Iterator.remove()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  <span class="hljs-comment">//do something</span><br>  it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Integer i : list)&#123;<br>  list.remove(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h3 id="遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么"><a href="#遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么" class="headerlink" title="遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么"></a>遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么</h3><p><strong>遍历方式有以下几种：</strong></p><ol><li>for循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每个位置的元素，当读取到最后一个元素后停止</li><li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。java在Collections中支持了Iterator模式</li><li>foreach循环遍历。foreach内部也是采用了Iterator的方式实现，使用时不需要显式声明Iterator或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合、例如删除、替换</li></ol><p><strong>最佳实践</strong></p><p>Java Collections框架中提供了一个RandomAccess接口，用来标记List实现是否支持RandomAccess</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持Random Access，按位置读取元素的平均时间复杂度为O(1)，如ArrayList</li><li>如果没有实现该接口，表示不支持Random Access，如LinkedList</li></ul><p>推荐做法是，支持Random Access的列表可用for遍历循环，否则建议用Iterator或foreach遍历。</p><h3 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h3><ul><li>数组转list：使用Arrays.asList(array)进行转换</li><li>List转数组：使用List自带的toArray()方法</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>lsit.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.toArray();<br><br><span class="hljs-comment">//array to list</span><br>String[] array = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;213&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>&#125;;<br>Arrays.asList(array);<br></code></pre></td></tr></table></figure><h3 id="多线程场景下如何使用ArrayList"><a href="#多线程场景下如何使用ArrayList" class="headerlink" title="多线程场景下如何使用ArrayList"></a>多线程场景下如何使用ArrayList</h3><p>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections的synchronizedList方法将其转换成线程安全的容器后在使用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);<br>synchronizedList.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>synchronizedList.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; synchronizedList.size();i++)&#123;<br>  System.out.println(synchronizedList.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么ArrayList的elementData加上transient修饰"><a href="#为什么ArrayList的elementData加上transient修饰" class="headerlink" title="为什么ArrayList的elementData加上transient修饰"></a>为什么ArrayList的elementData加上transient修饰</h3><p>ArrayList中的数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData;<br></code></pre></td></tr></table></figure><p>ArrayList的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;,<span class="hljs-title">RandomAccess</span>,<span class="hljs-title">Cloneable</span>,<span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></table></figure><p>可以看到ArrayList实现了Serializable接口，这意味着ArrayList支持序列化。transient的作用是说不希望elementData数组被序列化，重写了writeObject实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span> <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;<br>    *<span class="hljs-comment">// Write out element count, and any hidden stuff*</span><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;<br>    s.defaultWriteObject();<br>    *<span class="hljs-comment">// Write out array length*</span><br>        s.writeInt(elementData.length);<br>    *<span class="hljs-comment">// Write out all elements in the proper order.*</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>            s.writeObject(elementData[i]);<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>每次序列化时，先调用defaultWriteObject()方法序列化ArrayList中的非transient元素，然后遍历elementData，只序列化已存入的元素，这样即加快了序列化的速度，又减小了序列化之后的文件大小</p><h3 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="1-HashSet如何检查重复，HashSet是如何保证数据不重复的？"><a href="#1-HashSet如何检查重复，HashSet是如何保证数据不重复的？" class="headerlink" title="1.HashSet如何检查重复，HashSet是如何保证数据不重复的？"></a>1.HashSet如何检查重复，HashSet是如何保证数据不重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>HashSet部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>hashCode()与equals()相关规定</strong></p><ol><li>如果两个对象相等，则hashCode一定是相同的</li><li>两个对象相等，对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashcode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同的</li><li>==是指对内存地址进行比较，equals是对字符串的内容进行比较</li><li>==指引用是否相同，equals指的是值是否相同</li></ol><h4 id="2-HashSet与HashMap的区别"><a href="#2-HashSet与HashMap的区别" class="headerlink" title="2.HashSet与HashMap的区别"></a>2.HashSet与HashMap的区别</h4><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用put()向map中添加元素</td><td align="center">调用add()方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用(Key)计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，如果两个对象来说hashcode可能相同，所以equals方法用来判断对象的相等性，如果两个对象不同的话，返回false</td></tr><tr><td align="center">HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td align="center">HashSet较HashMap来说比较慢</td></tr></tbody></table><h3 id="BlockingQueue是什么"><a href="#BlockingQueue是什么" class="headerlink" title="BlockingQueue是什么"></a>BlockingQueue是什么</h3><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><h4 id="在Queue中poll和remove有什么区别"><a href="#在Queue中poll和remove有什么区别" class="headerlink" title="在Queue中poll和remove有什么区别"></a>在Queue中poll和remove有什么区别</h4><ul><li>相同点：都是返回与第一个元素，并在队列中删除返回的对象</li><li>不同点：如果没有元素poll()会返回null，而remove()会直接抛出NoSuchElementException异常</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>queue. offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br></code></pre></td></tr></table></figure><h3 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h3><p>当我们put的时候，首先计算key的hash值，这里调用了hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以hash函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<strong>index = (table.length - 1)&amp;hash</strong>,如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img src="https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="putVal方法执行流程图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//实现Map.put和相关方法</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 步骤①：tab为空则创建 </span><br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 步骤②：计算index，并对null做处理  </span><br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 步骤③：节点key存在，直接覆盖value </span><br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// 步骤④：判断该链为红黑树 </span><br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 步骤⑤：该链为链表 </span><br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <br>                <span class="hljs-comment">//判断该链表尾部指针是不是空的</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">//链表结构转树形结构</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 步骤⑥：超过最大容量就扩容 </span><br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的"><a href="#HashMap的扩容操作是怎么实现的" class="headerlink" title="HashMap的扩容操作是怎么实现的"></a>HashMap的扩容操作是怎么实现的</h3><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阈值时或者初始化时，就调用resize方法进行扩容</li><li>每次扩展的时候，都是扩展2倍</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab指向hash桶数组</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果oldCap不为空的话，就是hash桶数组不为空</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于最大容量了，就赋值为整数最大的阀值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<span class="hljs-comment">//返回</span><br>        &#125;<span class="hljs-comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold 双倍扩容阀值threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span><br>    <span class="hljs-comment">// 直接将该值赋给新的容量</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 新的threshold = 新的cap * 0.75</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 计算出新的数组长度后赋给当前成员变量table</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<span class="hljs-comment">//新建hash桶数组</span><br>    table = newTab;<span class="hljs-comment">//将新数组的值复制给旧的hash桶数组</span><br>    <span class="hljs-comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历新数组的所有桶下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// 用同样的hash映射算法把该元素加入新的数组</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 遍历链表</span><br>                    <span class="hljs-keyword">do</span> &#123;             <br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br>                                <span class="hljs-comment">// 代表下标保持不变的链表的头元素</span><br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span>                                <br>                                <span class="hljs-comment">// loTail.next指向当前e</span><br>                                loTail.next = e;<br>                            <span class="hljs-comment">// loTail指向当前的元素e</span><br>                            <span class="hljs-comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br>                            <span class="hljs-comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br>                            <span class="hljs-comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br>                            loTail = e;                           <br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><ul><li>在解决问题之前需要先知道<strong>什么是哈希冲突</strong>，在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</li></ul><h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong></p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p><h4 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h4><ol><li><strong>使用链地址法（使用散列表）来链接拥有相同hash值的数据</strong></li><li><strong>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong> </li><li><strong>引入红黑树进一步降低遍历的时间复杂度，使得遍历的更快。</strong> </li></ol><h3 id="能否使用任何类作为Map的key？"><a href="#能否使用任何类作为Map的key？" class="headerlink" title="能否使用任何类作为Map的key？"></a>能否使用任何类作为Map的key？</h3><p>可以使用任何类作为Map的key，但需要注意这几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h3 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h3><ul><li>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少hash碰撞的几率</li></ul><ol><li>都是final类型，既不可变性、保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals(),hashCode()等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况</li></ol><h3 id="如果使用Object作为HashMap的Key，应该怎么办？"><a href="#如果使用Object作为HashMap的Key，应该怎么办？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办？"></a>如果使用Object作为HashMap的Key，应该怎么办？</h3><ul><li>重写hashCode()和equals方法</li></ul><ol><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性；</strong></li></ol><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标</h3><ul><li>hashCode()方法返回的是int整数类型，其范围为-(2 [^ 31])<del>(2[^ 31]  - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2[^30] ，HashMap()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置。</li></ul><p><strong>怎么解决</strong></p><ol><li>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p>这个算法应该如何设计呢？</p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p>那为什么是两次扰动呢？</p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h3 id="comparable和comparator的区别"><a href="#comparable和comparator的区别" class="headerlink" title="comparable和comparator的区别"></a>comparable和comparator的区别</h3><ul><li>comparable接口实际上是出自java.lang包，他有一个comparaTo(Object object)方法来排序</li><li>comparator接口实际上是出自java.util包，他有一个compare(Object obj1，Object obj2)方法用来排序</li></ul><h3 id="Collection和Collections有什么区别"><a href="#Collection和Collections有什么区别" class="headerlink" title="Collection和Collections有什么区别"></a>Collection和Collections有什么区别</h3><ul><li>java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记4 集合类</title>
    <link href="/2021/04/27/Java%E7%AC%94%E8%AE%B04-%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2021/04/27/Java%E7%AC%94%E8%AE%B04-%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、集合与数组的区别"><a href="#一、集合与数组的区别" class="headerlink" title="一、集合与数组的区别"></a>一、集合与数组的区别</h3><ul><li>长度区别：集合长度可变，数组长度不可变</li><li>内容区别：集合可以存储不同类型元素，数组只能存储单一元素类型</li><li>元素区别：集合只能存储引用类型元素，数组可存储引用类型，也可以存储基本类型</li></ul><h4 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1.集合概述"></a>1.集合概述</h4><p>java结构图：</p><p><img src="https://img-blog.csdnimg.cn/20210409193629391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU1OTU3NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>粉色框为接口，紫色框是实现类</strong></p><ul><li>Java集合有两大接口，Collection和Map，他们为同一个层次。</li><li><strong>Collection</strong> 接口被<strong>List</strong>接口和<strong>Set</strong>接口继承</li><li>List接口有三个实现类，<strong>ArrayList，LinkedList，Vector</strong></li><li>Set接口被<strong>HashSet</strong>类实现，被<strong>SortedSet接口</strong>继承，同时TreeSet类实现SortedSet接口，<strong>LinkedHashSet类</strong>继承HashSet类</li></ul><ul><li><strong>Map</strong>接口有两个实现类，HashMap，HashTable，同时<strong>Properties类</strong>继承HashTable</li><li>Map接口被SortedMap接口继承，同时TreeMap类实现了SortedMap接口</li></ul><h3 id="二、详述"><a href="#二、详述" class="headerlink" title="二、详述"></a>二、详述</h3><h4 id="1-Collection接口（单列集合）"><a href="#1-Collection接口（单列集合）" class="headerlink" title="1.Collection接口（单列集合）"></a>1.Collection接口（单列集合）</h4><p>Collection接口是<strong>（单列集合）</strong>的最顶层接口，定义了一些通用的方法</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">add(E e)</td><td align="center">添加元素</td></tr><tr><td align="center">clear()</td><td align="center">清空元素</td></tr><tr><td align="center">remove(E e)</td><td align="center">移除元素</td></tr><tr><td align="center">size()</td><td align="center">元素数量</td></tr><tr><td align="center">toArray()</td><td align="center">集合转数组</td></tr><tr><td align="center">contain(E e)</td><td align="center">判断元素是否存在</td></tr><tr><td align="center">isEmpty()</td><td align="center">判断集合是否为空</td></tr></tbody></table><h5 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h5><p>特点：</p><ul><li>有索引，精准操作元素</li><li>元素有序，存储及取出时顺序一致</li><li>元素<strong>可重复</strong>， 通过.equals()比较是否重复</li><li>它利用索引（index），定义了一些方法：</li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">get(int index,E e)</td><td align="center">获取指定位置的元素</td></tr><tr><td align="center">remove(int index)</td><td align="center">移除指定位置的元素</td></tr><tr><td align="center">add(int index,E e)</td><td align="center">将元素添加到指定位置</td></tr><tr><td align="center">set(int index,E e)</td><td align="center">用元素替换指定位置的元素</td></tr></tbody></table><h6 id="1-1-1ArrayList实现类"><a href="#1-1-1ArrayList实现类" class="headerlink" title="1.1.1ArrayList实现类"></a>1.1.1ArrayList实现类</h6><p>数据结构：数组</p><p><strong>特点：</strong> <strong>查询快，增删慢，主要用于查询遍历数据，为常用集合之一；</strong></p><p>底层分析：数组结构是有序的元素序列，在内存中开辟一段连续的空间，在空间中存放元素，每个空间都有编号，通过编号可以快速找到相应的元素，因此查询快；数组初始化时长度是固定的，要想增删元素，必须创建一个新数组，把原数组的元素复制过来，随后原数组销毁，耗时长，因此增删慢。</p><h6 id="1-1-2LinkedList实现类"><a href="#1-1-2LinkedList实现类" class="headerlink" title="1.1.2LinkedList实现类"></a>1.1.2LinkedList实现类</h6><p>数据结构：双向链表</p><p><strong>特点：查询慢，增删快。</strong></p><p>底层分析：链表分为单向和双向，就是一条链子和两条链子的区别；多出的那条链子记录了元素的顺序，因此单向链表结构无序，双向链表结构有序；链表结构没有索引，因此查询慢；链表的增删只需在原有的基础上连上或切断</p><p>链子，因此增删快。</p><p>特有方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">getFirst()</td><td align="center">返回头元素</td></tr><tr><td align="center">getLast()</td><td align="center">返回结尾元素</td></tr><tr><td align="center">pop()</td><td align="center">从所在堆栈中获取一个元素</td></tr><tr><td align="center">push(E e)</td><td align="center">将元素推入所在堆栈</td></tr><tr><td align="center">addFirst(E e)</td><td align="center">添加元素到开头，头插</td></tr><tr><td align="center">addLast(E e)</td><td align="center">添加元素到结尾，尾插</td></tr></tbody></table><h6 id="1-1-3Vector实现类（基本不用）"><a href="#1-1-3Vector实现类（基本不用）" class="headerlink" title="1.1.3Vector实现类（基本不用）"></a>1.1.3Vector实现类（基本不用）</h6><p>数据结构：数组</p><p><strong>特点：查询快，增删慢</strong></p><p>底层分析：和ArrayList一样，都是数组的实现，因此具有相似的特征，他们之间的区别在于Vector是线程安全的，效率低，ArrayList是线程不安全的，但效率高。</p><h5 id="1-2Set接口"><a href="#1-2Set接口" class="headerlink" title="1.2Set接口"></a>1.2Set接口</h5><p>特点：</p><ul><li>元素<strong>不可重复</strong></li><li>元素<strong>无序</strong>，存储及取出时顺序不一样</li><li>没有索引，因此<strong>不能</strong>使用普通的For循环遍历</li></ul><p>Set与Collection接口中的方法基本一致，b不需进行功能上的补充。</p><h6 id="1-2-1HashSet实现类"><a href="#1-2-1HashSet实现类" class="headerlink" title="1.2.1HashSet实现类"></a>1.2.1HashSet实现类</h6><p>数据结构：JDK1.8前：哈希表（数组+单向链表）；JDK1.8后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素无序，元素不可重复，没有索引</strong></p><p>底层分析：HashSet 是基于 HashMap 实现的，哈希表底层数组+单向链表实现，即使用链表处理冲突，同一Hash的值的元素都存储在一个链表里，但是当位于一个链表中的元素较多，即hash值相等的元素较多，通过key值依次查找的效率降低。JDK1.8之后，哈希表底层采用数据+单向链表+红黑树实现，当链表长度超过阈值（8）时，链表将转换为红黑树，极大缩短查询时间。</p><p><em>哈希值是一个十进制的整数，是对象的地址值，是一个逻辑地址，不是实际存储的物理地址，由系统随机给出。Object类的int hashCode()方法，可以获取对象的哈希值</em>。</p><h6 id="1-2-2LinkedHashSet实现类"><a href="#1-2-2LinkedHashSet实现类" class="headerlink" title="1.2.2LinkedHashSet实现类"></a>1.2.2LinkedHashSet实现类</h6><p>数据结构：JDK1.8前：哈希表（数组+双向链表）；JDK1.8后：哈希表（数组+双向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素有序，元素不可重复，没有索引；</strong></p><p>底层分析：作为HashSet的子类，只是比它多了一条链表，这条链表用来记录元素顺序，因此LinkedHashSet其中的元素有序。</p><h6 id="1-2-3TreeSet实现类"><a href="#1-2-3TreeSet实现类" class="headerlink" title="1.2.3TreeSet实现类"></a>1.2.3TreeSet实现类</h6><p>数据结构：红黑树</p><p><strong>特点：查询快，元素有序，元素不可重复，没有索引；</strong></p><p>底层分析：TreeSet实现了继承于Set接口的SortedSet接口，它支持两种排序方法，自然排序和定制排序，自然排序的意思就是放入元素“a”，“b“，a会自然地排在b前面，其中还有几种特有方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">first()</td><td align="center">返回第一个元素</td></tr><tr><td align="center">last()</td><td align="center">返回最后一个元素</td></tr><tr><td align="center">comparator()</td><td align="center">返回排序比较器</td></tr></tbody></table><h4 id="2-Map接口（双列集合）"><a href="#2-Map接口（双列集合）" class="headerlink" title="2.Map接口（双列集合）"></a>2.Map接口（双列集合）</h4><p>特点：</p><ul><li>元素包含两个值（key,value）即键值对，key不允许重复，value可以重复，key与value是一一对应的。</li><li>元素无序</li></ul><p>Map接口是<strong>双列集合</strong>的最顶层接口，定义了一些通用的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">put(key,value)</td><td align="center">添加元素</td></tr><tr><td align="center">remove(key)</td><td align="center">删除key元素</td></tr><tr><td align="center">containKey(key)</td><td align="center">判断是否存在key对应的元素</td></tr><tr><td align="center">get(key)</td><td align="center">获取key对应的元素</td></tr><tr><td align="center">KeySet()</td><td align="center">获取所有的key，存到Set集合中</td></tr><tr><td align="center">entrySet()</td><td align="center">获取所有的元素，存到Set集合中</td></tr></tbody></table><p><em>Map集合必须保证<strong>key唯一</strong>，作为key，必须重写hashCode方法和equals方法，以保证key唯一。</em></p><h5 id="2-1HashMap实现类"><a href="#2-1HashMap实现类" class="headerlink" title="2.1HashMap实现类"></a>2.1HashMap实现类</h5><p>数据结构：JDK1.8之前：哈希表（数组+单向链表）；JDK1.8之后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素无序，key不允许重复但可以为null，value可以重复</strong></p><p>底层分析：和HashSet底层类似。</p><h5 id="2-2HashTable实现类（基本不用）"><a href="#2-2HashTable实现类（基本不用）" class="headerlink" title="2.2HashTable实现类（基本不用）"></a>2.2HashTable实现类（基本不用）</h5><p>数据结构：哈希表</p><p><strong>特点：查询快，元素无序，key不允许重复并且不可以为null，value可以重复</strong></p><p>底层分析：HashTable和Vector一样是古老的集合，有遗留缺陷，在JDK1.2后，被更先进的集合取代，HashTable是线程安全的，速度慢，HashMap是线程不安全的，速度快；</p><p><em>HashTable的子类properties现在依然活跃，properties集合是一个唯一和IO流结合的集合。</em></p><h5 id="2-3TreeMap实现类"><a href="#2-3TreeMap实现类" class="headerlink" title="2.3TreeMap实现类"></a>2.3TreeMap实现类</h5><p>数据结构：红黑树</p><p><strong>特点：查询快，元素有序，key不允许重复并且不可以为null，value可以重复。</strong></p><p>底层分析：和TreeSet底层类似。</p><hr><p>学习文章：<a href="https://blog.csdn.net/weixin_42559574/article/details/108203595">https://blog.csdn.net/weixin_42559574/article/details/108203595</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记3 多线程常见问题</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是多线程"><a href="#一、什么是多线程" class="headerlink" title="一、什么是多线程"></a>一、什么是多线程</h3><p>线程是指程序在运行的过程中，能够执行程序代码的一个执行单元。</p><p>java语言中，线程有五种状态：新建、就绪、运行、阻塞、死亡。</p><p><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt="img"></p><h3 id="二、进程与线程的区别？"><a href="#二、进程与线程的区别？" class="headerlink" title="二、进程与线程的区别？"></a>二、进程与线程的区别？</h3><p>进程是指一段正在执行的程序。而线程有时也被成为轻量级的进程，它是程序执行的最小单元，一个进程可以有多个线程。各个线程之间共享程序的内存空间（代码段、数据段、堆空间）及一些进程级的文件（列如：打开的文件），但是各个线程拥有自己的栈空间。在操作系统级别上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行。 </p><h3 id="三、为什么要使用多线程？"><a href="#三、为什么要使用多线程？" class="headerlink" title="三、为什么要使用多线程？"></a>三、为什么要使用多线程？</h3><ul><li><strong>提高执行效率，减少程序的响应时间。</strong>因为单线程执行的过程只有一个有效的操作序列，如果某个操作很耗时（或等待网络响应），此时程序就不会响应鼠标和键盘等操作，如果使用多线程，就可以将耗时的线程分配到一个单独的线程上执行，从而使程序具备更好的交互性。</li><li>与进程相比，线程的创建和切换开销更小。因开启一个新的进程需要分配独立的地址空间，建立许多数据结构来维护代码块等信息，而运行于同一个进程内的线程共享代码段、数据段、线程的启动和切换的开销比进程要少很多。同时<strong>多线程在数据共享方面效率非常高。</strong></li><li>目前市场上服务器配置大多数都是多CPU或多核计算机等，它们本身而言就具有执行多线程的能力，如果使用单个线程，就无法重复利用计算机资源，造成资源浪费。因此在多CPU计算机上<strong>使用多线程能提高CPU的利用率。</strong></li><li><strong>利用多线程能简化程序程序的结构，是程序便于理解和维护。</strong>一个非常复杂的进程可以分成多个线程来执行。</li></ul><h3 id="四、同步与异步有什么区别"><a href="#四、同步与异步有什么区别" class="headerlink" title="四、同步与异步有什么区别"></a>四、同步与异步有什么区别</h3><ul><li><p><strong>同步</strong>，<strong>可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</strong>。  </p></li><li><p><strong>异步</strong>，**执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 **</p><p>在多线程的环境中，通常会遇到数据共享问题，为了确保共享资源的正确性和安全性，就必须对共享数据进行同步处理（也就是锁机制）。对共享数据进行同步操作（增删改），就必须要获得每个线程对象的锁（this锁），这样可以保证同一时刻只有一个线程对其操作，其他线程要想对其操作需要排队等候并获取锁。当然在等候队列中优先级最高的线程才能获得该锁，从而进入共享代码区。</p><p>Java语言在同步机制中提供了语言级的支持，可以通过使用<strong>synchronize</strong>关键字来实现同步，但该方法是以很大的系统开销作为代价的，有时候甚至可能造成死锁，所以，同步控制并不是越多越好，要避免所谓的同步控制。实现同步的方法有两种：<strong>①同步方法（this锁）。②同步代码块（this锁或者自定义锁）</strong>当使用this锁时，就与同步方法共享同一锁，只有当①释放，②才可以使用。同时，同步代码块的范围也小于同步方法，建议使用，相比之下能够提高性能。 </p></li></ul><h3 id="五、如何实现java多线程"><a href="#五、如何实现java多线程" class="headerlink" title="五、如何实现java多线程"></a>五、如何实现java多线程</h3><p>在Java语言中实现多线程的方法有三种，其中前两种为常用方法：</p><ol><li><strong>继承Thread类，重写run()方法</strong></li></ol><p>  ​ Thread本质上也是实现了Runnable接口的一个实例，它表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()方法，start()方法是一个本地（native）方法，它将启动一个新的线程，并执行run()方法（执行的是自己重写了Thread类的run()方法），同时调用start()方法并不是执行多线程代码，而是使得该线程变为可运行状态（Runnable）,什么时候运行多线程代码由操作系统决定。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<span class="hljs-comment">//线程的函数体</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread thread = <span class="hljs-keyword">new</span> Thread<br>     thread.run();<span class="hljs-comment">//开启线程</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实现Runnable接口，并实现该结构的run()方法</strong></li></ol><ul><li>自定义实现Runnable接口，实现run()方法。</li><li>创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。</li><li>调用Thread的start()方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>   <span class="hljs-function">pulic <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread myThread = <span class="hljs-keyword">new</span> MyThread;<br>     Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);<br>     thread.start();<span class="hljs-comment">//启动线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不管是哪种方法，最终都是通过Thread类的API来控制线程。</em></p><ol start="3"><li><p><strong>实现Callable接口，重写call()方法</strong></p><p>Callable接口实际是属于Executor框架中的功能类，Callable结构与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要体现在如下三点：</p><ol><li>Callable在任务结束后可以提供一个返回值，Runnable无法提供该功能。</li><li>Callable中的call()方法可以跑出异常，而Runnable中的run()不能跑出异常。</li><li>运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供能了检查计算是否完成的方法。由于线程输入异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监控目标线程来调用call()方法的情况，当调用Future的get()方法以获取结果时，当前线程会阻塞，直到目标线程的call()方法结束返回结果。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableAndFuture</span></span>&#123;<br>   <span class="hljs-comment">//创建线程类</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>     Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> CallableTest());<br>     <span class="hljs-keyword">try</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;waiting thread to finish&quot;</span>);<br>          System.out.println(future.get());<br>        &#125;<span class="hljs-keyword">catch</span>&#123;Exception e&#125;&#123;<br>          e.printStackTrace<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    建议：当需要实现多线程时，一般推荐使用Runnable接口方式，因为Thread类定义了多种方法可以被派生类使用或重写，但是只有run()方法必须被重写，在run()方法中实现这个线程的主要功能，这当然也是实现Runnable接口所需的方法。再者，我们很多时候继承一个类是为了去加强和修改这个类才去继承的。因此，如果我们没有必要重写Thread类中的其他方法，那么通过继承Thread类和实现Runnable接口的效果是相同的，这样的话最好还是使用Runnable接口来创建线程。 </p></li></ol><h3 id="六、run方法与start方法的区别"><a href="#六、run方法与start方法的区别" class="headerlink" title="六、run方法与start方法的区别"></a>六、run方法与start方法的区别</h3><p>通常，系统通过调用线程类的start()方法启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以别JVM调用执行，执行的过程中，JVM通过调用想成类的run()方法来完成实际的操作，当run()方法结束后，线程也就会终止。<br>如果直接调用线程类的run()方法，就会被当做一个普通函数调用，程序中仍然只有一个主程序，也就是说start()方法能够异步调用run()方法，但是直接调用run()方法却是同步的，也就无法达到多线程的目的。</p><h3 id="七、多线程数据同步实现的方法有哪些"><a href="#七、多线程数据同步实现的方法有哪些" class="headerlink" title="七、多线程数据同步实现的方法有哪些"></a>七、多线程数据同步实现的方法有哪些</h3><p>当使用多线程访问同一数据时，非常容易出现线程安全问题，因此采用同步机制解决。Java提供了三种方法：</p><ol><li><p><strong>synchronized关键字</strong></p><p> 在Java语言中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的synchronize代码时，需要先获取这个锁，然后再去执行相应的代码，执行结束后，释放锁。</p><p>synchronize关键字主要有两种用法（synchronize方法和synchronize代码块）</p><ul><li><p>synchronized方法：在方法的声明前加synchronize关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> synchronize <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>将需要对同步资源的操作放入test()方法中，就能保证此资源在同一时刻只能被一个线程调用，从而保证资源的安全性。然而当此方法体规模非常大时，会影响系统的效率。</p></li><li><p>synchronized块：既可以把任意的代码段声明为synchronized，也可以指定上锁的对象，有非常高的灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(syncObject)&#123;<br>    <span class="hljs-comment">//访问syncObject的代码块</span><br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>wait()方法与notify()方法</strong></p><p>当使用synchronized来修饰某个共享资源时，如果线程A1在执行synchronized代码，线程A2也要执行同一对象的统同一synchronize的代码，线程A2将要等到线程A1执行完后执行，这种情况可以使用wai()和notify()。必须是统一把锁，才生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;  <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> res[];  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumberPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, <span class="hljs-keyword">byte</span> a[])</span></span>&#123;  <br>           <span class="hljs-keyword">this</span>.number = number;  <br>           res = a;  <br>       &#125;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;  <br>           <span class="hljs-keyword">synchronized</span> (res)&#123;  <br>               <span class="hljs-keyword">while</span>(count-- &gt; <span class="hljs-number">0</span>)&#123;  <br>                   <span class="hljs-keyword">try</span> &#123;  <br>                       res.notify();<span class="hljs-comment">//唤醒等待res资源的线程，把锁交给线程（该同步锁执行完毕自动释放锁）  </span><br>                       System.out.println(<span class="hljs-string">&quot; &quot;</span>+number);  <br>                       res.wait();<span class="hljs-comment">//释放CPU控制权，释放res的锁，本线程阻塞，等待被唤醒。  </span><br>                       System.out.println(<span class="hljs-string">&quot;------线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;获得锁，wait()后的代码继续运行：&quot;</span>+number);  <br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                       <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>                       e.printStackTrace();  <br>                   &#125;  <br>               &#125;<span class="hljs-comment">//end of while  </span><br>               <span class="hljs-keyword">return</span>;  <br>           &#125;<span class="hljs-comment">//synchronized  </span><br>             <br>       &#125;  <br>   &#125;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;  <br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> a[] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//以该对象为共享资源  </span><br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">1</span>),a),<span class="hljs-string">&quot;1&quot;</span>).start();  <br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">2</span>),a),<span class="hljs-string">&quot;2&quot;</span>).start();  <br>       &#125;  <br>   &#125;  <br><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong> </p><p><img src="https://img-blog.csdnimg.cn/20210426222413506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p><strong>lock</strong></p><ul><li>lock()：以阻塞的方式获取锁，也就是说，如果获取到了锁，就会执行，其他线程需要等待，unlock()锁后别的线程才能执行，如果别的线程持有锁，当前线程等待，直到获取锁后返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span>(ProdLine.size() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;队列是空的，请稍候&quot;</span>);<br>                empty.await();<br>            &#125;<br>            m = ProdLine.removeFirst();<br>            full.signal(); <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>tryLock()。以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立即返回true，否则，返回false。</li><li>tryLock(long timeout,TimeUnit unit)。在给定的时间单元内，获取到了锁返回true，否则false。</li><li>lockInterruptibly().如果获取了锁，立即返回；如果没有锁，当前线程处于休眠状态，直到获取锁，或者当前线程被中断（会收到InterruptedException异常）。它与lock()方法最大的区别在于如果()方法获取不到锁，就会一直处于阻塞状态，且会忽略Interrupt()方法。</li></ul></li></ol><h3 id="八、sleep方法与wait方法有什么区别"><a href="#八、sleep方法与wait方法有什么区别" class="headerlink" title="八、sleep方法与wait方法有什么区别"></a>八、sleep方法与wait方法有什么区别</h3><p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法，直到被唤醒或等待时间超时。</p><p><strong>区别：</strong></p><ul><li><p>原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到时间一到，此线程会自动“苏醒”。</p><p>wait()方法是Object类的方法，用于线程间通讯，这个方法会使当前线程拥有该对象锁的进程等待，直到其他线程调用notify()方法（或notifyAll方法）时才“醒”来，不过开发人员可可以给它指定一个时间，自动“醒”来。与wait()方法配套的方法还有notify()和notifyAll()方法。</p></li><li><p>对锁的处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通讯，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，调用后会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。</p></li><li><p>使用区域不同，由于wait()的特殊意义，因此它必须放在同步控制方法或者同步代码块中使用，而sleep()则可以放在任何地方使用。</p></li><li><p>sleep()方法 必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。</p><p> sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep()方法。而推荐使用wait()方法。</p></li></ul><h3 id="九、sleep与yield区别"><a href="#九、sleep与yield区别" class="headerlink" title="九、sleep与yield区别"></a>九、sleep与yield区别</h3><ul><li>sleep()给其他线程运行机会时，不考虑线程的优先级，因此会给低优先级的线程以运行的机会，而yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</li><li>sleep()方法会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程很可能在进入到可执行状态后马上又被执行。</li></ul><h3 id="十、终止线程的方法有哪些"><a href="#十、终止线程的方法有哪些" class="headerlink" title="十、终止线程的方法有哪些"></a>十、终止线程的方法有哪些</h3><ul><li><p>stop()方法，它会释放已经锁定的所有监视资源，如果当前任何一个受监视资源保护的对象处于一个不一致的状态（执行了一部分），其他线程线程将会获取到修改了的部分值，这个时候就可能导致程序执行结果的不确定性，并且这种问题很难被定位。</p></li><li><p>suspend()方法，容易发生死锁。因为调用suspend()方法不会释放锁，这就会导致此线程挂起。</p><p>以上两种方法的不安全性，Java语言已经不建议使用以上两种方法来终止线程了。</p></li><li><p>一般建议采用的方法是让线程自行结束进入Dead状态。一个线程进入Dead状态，既执行完run()方法，也就是说提供一种能够自动让run()方法结束的方式，在实际中，我们可以通过flag标志来控制循环是否执行，从而使线程离开run方法终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Boolean flag;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>     flag=<span class="hljs-keyword">false</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(flag);<span class="hljs-comment">//do something</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述通过stop()方法虽然可以终止线程，但同样也存在问题；当线程处于阻塞状态时（sleep()被调用或wait()方法被调用或当被I/O阻塞时）,上面介绍的方法就不可用了。此时使用interrupt()方法来打破阻塞的情况，当interrupt()方法被调用时，会跑出interruptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;thread go to sleep&quot;</span>);<br>       <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//用休眠来模拟线程被阻塞</span><br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread finish&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;thread is interrupted!);</span><br><span class="hljs-string">           &#125;</span><br><span class="hljs-string">     &#125; </span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">thread.start();</span><br><span class="hljs-string">therad.interrupt();</span><br></code></pre></td></tr></table></figure><p><strong>程序运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">thread go to sleep<br>thread is interrupted!<br></code></pre></td></tr></table></figure><p>如果I/0停滞，进入非运行状态，基本上要等到I/O完成才能离开这个状态。或者通过出发异常，使用readLine()方法在等待网络上的一个信息，此时线程处于阻塞状态，让程序离开run()就出发close()方法来关闭流，这个时候就会跑出IOException异常，通过捕获此异常就可以离开run()。</p></li></ul><h3 id="十一、-synchronized与Lock有什么异同"><a href="#十一、-synchronized与Lock有什么异同" class="headerlink" title="十一、 synchronized与Lock有什么异同"></a>十一、 synchronized与Lock有什么异同</h3><p>Java语言中提供了两种锁机制的实现对某个共享资源的同步；synchronized和Lock。其中synchronized使用Object类对象本身的notify()、wait()、notifyAll()调度机制，而Lock使用condition包进行线程之间的调度，完成synchronized实现的所有功能</p><ul><li><p><strong>用法不一样。</strong>synchronized既可以加在方法上，也可以加在特定的代码块中，括号中表示需要的锁对象。而Lock需要显式的指定起始位置和终止位置。synchronized是托管给JVM执行的，而Lock的锁定是通过代码实现，他有比synchronized更精确的线程语义。</p></li><li><p><strong>性能不一样。</strong>在JDK5中增加了一个Lock接口的实现类ReentrantLock。它不仅拥有和synchronized相同的并发性和内存语义、还多了锁投票、定时锁、等候锁和中断锁。它们的性能在不同的情况下会有所不同；在资源竞争不激烈的情况下，synchronized的性能要优于RenntrantLock，但是资源竞争激烈的情况下，synchronized性能会下降的非常快，而ReentrantLock的性能基本保持不变。</p></li><li><p><strong>锁机制不一样。</strong>synchronized获得锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且自动解锁，而condition中的await()、signal()、signalAll()能够指定要释放的锁。不会因为异常而导致锁没有被释放从而引发死锁的问题。而Lock则需要开发人员手动释放，并且必须放在finally块中释放，否则会引起死锁问题。此外，Lock还提供了更强大的功能，他的tryLock()方法可以采用非阻塞的方式去获取锁。</p><p>虽然synchronized与Lock都可以实现多线程的同步，但是最好不要同时使用这两种同步机制给统一共享资源加锁（不起作用），因为ReentrantLock与synchronized所使用的机制不同，所以它们运行时独立的，相当于两个种类的锁，在使用的时候互不影响。</p></li></ul><p><strong>面试题</strong></p><ol><li>当一个线程进入一个对象的synchronized()方法后，其他线程是否能够进入此对象的其他方法？</li></ol><ul><li>其他线程可进入此对象的非synchronized修饰的方法。如果其他方法有synchronized修饰，都用的是同一对象锁，就不能访问。</li></ul><ol start="2"><li>如果其他方法是静态方法，且被synchronized修饰，是否可以访问？</li></ol><ul><li>可以的，因为static修饰的方法，它用的锁是当前类的字节码，而非静态方法使用的是this，因此可以调用。</li></ul><h3 id="十二、什么是线程守护"><a href="#十二、什么是线程守护" class="headerlink" title="十二、什么是线程守护"></a>十二、什么是线程守护</h3><p> Java提供了两种线程：<strong>守护线程和用户线程</strong>。守护线程又被称为“服务进程”、“精灵线程”、“后台线程”，是指在程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分，通俗点讲，每一个守护线程都是JVM中非守护线程的“保姆”。典型例子就是“垃圾回收器”。只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源。</p><p>用户线程和守护线程几乎一样，唯一的不同就在于如果用户线程已经全部退出运行，只剩下守护线程运行，JVM也就退出了因为当所有非守护线程结束时，没有了守护者，守护线程就没有工作可做，也就没有继续运行程序的必要了，程序也就终止了，同时会“杀死”所有的守护线程。也就是说，只要有任何非守护线程运行，程序就不会终止。</p><p>Java语言中，守护线程优先级都较低，它并非只有JVM内部提供，用户也可以自己设置守护线程，方法就是在调用线程的start()方法之前，设置setDaemon(true)方法，若将参数设置为false,则表示用户进程模式。需要注意的是，守护线程中产生的其它线程都是守护线程，用户线程也是如此。</p><p><strong>线程类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>守护线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public final void setDaemon(boolean on)：是否设置为守护进程。true：是；false：否</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemonTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ThreadDaemon td1 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>ThreadDaemon td2 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>td1.setName(<span class="hljs-string">&quot;A&quot;</span>);<br>td2.setName(<span class="hljs-string">&quot;B&quot;</span>);<br> <br><span class="hljs-comment">//添加守护线程</span><br>td1.setDaemon(<span class="hljs-keyword">true</span>);<br>td2.setDaemon(<span class="hljs-keyword">true</span>);<br><br>td1.start();<br>td2.start();<br><br>Thread.currentThread().setName(<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>A线程和B线程均设置为守护线程，C线程为用户进程。这三个线程均随机抢占CPU的使用权，当C抢占并且运行完毕之后，A和B这两个线程将在某一时间死亡，切记并不是立刻死亡，而是A线程执行完毕的一段时间后。</p><h3 id="十三、join方法作用"><a href="#十三、join方法作用" class="headerlink" title="十三、join方法作用"></a>十三、join方法作用</h3><p>在Java语言中，join()方法的作用是让调用该方法的线程在执行完run()方法后，再执行join方法后面的代码。简单点说就是将两个线程合并，并实现同步功能。具体而言，可以通过线程A的join()方法来等待线程A的结束，或者使用线程A的join(2000)方法来等待线程A的结束，但最多只等2s。示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Begin ThreadImp&quot;</span>);<br>       Thread.sleep(<span class="hljs-number">5000</span>);<br>       System.out.println(<span class="hljs-string">&quot;End ThreadImp&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadImp());<br>    t.start();<br>    <span class="hljs-keyword">try</span>&#123;<br>         t.join(<span class="hljs-number">1000</span>);<span class="hljs-comment">//主线程等待1s</span><br>         <span class="hljs-keyword">if</span>（t.isAlive())&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has not finished&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has finished&quot;</span>);<br>         &#125;<br>       System.out.println(<span class="hljs-string">&quot;joinFinish&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedExcetion e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426224744450.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记2 线程池学习</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程池"><a href="#一、线程池" class="headerlink" title="一、线程池"></a>一、线程池</h3><p>在java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。</p><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p><p>假设一个服务器完成一项任务所需时间为：T1创建线程池时间，T2在线程中执行任务的时间，T3销毁线程时间。</p><p>如果：T1+T3&gt;&gt;T2,则可以采用线程池，提高服务器性能。</p><h3 id="二、线程池的优势"><a href="#二、线程池的优势" class="headerlink" title="二、线程池的优势"></a>二、线程池的优势</h3><ul><li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限创建，不仅会损耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</li></ul><h3 id="三、线程池的使用"><a href="#三、线程池的使用" class="headerlink" title="三、线程池的使用"></a>三、线程池的使用</h3><p>线程池的真正实现类是<strong>ThreadPoolExecutor</strong>， 其构造方法有4种。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         threadFactory, defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), handler);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可看到，需要这几个参数：</p><ul><li><strong>corePoolSize</strong> (必需)：核心线程数。默认情况下，核心线程数会一直存货，但是当将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>maxmumPoolsize</strong> (必需)：线程池所能容纳的最大线程数。当活跃线程数到该数值后，后续的新任务将会阻塞。</li><li><strong>keepAliveTime</strong>(必需)：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。 如果将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>unit</strong> （必需）：指定keepAliveTime参数的时间单位。常用的有：<strong>TimeUnit.MILLISECONDS</strong> （毫秒）、<strong>TimeUnit.SECONDS</strong> （秒）、<strong>TimeUnit.MINUTES</strong> （分）</li><li><strong>Queue</strong> （必需）：任务队列。通过线程池的execute()方法提交的Runnable对象将存储在该参数中。其采用阻塞队列实现。</li><li><strong>threadFactory</strong> （可选）：线程工厂。用于指定为线程池创建新线程的方式。</li><li><strong>handler</strong> （可选）：拒绝策略。当达到最大线程数时需要执行的包和策略。</li></ul><p>线程池的使用流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br>ThreadPoolExecutor threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,<br>                                             MAXIMUM_POOL_SIZE,<br>                                             KEEP_ALIVE,<br>                                             TimeUnit.SECONDS,<br>                                             sPoolWorkQueue,<br>                                             sThreadFactory);<br><span class="hljs-comment">// 向线程池提交任务</span><br>threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        ... <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 关闭线程池</span><br>threadPool.shutdown(); <span class="hljs-comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span><br>threadPool.shutdownNow(); <span class="hljs-comment">// 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span><br></code></pre></td></tr></table></figure><h3 id="三、线程池的工作原理"><a href="#三、线程池的工作原理" class="headerlink" title="三、线程池的工作原理"></a>三、线程池的工作原理</h3><p>工作流程图：</p><p><img src="https://img-blog.csdnimg.cn/20210426193522921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="四、线程池的参数"><a href="#四、线程池的参数" class="headerlink" title="四、线程池的参数"></a>四、线程池的参数</h3><h4 id="1-任务队列（workqueue）"><a href="#1-任务队列（workqueue）" class="headerlink" title="1.任务队列（workqueue）"></a>1.任务队列（workqueue）</h4><p><img src="https://img-blog.csdnimg.cn/20210426202610254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在java中需要实现<strong>BlockingQueue</strong> 接口。但java已经提供了7种阻塞队列的实现：</p><ol><li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）</li><li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为<strong>Integer.MAX_VALUE</strong>。</li><li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排列的无界阻塞队列，对元素没有要求，可以实现<strong>Comparable</strong> 接口也可以提供Comparator来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</li><li><strong>DelayQueue</strong> ：类似于<strong>PriorityBlockingQueue</strong> ，是二叉堆实现的无界优先级阻塞队列。要求元素都实现<strong>Delayed</strong> 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</li><li><strong>SynchronousQueue</strong>： 一个不存储元素的阻塞队列，消费者线程调用take()方法的时候就会发送阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用put()方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</li><li><strong>LinkedBlockingDeque</strong>： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样FIFO（先进先出），也可以像栈一个FILO（先进后出）</li><li><strong>LinkedTransferQueue：</strong> 他是<strong>ConcurrentLinkedQueue</strong>、**LinkedBlockingQueue **和 **SynchronousQueue **的结合体，但是把它用在 ThreadPoolExecutor 中，和 **LinkedBlockingQueue **行为一致，但是是无界的阻塞队列。</li></ol><p><strong>注意有界队列和无界队列的区别：</strong> <em>如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</em> </p><h4 id="2-线程工厂（theadFactory）"><a href="#2-线程工厂（theadFactory）" class="headerlink" title="2.线程工厂（theadFactory）"></a>2.线程工厂（theadFactory）</h4><p>线程工厂指定创建线程的方式，需要实现 **ThreadFactory **接口，并实现 **newThread(Runnable r) **方法。该参数可以不用指定，Executors 框架已经为我们实现了一个默认的线程工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br> <br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                              Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                      poolNumber.getAndIncrement() +<br>                     <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                              namePrefix + threadNumber.getAndIncrement(),<br>                              <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-拒绝策略（handler）"><a href="#3-拒绝策略（handler）" class="headerlink" title="3.拒绝策略（handler）"></a>3.拒绝策略（handler）</h4><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现<strong>RejectedExecutionHanlder</strong>接口，并实现 **rejectedExecution(Runnabler, ThreadPoolExecutor executor) **方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p><ol><li><strong>AbortPolicy（默认）</strong>：丢弃任务并抛出 **RejectedExecutionException **异常。</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li><li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li></ol><h3 id="五、功能线程池"><a href="#五、功能线程池" class="headerlink" title="五、功能线程池"></a>五、功能线程池</h3><p>Executors已经为我们封装好了 4 种常见的功能线程池，如下：</p><ul><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool ）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ul><h4 id="1-定长线程池（FixedThreadPool）"><a href="#1-定长线程池（FixedThreadPool）" class="headerlink" title="1.定长线程池（FixedThreadPool）"></a>1.定长线程池（FixedThreadPool）</h4><p>创建方法源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 只有核心教程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 控制线程最大并发数。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3</span><br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>fixedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="2-定时线程池（ScheduledThreadPool）"><a href="#2-定时线程池（ScheduledThreadPool）" class="headerlink" title="2.定时线程池（ScheduledThreadPool）"></a>2.定时线程池（ScheduledThreadPool）</h4><p>创建方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="hljs-number">10L</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。</li><li><strong>应用场景</strong>： 执行定时或周期性的任务。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5</span><br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>scheduledThreadPool.schedule(task, <span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 延迟1s后执行任务</span><br>scheduledThreadPool.scheduleAtFixedRate(task,<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS);<span class="hljs-comment">// 延迟10ms后、每隔1000ms执行任务</span><br></code></pre></td></tr></table></figure><h4 id="3-可缓存线程池（CachedThreadPool）"><a href="#3-可缓存线程池（CachedThreadPool）" class="headerlink" title="3.可缓存线程池（CachedThreadPool）"></a>3.可缓存线程池（CachedThreadPool）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。</li><li><strong>应用场景</strong> ： 执行大量，耗时少的任务</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建可缓存线程池对象</span><br>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>cachedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-单线程化线程池（SingleThreadExecutor）"><a href="#5-单线程化线程池（SingleThreadExecutor）" class="headerlink" title="5.单线程化线程池（SingleThreadExecutor）"></a>5.单线程化线程池（SingleThreadExecutor）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong> ： 只有一个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 不合适并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建单线程化线程池</span><br>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>singleThreadExecutor.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-对比"><a href="#5-对比" class="headerlink" title="5.对比"></a>5.对比</h4><p><img src="https://img-blog.csdnimg.cn/20210426201526725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p> Executors 的 4 个功能线程有如下弊端：</p><ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：主要问题是堆积的请求处理队列均采用 <strong>LinkedBlockingQueue</strong>，可能会耗费非常大的内存，甚至 OOM。</li><li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><hr><p>学习文章：<a href="https://blog.csdn.net/u013541140/article/details/95225769">https://blog.csdn.net/u013541140/article/details/95225769</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记1 多线程学习</title>
    <link href="/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程和进程的区别"><a href="#一、线程和进程的区别" class="headerlink" title="一、线程和进程的区别"></a>一、线程和进程的区别</h3><p><strong>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。（进程是资源分配的最小单位）</strong></p><p><strong>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换开销小。（线程是cpu调度的最小单位）</strong></p><p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止</p><p>多线程指在同一个程序中有多个顺序流在执行，在操作系统能同时运行多个任务（程序）</p><ul><li>在java中要实现多线程有三种方式，Thread类，实现Runable接口，Callable接口</li></ul><h3 id="二、扩展java-lang-Thread类"><a href="#二、扩展java-lang-Thread类" class="headerlink" title="二、扩展java.lang.Thread类"></a>二、扩展java.lang.Thread类</h3><p>​    继承thread类的方法是常用的一种，如果说要起一条线程可以使用thread</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行  :  &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads mTh2=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;B&quot;</span>);<br>        mTh1.start();<br>        mTh2.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042517010912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>程序在启动运行main时，java虚拟机启动一个进程，主线程main在main()调用时被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</li><li>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</li><li>多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</li><li>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</li></ul><p><em>所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。但是start方法重复调用的话会出现<strong>java.lang.IllegalThreadStateException</strong>异常。</em></p><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>Threads mTh2=mTh1;<br>mTh1.start();<br>mTh2.start();<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425171539746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a>二、实现java.lang.Runnable接口</h3><p>只需将run方法重写就行</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads1</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;运行 : &quot;</span>+i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;C&quot;</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;D&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425172441669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>Threads1类通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个约定。所有多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</li><li>在启动多线程时，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码</li><li>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</li></ul><h3 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a>三、Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。</p><p><strong>实现Runnable接口比继承Thread类具有的优势：</strong></p><ul><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免java中的单继承限制</li><li>增加程序的健壮性、代码可以被多个线程共享，代码和数据独立</li><li>线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</li></ul><p>==注意：main方法也是一个线程，在java中所以的线程都是同时启动的，至于什么0候，哪个先执行，完全看谁先得到CPU的资源。==</p><p>==在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。==</p><h3 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h3><p><img src="https://img-blog.csdnimg.cn/20210425174938348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>新建状态：新创建一个线程对象</li><li>就绪状态：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</li><li>运行状态：就绪状态的线程获取了CPU，执行程序代码</li><li>阻塞状态：因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。<ul><li>阻塞状态三种情况<ul><li>等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待池中（wait会释放持有的锁）</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中</li><li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时，join等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li><li>死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul></li></ul><h3 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h3><h4 id="1-线程优先级"><a href="#1-线程优先级" class="headerlink" title="1.线程优先级"></a>1.线程优先级</h4><ul><li><p>java线程优先级高的会获得更多的运行机会</p></li><li><p>Java线程的优先级用整数表示，取值在1~10，Thread类有以下三个静态常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_PRIORITY <span class="hljs-comment">//线程可以具有的最高优先级，取值为10。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MIN_PRIORITY <span class="hljs-comment">//线程可以具有的最低优先级，取值为1。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NORM_PRIORITY <span class="hljs-comment">//分配给线程的默认优先级，取值为5。</span><br></code></pre></td></tr></table></figure><p><strong>用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread4 t1 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t1&quot;</span>);<br>Thread4 t2 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t2&quot;</span>);<br>t1.setPriority(Thread.MAX_PRIORITY);<br>t2.setPriority(Thread.MIN_PRIORITY);<br></code></pre></td></tr></table></figure></li><li><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有优先级，主线程优先级默认为Thread.NORM_PRIORITY。</p></li><li><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p></li></ul><h4 id="2-线程睡眠"><a href="#2-线程睡眠" class="headerlink" title="2.线程睡眠"></a>2.线程睡眠</h4><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><h4 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3.线程等待"></a>3.线程等待</h4><p> Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><h4 id="4-线程让步"><a href="#4-线程让步" class="headerlink" title="4.线程让步"></a>4.线程让步</h4><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><h4 id="5-线程加入"><a href="#5-线程加入" class="headerlink" title="5.线程加入"></a>5.线程加入</h4><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><h4 id="6-线程唤醒"><a href="#6-线程唤醒" class="headerlink" title="6.线程唤醒"></a>6.线程唤醒</h4><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><h3 id="六、常用函数"><a href="#六、常用函数" class="headerlink" title="六、常用函数"></a>六、常用函数</h3><ul><li><p><strong>sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</strong> sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p><p>leep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</p><p>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。</p></li><li><p><strong>join():指等待t线程终止。</strong></p><ul><li>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> AThread(); t.start(); t.join();<br></code></pre></td></tr></table></figure></li></ul><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p><strong>不加join情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426091527321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程比子线程结束早</p><p><strong>加上join方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            thread1.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            thread2.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Threads2.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426092435399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程会等待子线程结束之后在结束。</p><ul><li><p><strong>yield():暂停当前正在执行的线程对象，并执行其他线程</strong></p><p>Thread.yield()方法作用：暂停当前正在执行的线程对象，并执行其他线程。</p><p><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong> 所以，使用yield方法的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p><strong>yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果</strong> </p></li></ul><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadYield</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadYield</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">50</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">&quot;------&quot;</span>+i);<br>            <span class="hljs-comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">30</span>)&#123;<br>                <span class="hljs-keyword">this</span>.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadYield yield1 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;A&quot;</span>);<br>        ThreadYield yield2 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;B&quot;</span>);<br>        yield1.start();<br>        yield2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><ol><li><p>当A线程运行到30时，CPU让掉，这时A线程再次抢到CPU时间并执行</p><p><img src="https://img-blog.csdnimg.cn/20210426094258763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>当A线程运行到30时，CPU让掉，这时B线程抢到CPU时间并执行。</p></li></ol><h4 id="sleep-和yield-区别"><a href="#sleep-和yield-区别" class="headerlink" title="sleep()和yield()区别"></a>sleep()和yield()区别</h4><ol><li>sleep()使当前线程进入停滞状态, 所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</li><li>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</li><li>sleep 方法允许较低优先级的线程获得运行机会,但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</li></ol><ul><li><p>interrupt():不是中断某个线程， 只是线程发送一个中断信号，让线程 在无限等待时（如死锁）能够抛出，从而结束线程。</p></li><li><p>wait(): Obj.wait()与Obj.notify()必须要与synchronized一起使用，也就是针对已获取了Obj锁进行操作，从语法角度说必须放在synchronized(Obj){…}语句块内。</p><p>从功能上wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其他线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。</p><p>notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，不是马上就释放对象锁，而是在相应的synchronized(){}语句块执行结束后，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。</p><p>Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p><strong>案例：</strong></p><p><strong>建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。</strong> </p><p><strong>案例实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadText</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Object prev;<br>    <span class="hljs-keyword">private</span> Object self;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadText</span><span class="hljs-params">(String name,Object prev,Object self)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.self = self;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (prev)&#123;<br>                <span class="hljs-keyword">synchronized</span> (self)&#123;<br>                    System.out.println(name);<br>                    count -- ;<br>                    self.notify();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    prev.wait();<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Object a = <span class="hljs-keyword">new</span> Object();<br>        Object b = <span class="hljs-keyword">new</span> Object();<br>        Object c = <span class="hljs-keyword">new</span> Object();<br>        ThreadText pa = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;A&quot;</span>,c,a);<br>        ThreadText pb = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;B&quot;</span>,a,b);<br>        ThreadText pc = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;C&quot;</span>,b,c);<br><br>        <span class="hljs-keyword">new</span> Thread(pa).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pb).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pc).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021042610344056.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>案例分析</strong></p><p>该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。</p><p>为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。</p><p>可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p></li><li><p>wait()方法：wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</p><p>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</p></li></ul><h4 id="wait和sleep区别"><a href="#wait和sleep区别" class="headerlink" title="wait和sleep区别"></a>wait和sleep区别</h4><p><strong>相同点</strong></p><ol><li><p> 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。</p></li><li><p>wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。</p><p>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p><p>InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。</p></li></ol><p><strong>不同点</strong></p><ol><li><p>Thread类的方法：sleep(),yield()等。</p><p>Object类的方法：wait()和notify等。</p></li><li><p>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。</p><p>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p></li><li><p>wait，notify和notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用，<strong>所以sleep和wait最大的区别是：</strong></p><p><strong>sleep()睡眠时，保持对象锁，仍然占有该锁；</strong></p><p><strong>wait()睡眠时，释放对象锁</strong></p><p><strong>但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。</strong></p></li></ol><h3 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a>七、常见线程名词解释</h3><p>主线程：JVM调用程序main()所产生的线程</p><p>当前线程：一般指通过Thread.currentThread()来获取进程</p><p>后台进程：指为其他线程提供服务的线程，也成为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>前台线程：指接受后台线程服务的线程，其实前台后台线程是联系在一起，像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p><strong>线程类的一些常用方法：</strong> </p><p>　　<strong>sleep(): 强迫一个线程睡眠Ｎ毫秒。</strong> <br>　　<strong>isAlive(): 判断一个线程是否存活。</strong> <br>　　<strong>join(): 等待线程终止。</strong> <br>　　<strong>activeCount(): 程序中活跃的线程数。</strong> <br>　　<strong>enumerate(): 枚举程序中的线程。</strong> <br>    <strong>currentThread(): 得到当前线程。</strong> <br>　　<strong>isDaemon(): 一个线程是否为守护线程。</strong> <br>　　<strong>setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</strong> <br>　　<strong>setName(): 为线程设置一个名称。</strong> <br>　　<strong>wait(): 强迫一个线程等待。</strong> <br>　　<strong>notify(): 通知一个线程继续运行。</strong> <br>　　<strong>setPriority(): 设置一个线程的优先级。</strong></p><h3 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a>八、线程同步</h3><ul><li><strong>synchronized关键字的作用域有两种</strong> </li></ul><ol><li>是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</li><li>是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ol><ul><li><strong>除了除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</strong> 用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；</li><li><strong>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。</strong>继承类需要你显式的指定它的某个方法为synchronized方法；</li></ul><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>在进一步阐述之前，我们需要明确几点：</p><p>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>B．每个对象只有一个锁（lock）与之相关联。</p><p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><ol><li><p>把synchronized当作函数修饰符时，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>上边的示例代码等同于如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)  <span class="hljs-comment">//(1)&#123;</span><br>    <span class="hljs-comment">//..</span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p> (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱</p></li><li><p>同步块，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(SomeObject so)</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(so)&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] lock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>      <span class="hljs-comment">//..</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。==</p></li><li><p>将synchronized作用于static 函数，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodBB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Foo.class) <span class="hljs-comment">//class literal(类名称字面常量)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p></li></ol><p><strong>总结</strong></p><ol><li>线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</li><li>线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法</li><li>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</li><li>对于同步，要时刻清醒在哪个对象上同步，这是关键。</li><li>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</li><li>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</li><li>死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真但是，一旦程序发生死锁，程序将死掉。</li></ol><h3 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a>九、线程数据传递</h3><h4 id="1-通过构造方法传递数据"><a href="#1-通过构造方法传递数据" class="headerlink" title="1.通过构造方法传递数据"></a>1.通过构造方法传递数据</h4><p>在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用。下面的代码演示了如何通过构造方法来传递数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreads</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> MyThreads(<span class="hljs-string">&quot;word&quot;</span>);<br>    thread.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><h4 id="2-通过变量和方法传递数据"><a href="#2-通过变量和方法传递数据" class="headerlink" title="2.通过变量和方法传递数据"></a>2.通过变量和方法传递数据</h4><p>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads3 threads3 = <span class="hljs-keyword">new</span> Threads3();<br>        threads3.setName(<span class="hljs-string">&quot;world&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(threads3);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-通过回调函数传递数据"><a href="#3-通过回调函数传递数据" class="headerlink" title="3.通过回调函数传递数据"></a>3.通过回调函数传递数据</h4><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Data data,Integer ... num)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : num)&#123;<br>            data.value += n;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Work work;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads4</span><span class="hljs-params">(Work work)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.work = work;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        Data data = <span class="hljs-keyword">new</span> Data();<br>        <span class="hljs-keyword">int</span> n1 = random.nextInt(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">int</span> n2 = random.nextInt(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">int</span> n3 = random.nextInt(<span class="hljs-number">3000</span>);<br>        work.process(data,n1,n2,n3);<br>        System.out.println(String.valueOf(n1) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n2) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n3) + <span class="hljs-string">&quot;=&quot;</span> + data.value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Threads4(<span class="hljs-keyword">new</span> Work());<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>学习文章链接:<a href="http://blog.csdn.net/evankaka">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记10 事务与事务锁</title>
    <link href="/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/"/>
    <url>/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一、事务简介"><a href="#一、事务简介" class="headerlink" title="一、事务简介"></a>一、事务简介</h3><p>Redis执行命令过程中，多条连续执行的指令被干扰，打断，插队</p><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>redis事务就是一个命令执行的队列，将一系列预定命令包装成一个整体（一个队列）。当执行时，按照添加顺序依次执行，中间不会被打断或者干扰。</p><p>一个队列中，一次性，顺序性，排他性的执行一系列命令</p><h3 id="二、事务的基本操作"><a href="#二、事务的基本操作" class="headerlink" title="二、事务的基本操作"></a>二、事务的基本操作</h3><ul><li><p>开启事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multi<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li><p>执行事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</li></ul></li></ul><p><em>注意：</em> <strong>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行。</strong></p><ul><li><p>取消事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">discard<br></code></pre></td></tr></table></figure><ul><li>作用：终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul><h3 id="三、事物的工作流程"><a href="#三、事物的工作流程" class="headerlink" title="三、事物的工作流程"></a>三、事物的工作流程</h3><ul><li><p>未开启事务前的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423145755640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>创建事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150112123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150227995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的del指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150354629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>关闭事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150515144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>取消事务</p><p><img src="https://img-blog.csdnimg.cn/2021042315064864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="四、事物的注意事项"><a href="#四、事物的注意事项" class="headerlink" title="四、事物的注意事项"></a>四、事物的注意事项</h3><h4 id="定义事务的过程中，命令格式输入错误怎么办？"><a href="#定义事务的过程中，命令格式输入错误怎么办？" class="headerlink" title="定义事务的过程中，命令格式输入错误怎么办？"></a>定义事务的过程中，命令格式输入错误怎么办？</h4><ul><li><p>语法错误</p><p>指命令书写格式有误</p></li><li><p>处理结果</p><p>如果定义的事务中所包含的命令存在语法错误，整体事务中所以命令均不会执行。包括那些语法正确的命令。</p></li></ul><h4 id="定义事务的过程中，命令执行出现错误怎么办？"><a href="#定义事务的过程中，命令执行出现错误怎么办？" class="headerlink" title="定义事务的过程中，命令执行出现错误怎么办？"></a>定义事务的过程中，命令执行出现错误怎么办？</h4><ul><li><p>运行错误</p><p>指命令格式正确，但是无法正确的执行，列如对list进行incr操作</p></li><li><p>处理结果</p><p>能够正确运行的命令会执行，运行错误的命令不会执行</p></li></ul><p><em>注意：</em> <strong>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</strong></p><h4 id="手动进行事务回滚"><a href="#手动进行事务回滚" class="headerlink" title="手动进行事务回滚"></a>手动进行事务回滚</h4><ul><li>记录操作过程中被影响的数据之前的状态<ul><li>单数据：string</li><li>多数据：hash、list、set、zset</li></ul></li><li>设置指令恢复所有的被修改的项<ul><li>单数据：直接set（注意周边属性，列如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ul></li></ul><h3 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h3><h4 id="基于特定条件的事务执行——锁"><a href="#基于特定条件的事务执行——锁" class="headerlink" title="基于特定条件的事务执行——锁"></a>基于特定条件的事务执行——锁</h4><p><strong>业务场景1</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423160652713.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操纵修改后，将不适用于继续操作</li><li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li></ul><p><strong>解决方案</strong></p><ul><li><p>对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch key1 [key2...]<br></code></pre></td></tr></table></figure></li><li><p>取消对所有key的监视</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unwatch<br></code></pre></td></tr></table></figure></li><li><p>redis应用基于状态控制的批量任务执行</p></li></ul><h4 id="基于特定条件的事务执行——分布式锁"><a href="#基于特定条件的事务执行——分布式锁" class="headerlink" title="基于特定条件的事务执行——分布式锁"></a>基于特定条件的事务执行——分布式锁</h4><p><strong>业务场景2</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423161241863.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li><li>虽然redis是单线程的，但是多个客户端对同一个数据同时操作时，如何避免不被同时修改？</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用setnx设置一个公共锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p><ul><li>对于返回设置成功时，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul></li><li><p>操作完毕通过del操作释放锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del lock-key<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em> ： 上述解决方案是一种设计概念，依赖规范保障，具有风险性</p><ul><li>redis应有基于分布式对应的场景控制</li></ul><h4 id="基于特定条件的事务执行——分布式锁改良"><a href="#基于特定条件的事务执行——分布式锁改良" class="headerlink" title="基于特定条件的事务执行——分布式锁改良"></a>基于特定条件的事务执行——分布式锁改良</h4><p><strong>业务场景</strong></p><p>依赖分布式锁的机制，某个用户操作时对应客户机宕机，并且此时已经获取到锁，如何解决？</p><p><strong>业务分析</strong></p><ul><li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</li><li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用expire为锁key添加时间限定，到时不释放，放弃锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire lock-key second<br>pexpire lock-key millseconds<br></code></pre></td></tr></table></figure><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms</li><li>测试百万次最长执行时间对应命令的最大消耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时* 120%+平均网络延迟*110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记9 Redis持久化之AOF</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、AOF概念"><a href="#一、AOF概念" class="headerlink" title="一、AOF概念"></a>一、AOF概念</h3><ul><li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令，达到恢复数据的目的。与RDB相比可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></li><li>AOF的主要作用时解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li></ul><h3 id="二、AOF写数据过程"><a href="#二、AOF写数据过程" class="headerlink" title="二、AOF写数据过程"></a>二、AOF写数据过程</h3><p><img src="https://img-blog.csdnimg.cn/20210422194954247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="三、AOF写数据三种策略（appendfsync）"><a href="#三、AOF写数据三种策略（appendfsync）" class="headerlink" title="三、AOF写数据三种策略（appendfsync）"></a>三、AOF写数据三种策略（appendfsync）</h3><ul><li><p>always（每次）</p><p>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong></p></li><li><p>everysec（每秒）</p><p>每次将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，在系统突然宕机的情况下丢失1秒内的数据（建议使用，也是默认配置）</p></li><li><p>no（系统控制）</p><p>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></p><p>​</p></li></ul><h3 id="四、AOF功能开启"><a href="#四、AOF功能开启" class="headerlink" title="四、AOF功能开启"></a>四、AOF功能开启</h3><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly yes|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>是否开启AOF持久化功能，默认为不开启状态</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfsync always|everysec|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF写数据策略</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfilename filename<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dir<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li></ul><h3 id="五、AOF写数据遇到的问题"><a href="#五、AOF写数据遇到的问题" class="headerlink" title="五、AOF写数据遇到的问题"></a>五、AOF写数据遇到的问题</h3><p><strong>如果连续执行如下指令该如何处理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042220280729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p>AOF重写</p><h3 id="六、AOF重写"><a href="#六、AOF重写" class="headerlink" title="六、AOF重写"></a>六、AOF重写</h3><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是<strong>将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。</strong></p><h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令，如del key1、hdel key2、srem key3、set key4 123、set key4 222等</p></li><li><p>对同一数据的多条写命令合并为一条命令，如lpush list1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c。</p><p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型、每条指令最多写入64个元素</p></li></ul><h4 id="AOF重写方式（手动重写）"><a href="#AOF重写方式（手动重写）" class="headerlink" title="AOF重写方式（手动重写）"></a>AOF重写方式（手动重写）</h4><ul><li><p>手动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgrewriteaof<br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li></ul><h4 id="AOF手动重写——bgrewriteaof指令工作原理"><a href="#AOF手动重写——bgrewriteaof指令工作原理" class="headerlink" title="AOF手动重写——bgrewriteaof指令工作原理"></a>AOF手动重写——bgrewriteaof指令工作原理</h4><p><img src="https://img-blog.csdnimg.cn/20210422204256378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写方式（自动重写）"><a href="#AOF重写方式（自动重写）" class="headerlink" title="AOF重写方式（自动重写）"></a>AOF重写方式（自动重写）</h4><ul><li><p>自动重写触发条件格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percent<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发对比参数（运行指令info Persistence获取具体信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">aof_current_size<br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="https://img-blog.csdnimg.cn/20210422205637212.png" alt="img"></p><h4 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210052662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210223933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210422210336449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>AOF缓冲区同步文件策略，由参数appendfsync控制</li></ul><p><strong>系统调用write和fsync说明：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422210709540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="七、RDB与AOF区别"><a href="#七、RDB与AOF区别" class="headerlink" title="七、RDB与AOF区别"></a>七、RDB与AOF区别</h3><p><img src="https://img-blog.csdnimg.cn/20210422210809864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB与AOF选择之惑</strong></p><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用erverysecond，每秒钟fsync一次。该策略redis任然可以保持很好的处理性能，当出现问题时，最多丢失0-1秒中的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复数据较慢</li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人工手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降得很低</li></ul></li><li>综合对比<ol><li>RDB与AOF得选择实际上是在做一种权衡，每种都有利弊</li><li>如不能承受数分钟以内得数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内数据丢失，且追求大数据集得恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量</li></ol></li></ul><p><strong>持久化应用场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422211202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记8 Redis持久化之RDB</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、持久化简介"><a href="#一、持久化简介" class="headerlink" title="一、持久化简介"></a>一、持久化简介</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1.什么是持久化"></a>1.什么是持久化</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><h3 id="2-为什么要进行持久化"><a href="#2-为什么要进行持久化" class="headerlink" title="2.为什么要进行持久化"></a>2.为什么要进行持久化</h3><p>防止数据的意外丢失，确保数据安全性</p><h3 id="3-持久化过程保存什么"><a href="#3-持久化过程保存什么" class="headerlink" title="3.持久化过程保存什么"></a>3.持久化过程保存什么</h3><ul><li><p>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。</p></li><li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。</p><p><img src="https://img-blog.csdnimg.cn/2021042215521812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><h2 id="二、RDB"><a href="#二、RDB" class="headerlink" title="二、RDB"></a>二、RDB</h2><h3 id="1-RDB启动方式（手动执行）"><a href="#1-RDB启动方式（手动执行）" class="headerlink" title="1.RDB启动方式（手动执行）"></a>1.RDB启动方式（手动执行）</h3><p><strong>命令执行</strong></p><ul><li>谁：redis操作者（用户）</li><li>什么时间：即使（随时进行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save指令</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><p><strong>RDB启动方式——save指令相关配置</strong></p><ul><li><p>dbfilename dump.rdb</p><p>说明 : 设置本地数据库文件名，默认值为dump.rdb</p><p>经验 : 通常设置为<strong>dump-端口号.rdb</strong></p></li><li><p>dir</p><p>说明 : 设置存储.rdb文件路径</p><p>经验 : 通常设置成存储空间较大的目录 , 目录名称为data</p></li><li><p>rdbcompression yes</p><p>说明 : 设置存储至本地数据库时是否压缩数据 , 默认为yes , 采用LZF压缩</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节省CPU运行时间 , 但会使存储的文件变大(巨大)</p></li><li><p>rdbchecksum yes</p><p>说明 : 设置是否进行RDB文件格式校验 , 该校验过程在写文件个读文件过程均进行</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节约读写性过程约10%时间消耗 , 但是存储一定的数据损坏风险</p></li></ul><p><strong>RDB启动方式——save指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422160844486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> <strong>Redis是单线程的</strong>，所有命令都会在类似队列中排好队，不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成位置，有可能会造成长时间阻塞，<strong>线上环境不建议使用</strong></p><h3 id="2-RDB启动方式（后台执行）"><a href="#2-RDB启动方式（后台执行）" class="headerlink" title="2.RDB启动方式（后台执行）"></a>2.RDB启动方式（后台执行）</h3><p><strong>后台执行</strong></p><ul><li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li><li>什么时间：即使（发起）；合理时间（执行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——bgsave</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgsave<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但不是立即执行</p></li></ul><p><strong>RDB启动方式——bgsave指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422161702164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em>bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><p><strong>RDB启动方式——bgsave指令相关配置</strong></p><ul><li><p>stop-writes-on-bgsave-error yes</p><p>说明：后台存储过程中如果出现错误现象，是否停止保存操作</p><p>经验：默认为开启</p></li></ul><h3 id="3-RDB启动方式（自动执行）"><a href="#3-RDB启动方式（自动执行）" class="headerlink" title="3.RDB启动方式（自动执行）"></a>3.RDB启动方式（自动执行）</h3><p><strong>自动执行</strong></p><ul><li>谁：redis服务器发起指令（基于条件）</li><li>什么时间：满足条件</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save配置</strong></p><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save second changes<br></code></pre></td></tr></table></figure></li><li><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数</p><p>second：监控时间范围</p><p>changes：监控key的变化量</p></li><li><p>位置</p><p>conf文件中配置</p></li><li><p>范例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure></li></ul><p><strong>RDB启动方式——save配置原理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042216312487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> </p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li>save配置启动后执行的是bgsave操作</li></ul><p><strong>RDB三种启动方式对比</strong></p><ul><li>save配置启动后由于执行的还是bgsave操作所以不在进行对比。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210422163458239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB特殊启动方式</strong></p><ul><li><p>全量复制</p><p>在主从复制中详细介绍</p></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debug reload<br></code></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown<br></code></pre></td></tr></table></figure><ul><li>默认情况下执行shutdown命令时，自动执行bgsave（如果没有开启AOF持久化功能）</li></ul></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个<strong>时间点</strong>的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务器之间数据格式无法兼容现象</li></ul><h3 id="RDB存储的弊端"><a href="#RDB存储的弊端" class="headerlink" title="RDB存储的弊端"></a>RDB存储的弊端</h3><ul><li>存储数据量大，效率较低<ul><li>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li></ul></li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><p><strong>解决思路</strong></p><ul><li>不写全数据，仅记录部分数据</li><li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li><li>对所有操作均进行记录，排除丢失数据的风险</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记7 Jedis连接并操作Redis</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Jedis简介"><a href="#一、Jedis简介" class="headerlink" title="一、Jedis简介"></a>一、Jedis简介</h3><p><strong>编程语言与redis</strong></p><ul><li><p>Java语言连接redis服务</p><p>Jedis</p><p>SpringData Redis</p><p>Lettuce</p><p>​</p></li></ul><h3 id="二、Jedis操作Redis"><a href="#二、Jedis操作Redis" class="headerlink" title="二、Jedis操作Redis"></a>二、Jedis操作Redis</h3><p><strong>准备工作</strong></p><ul><li><p>基于maven导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>连接redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>)<br></code></pre></td></tr></table></figure></li><li><p>操作redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>关闭redis连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure></li><li><p>API文档</p><p><a href="https://xetorthio.github.io/jedis/">https://xetorthio.github.io/jedis/</a></p></li></ul><h4 id="Jedis简易工具类开发"><a href="#Jedis简易工具类开发" class="headerlink" title="Jedis简易工具类开发"></a>Jedis简易工具类开发</h4><p><strong>基于连接池获取数据</strong></p><ul><li><p>JedisPool：Jedis提供的连接池技术</p><p>​    poolConfig：连接池配置对象</p><p>​    host：redis服务地址</p><p>​    port：redis服务端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JedisPool</span> <span class="hljs-params">(GenericObjectPoolConfig poolConfig, String host, <span class="hljs-keyword">int</span> port)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>(poolConfig, host, port, <span class="hljs-number">2000</span>, (String)<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, (String)<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>封装连接参数</strong></p><ul><li><p>jedis.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jedis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">jedis.prot</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">jedis.maxTotal</span>=<span class="hljs-string">30</span><br><span class="hljs-meta">jedis.maxIdle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>加载配置信息</strong></p><ul><li><p>静态代码块初始化资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<br>    <span class="hljs-keyword">static</span> &#123;<br>        JedisPoolConfig jpc=<span class="hljs-keyword">new</span> JedisPoolConfig();<br>        ResourceBundle rb=ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br>        host=rb.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        port=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        maxTotal=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br>        maxIdle=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br>        jpc.setMaxTotal(maxTotal);<br>        jpc.setMaxIdle(maxIdle);<br>        jp=<span class="hljs-keyword">new</span> JedisPool(jpc,host,port);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>对外访问外接口，提供jedis连接对象，连接从连接池获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> jp.getResource();<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="三、Jedis读写redis数据"><a href="#三、Jedis读写redis数据" class="headerlink" title="三、Jedis读写redis数据"></a>三、Jedis读写redis数据</h3><p><strong>案例实现</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101849577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>需求分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101957835.png" alt="img"></p><p><strong>实现步骤</strong></p><ul><li><p>1.设定业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">(String id, <span class="hljs-keyword">long</span> num)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;业务发起调用&quot;</span>,<span class="hljs-string">&quot;当前第&quot;</span>+num+<span class="hljs-string">&quot;次&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2.设定多线类，模拟用户调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(ture)&#123;<br>    jd.service(id);<br>    <span class="hljs-comment">//模拟调用间隔，设定为1.x秒</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Random r = <span class="hljs-keyword">new</span> Random();<br>      Thread.sleep(<span class="hljs-number">1000</span>+r.nextInt(<span class="hljs-number">200</span>));<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3.设计redis控制方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(String id)</span></span>&#123;<br>  Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>  String value = jedis.get(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>  <span class="hljs-comment">//判定是否具有调用计数控制，利用异常进行控制处理</span><br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-keyword">null</span>)&#123;<br>    jedis.setex(<span class="hljs-string">&quot;compid:&quot;</span>+id,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;&quot;</span>+(Long.MAX_VALUE-<span class="hljs-number">10</span>));<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//有控制，自增，并调用业务</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Long val = redis.incr(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>      business(id,<span class="hljs-number">10</span>+val-Long.MAX_VALUE);<br>    &#125;<span class="hljs-keyword">catch</span>(JedisDataExpection e)&#123;<br>      System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;使用次数到达上线&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      jedis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设计启动主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[],args)</span></span>&#123;<br>  MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;初级用户&quot;</span>);<br>  t1.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记6 key和数据库通用指令</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、key通用操作"><a href="#一、key通用操作" class="headerlink" title="一、key通用操作"></a>一、key通用操作</h2><h3 id="1-key特征"><a href="#1-key特征" class="headerlink" title="1.key特征"></a>1.key特征</h3><ul><li>key是一个字符串，通过key获取redis中保存的数据</li></ul><h3 id="2-key设计的操作"><a href="#2-key设计的操作" class="headerlink" title="2.key设计的操作"></a>2.key设计的操作</h3><ul><li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li><li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li><li>对于key快速查询操作，例如：按指定策略查询key</li></ul><h3 id="3-key基本操作"><a href="#3-key基本操作" class="headerlink" title="3.key基本操作"></a>3.key基本操作</h3><ul><li><p>删除指定key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>获取key是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exists key<br></code></pre></td></tr></table></figure></li><li><p>获取key的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">type key<br></code></pre></td></tr></table></figure><p><strong>key扩展操作（时效性控制）</strong></p></li><li><p>为指定key设置有效期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire key seconds     #设置秒<br>pexpire key milliseconds #设置毫秒<br>expireat key timestamp   #秒时间戳<br>pexpireat key milliseconds-timestamp  #毫秒时间戳<br></code></pre></td></tr></table></figure></li><li><p>获取key的有效时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ttl key<br>pttl key<br></code></pre></td></tr></table></figure><ul><li>ttl命令下，如果返回值为-2则是key不存在；如果返回值是-1，则是key存在且没有设置有效期；如果key设置有效期，则返回当前剩余的有效时常。</li></ul></li><li><p>切换key从时效性到永久性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">persist key  <br></code></pre></td></tr></table></figure><p><strong>key扩展操作（查询模式）</strong></p></li><li><p>查询key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys pattern<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421210222191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="4-key其他操作"><a href="#4-key其他操作" class="headerlink" title="4.key其他操作"></a>4.key其他操作</h3><ul><li><p>为key改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rename key newkey<br>renamenx key newkey  #如果key不存在，就改名<br></code></pre></td></tr></table></figure></li><li><p>对所有key排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort<br></code></pre></td></tr></table></figure></li><li><p>其他key通用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help @generic<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、数据库通用操作"><a href="#二、数据库通用操作" class="headerlink" title="二、数据库通用操作"></a>二、数据库通用操作</h2><p><strong>key的重复问题</strong></p><ul><li>key是由程序员定义的</li><li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li><li>数据不区分种类，类别混杂在一起，极易出现重复或冲突</li></ul><p><strong>解决方案</strong></p><ul><li>redis为每个服务器提供有16个数据库，编号从0-15</li><li>每个数据库之间的数据互相独立</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421210716812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="1-db基本操作"><a href="#1-db基本操作" class="headerlink" title="1.db基本操作"></a>1.db基本操作</h3><ul><li><p>切换数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select index<br></code></pre></td></tr></table></figure></li><li><p>其他操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">quit<br>ping<br>echo message<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-db相关操作"><a href="#2-db相关操作" class="headerlink" title="2.db相关操作"></a>2.db相关操作</h3><ul><li><p>数据移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">move key db<br></code></pre></td></tr></table></figure></li><li><p>数据清除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">dbsize   #查看当前库中key的总数量<br>flushdb  #清除当前库中所有的key<br>flushall #清除所有库中的key<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记5 sorted_set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="sorted-set类型"><a href="#sorted-set类型" class="headerlink" title="sorted_set类型"></a>sorted_set类型</h2><ul><li>新的存储需求：数据排序有利于数据的有效显示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要的存储结构：新的存储模型，可以保存可排序的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421164359468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="sorted-set类型数据的基本操作"><a href="#sorted-set类型数据的基本操作" class="headerlink" title="sorted_set类型数据的基本操作"></a>sorted_set类型数据的基本操作</h2><ul><li><p>添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd key score1 member1 [score2 member2]<br><br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrange key start stop [WITHSCORES]<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrem key member [member1 ...]<br></code></pre></td></tr></table></figure></li><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrangebyscore key min max [WITHSCORES] [LIMIT]<br>zrevrangebyscore key max min [WITHSCORES] #逆排序<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421165618285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zremrangebyrank key start stop   #按索引删除<br>zremrangebyscore key min max<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em>：</p><ul><li><em>min与max用于限定搜索查询的条件</em></li><li><em>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</em></li><li><em>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</em></li></ul><p>​    </p><ul><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">zcard key<br>zcount key min max<br><br></code></pre></td></tr></table></figure></li><li><p>集合交、并操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zinterstore destination numkeys key [key ...]<br>zunionstore destination numkeys key [key ...]<br></code></pre></td></tr></table></figure></li></ul><h2 id="sorted-set类型数据的扩展操作"><a href="#sorted-set类型数据的扩展操作" class="headerlink" title="sorted_set类型数据的扩展操作"></a>sorted_set类型数据的扩展操作</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171218699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>获取数据对应的索引（排名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrank key member<br>zrevrank key member<br></code></pre></td></tr></table></figure></li><li><p>score 值获取与修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zscore key member<br>zincrby key increment member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421171509850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于计数器组合排序功能对应的排名</p></li></ul><h2 id="sorted-set类型数据操作的注意事项"><a href="#sorted-set类型数据操作的注意事项" class="headerlink" title="sorted_set类型数据操作的注意事项"></a>sorted_set类型数据操作的注意事项</h2><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时侯要慎重</li><li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171846808.png" alt="img"></p><p> <strong>解决方案</strong></p><ul><li><p>对于基于时间线限定的任务处理，将处理时间记录位score值，利用排序功能区分处理的先后顺序</p></li><li><p>记录下一个要处理的事件，当到期后处理对应的任务，移除redis中的记录，并记录下一个要处理的时间</p></li><li><p>当新任务加入时，判定并更新当前下一个要处理的任务时间</p></li><li><p>为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set.例如1小时内，1天内，年度等，操作时逐渐提升，将即将操作的若干个任务纳入到1小时内处理队列中</p></li><li><p>获取当前系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">time<br></code></pre></td></tr></table></figure><ul><li>redis应用于定时任务顺序管理或任务过期管理</li></ul></li></ul><p><strong>业务场景（任务/消息权重设定应用）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421172226972.png" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042117234594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><p>带有权重的任务，优先处理权重高的任务，采用score记录权重即可</p><p><img src="https://img-blog.csdnimg.cn/20210421172537332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记4 Set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p><p><img src="https://img-blog.csdnimg.cn/20210421154631120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2021042115482653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h2 id="set类型数据的基本操作"><a href="#set类型数据的基本操作" class="headerlink" title="set类型数据的基本操作"></a>set类型数据的基本操作</h2><ul><li><p>添加书籍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smembers key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srem key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scard key<br></code></pre></td></tr></table></figure></li><li><p> 判断集合中是否包含指定数据</p></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sismember key member<br></code></pre></td></tr></table></figure><h2 id="set类型数据的扩展操作1"><a href="#set类型数据的扩展操作1" class="headerlink" title="set类型数据的扩展操作1"></a>set类型数据的扩展操作1</h2><p><strong>业务操作</strong></p><p>每位用户首次使用进入头条时候会设置3项爱好的内容，但是后期为了增加用户的活跃度，兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？</p><p><strong>业务分析</strong></p><ul><li>系统分析出各个分类的最新或最热点信息条目并组织成set集合</li><li>随机挑选其中部分信息</li><li>配合用户关注信息分类中的热点信息组织展示的全信息集合</li></ul><p><strong>解决方案</strong></p><ul><li><p>随机获取集合中指定数量的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srandmember key [count]<br></code></pre></td></tr></table></figure></li><li><p>随机获取集合中的某个数据并将该数据移除集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">spop key<br></code></pre></td></tr></table></figure></li><li><p>redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等</p></li></ul><h2 id="set类型数据的扩展操作2"><a href="#set类型数据的扩展操作2" class="headerlink" title="set类型数据的扩展操作2"></a>set类型数据的扩展操作2</h2><ul><li><p>求两个集合的交、并、差集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinter key [key2]<br></code></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinterstore destination key1 [key2]<br>sunionstore destination key1 [key2]<br>sdiffstore destination key1 [key2]<br><br></code></pre></td></tr></table></figure></li><li><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smove source destination member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421162116514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</p></li><li><p>显示共同关注（一度）</p></li><li><p>显示共同好友（一度）</p></li><li><p>由用户A出发，获取到好友用户B的好友信息列表（一度）</p></li><li><p>由用户A出发，获取到好友用户B的购物清单列表（二度）</p></li><li><p>由用户A出发，获取到好友用户B的游戏充值列表（二度）</p></li></ul><h2 id="set类型数据操作的注意事项"><a href="#set类型数据操作的注意事项" class="headerlink" title="set类型数据操作的注意事项"></a>set类型数据操作的注意事项</h2><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421162650651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>依赖set集合数据不重复的特征，依赖set集合hash存储结构特征完成数据过滤与快速查询</li><li>根据用户id获取用户所有角色</li><li>根据用户所有角色获取用户所有操作权限放入set集合</li><li>根据用户所有觉得获取用户所有数据全选放入set集合</li></ul><p><strong>校验工作</strong>：</p><p>​    redis提供基础数据还是提供校验结果</p><ul><li>redis应用于同类型不重复数据的合并操作</li></ul><h2 id="set类型应用场景"><a href="#set类型应用场景" class="headerlink" title="set类型应用场景"></a>set类型应用场景</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163055810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>利用set集合的数据去重特征，记录各种访问数据</li><li>建立string类型数据，利用incr统计日访问量（PV)</li><li>建立set模型，记录不同cookie数量（UV)</li><li>建立set模型，记录不用IP数量（IP)</li></ul><p><strong>业务场景（黑白名单）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163311178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>基于经营战略设定问题用户发现、鉴别规则</p></li><li><p>周期性更行满足规则的用户黑名单，加入set集合</p></li><li><p>用户行为信息达到后与黑名单进行比比对，确认行为去向</p></li><li><p>黑名单过滤IP地址：应用于开放游客访问权限的信息源</p></li><li><p>黑名单过滤设备信息：应用于限定访问设备的信息源</p></li><li><p>黑名单过滤用户：应用于基于访问权限的信息源</p></li><li><p>redis应用于基于黑名单与白名单设定的服务控制</p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记3 List数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用双向链表存储结构实现</p><p><img src="https://img-blog.csdnimg.cn/20210421145318123.png" alt="img"></p></li></ul><h2 id="list类型数据基本操作"><a href="#list类型数据基本操作" class="headerlink" title="list类型数据基本操作"></a>list类型数据基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush key value [value2]...   #在key对应的list头部添加元素<br>rpush key value [value2]...   #在key对应的list尾部添加元素<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrange key start stop    <br>lindex key index<br>llen key<br><br></code></pre></td></tr></table></figure></li><li><p>获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpop key                      #在key对应的list头部删除元素<br>rpop key                      #在key对应的list尾部删除元素<br></code></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">blpop key1 [key2] timeout<br>brpop key1 [key2] timeout<br></code></pre></td></tr></table></figure><p>阻塞式获取，获取值如果还没有的时候等待，如果有值就获取。</p></li></ul><h2 id="list类型数据扩展操作"><a href="#list类型数据扩展操作" class="headerlink" title="list类型数据扩展操作"></a>list类型数据扩展操作</h2><p><strong>业务场景</strong></p><p>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息</p><p><img src="https://img-blog.csdnimg.cn/20210421151850933.png" alt="img"></p><p><strong>解决方案</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrem key count value<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421152228925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>redis 应用于具有操作先后顺序的数据控制</li></ul><h2 id="list类型数据操作注意事项"><a href="#list类型数据操作注意事项" class="headerlink" title="list类型数据操作注意事项"></a>list类型数据操作注意事项</h2><ul><li>list保存的数据都是string类型，数据总容量有限，最多2[^32]-1个元素。</li><li>list具有索引概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第二页及更多的信息通过数据库的形式加载</li></ul><h2 id="list类型应用场景"><a href="#list类型应用场景" class="headerlink" title="list类型应用场景"></a>list类型应用场景</h2><p><strong>业务场景</strong></p><ol><li>twitter、新浪微博、腾讯微博中个人用于的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的事件顺序展示</li><li>企业运营过程中，系统将产生出大量的运营数据，如何保障堕胎服务器操作日志的统一顺序输出？</li></ol><p><strong>解决方案</strong></p><ul><li>依赖list的数据具有顺序的特征对信息进行管理</li><li>使用队列模型解决多路信息汇总合并的问题</li><li>使用栈模型解决最新消息的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记2 Hash数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、hash类型"><a href="#一、hash类型" class="headerlink" title="一、hash类型"></a>一、hash类型</h2><ul><li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息。</p></li><li><p>需要的存储结构：一个存储空间保存多个键值对数据</p></li><li><p>hash类型：底层使用哈希表结构实现数据存储。</p><p><img src="https://img-blog.csdnimg.cn/20210413221436565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><strong>hash存储结构优化</strong></p><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul><h2 id="二、hash类型数据的基本操作"><a href="#二、hash类型数据的基本操作" class="headerlink" title="二、hash类型数据的基本操作"></a>二、hash类型数据的基本操作</h2><ul><li>添加/修改数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset key field value<br></code></pre></td></tr></table></figure></li><li>获取数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hget key field<br>hgetall key<br></code></pre></td></tr></table></figure></li><li>删除数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdel key field1 [field2]<br></code></pre></td></tr></table></figure></li><li>获取哈希表中是否存在指定的字段<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexists key field<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、hash类型数据拓展操作"><a href="#三、hash类型数据拓展操作" class="headerlink" title="三、hash类型数据拓展操作"></a>三、hash类型数据拓展操作</h2><ul><li>获取哈希表中所有的字段名或字段值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hkeys key<br></code></pre></td></tr></table></figure></li><li>设定指定字段的数值数据增加指定范围的值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby key field increment<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、hash类型数据操作的注意事项"><a href="#四、hash类型数据操作的注意事项" class="headerlink" title="四、hash类型数据操作的注意事项"></a>四、hash类型数据操作的注意事项</h2><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li><li>每个hash可以存储2的32次方-1个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，不可滥用，不能将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈。</li></ul><h2 id="五、hash类型的应用场景"><a href="#五、hash类型的应用场景" class="headerlink" title="五、hash类型的应用场景"></a>五、hash类型的应用场景</h2><p><strong>业务场景1</strong></p><p>电商网站购物车的实现</p><p><img src="https://img-blog.csdnimg.cn/20210414104649492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>业务分析</strong></p><ul><li>仅分析购物车的redis存储模型（添加、浏览、更改数量、删除、清空</li><li>购物车与数据库间持久化同步</li><li>购物车与订单间关系（提交购物车：读取数据生成订单 商家临时价格调整：隶属于订单级别）</li><li>未登录用户购物车信息存储（cookie存储）</li></ul><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414110019950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210414110917809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>当前设计是否加速了购物车的呈现</strong><br>当前仅仅是将数据存储到reids中，并没有起到加速的作用，商品还需要二次查询数据库</p><ul><li>每条购物车中的商品记录保存成两条field</li><li>field1专用于保存购买数量<br> 命名格式：商品id：nums<pre><code> 保存数据：数值</code></pre></li><li>field2专用于保存购物车中的显示信息，包含文字描述，图片地址，所属商家信息等<br>命名格式：商品id：info<br>保存数据：json</li></ul><p><strong>我们可以把field2作为独立hash，来减少数据的重复</strong><br><font color=#999AAA>创建数据，如果已存在数据则创建失败，如果没有则创建成功</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hsetnx key field value<br></code></pre></td></tr></table></figure><p><strong>业务场景2</strong></p><p>抢购活动</p><p><img src="https://img-blog.csdnimg.cn/20210414111343238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414111420146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><font color=#999AAA>创建id为00001的商铺，货物1 25个，货物2 100个。</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hmset shopping:id:00001 good1 25 good2 100<br></code></pre></td></tr></table></figure><p><font color=#999AAA>店铺货物1被抢走了10个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby shopping:id:00001 good1 -10<br></code></pre></td></tr></table></figure><hr><p>学习链接:<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记1 String数据类型</title>
    <link href="/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><ol><li>String</li><li>Hash</li><li>list</li><li>set</li><li>sorted_set</li></ol><h1 id="String数据类型"><a href="#String数据类型" class="headerlink" title="String数据类型"></a>String数据类型</h1><h2 id="1-redis-数据存储格式"><a href="#1-redis-数据存储格式" class="headerlink" title="1.redis 数据存储格式"></a>1.redis 数据存储格式</h2><ul><li><p> redis自身是一个Map，其中所有的数据类型都是采用key：value的形式存储。</p></li><li><p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>name</td><td>Ruby</td></tr><tr><td>age</td><td>17</td></tr></tbody></table></li></ul><h2 id="2-string类型"><a href="#2-string类型" class="headerlink" title="2.string类型"></a>2.string类型</h2><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>-存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数形式展示，可作为数字操作使用。</li></ul><h2 id="3-string类型数据的基本操作"><a href="#3-string类型数据的基本操作" class="headerlink" title="3.string类型数据的基本操作"></a>3.string类型数据的基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key value<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">get key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mset key1 value1 key2 value2 ...<br></code></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mget key<br></code></pre></td></tr></table></figure></li><li><p>获取数据字符串个数（字符串长度）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">strlen key<br></code></pre></td></tr></table></figure></li><li><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">append key value<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-string类型数据的拓展操作"><a href="#4-string类型数据的拓展操作" class="headerlink" title="4.string类型数据的拓展操作"></a>4.string类型数据的拓展操作</h2><ul><li><p>设置数据具有指定的生命周期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key seconds value<br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><p><em>设置user时效为5s，超出5秒则无法获取。</em></p><p><img src="https://img-blog.csdnimg.cn/20210413204021597.png" alt="img"></p></li><li><p>redis控制数据的生命周期，通过数据是否失效控制业务，适用于所有具有时效性限定控制的操作</p></li></ul><h2 id="5-string类型数据操作的注意事项"><a href="#5-string类型数据操作的注意事项" class="headerlink" title="5.string类型数据操作的注意事项"></a>5.string类型数据操作的注意事项</h2><pre><code>1. 表示运行结果是否成功 （integer）0 → false 失败 （integer）1 → true 成功</code></pre><ol start="2"><li>表示运行结果值<br>（integer） 3 → 3 3个<br> （integer） 1 →1 1个</li><li>数据未获取<br>（nil）== null</li><li>数据最大存储量<br>512MB</li><li>数据计算最大范围（java中的long的最大值）<br>9223372036854775807</li></ol><h2 id="6-业务场景"><a href="#6-业务场景" class="headerlink" title="6.业务场景"></a>6.业务场景</h2><ul><li>主页高频访问信息显示控制，列如新浪微博大V主页显示粉丝数于微博数量</li></ul><p><strong>解决方案</strong> </p><ul><li>在redis中为大v用户设定用户信息，以用户主键和属性值为key，后台设定定时刷新策略。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210413210057424.png" alt="img"></p><ul><li><p>在redis中以json格式存储大v用户，定时刷新</p><p><img src="https://img-blog.csdnimg.cn/20210413210832666.png" alt="img"></p></li></ul><h2 id="7-key的设置约定"><a href="#7-key的设置约定" class="headerlink" title="7.key的设置约定"></a>7.key的设置约定</h2><ul><li><p>热点数据key命名管理</p><p><img src="https://img-blog.csdnimg.cn/20210413211455137.png" alt="img"></p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的网站推荐</title>
    <link href="/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<p>一些我平常使用的网站，个人觉得还都挺不错的，就写在上面推荐一下。</p><h2 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h2><h3 id="1-Canva"><a href="#1-Canva" class="headerlink" title="1.Canva"></a>1.Canva</h3><p>网址：<a href="https://www.canva.cn/">https://www.canva.cn</a></p><p>这是一个在线设计的网站。各种实用模板，包括海报，PPT、微信公众号封面，LOGI等。还有一些不同的图片素材。</p><p><img src="https://img-blog.csdnimg.cn/20210420210755800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Pexels"><a href="#2-Pexels" class="headerlink" title="2.Pexels"></a>2.Pexels</h3><p>网址：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>具有很丰富的高质量图片网站，不光可以免费下载高清图片，而且还可以下载视频，没有版权。</p><p><img src="https://img-blog.csdnimg.cn/20210420211431755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="3-Pixabay"><a href="#3-Pixabay" class="headerlink" title="3.Pixabay"></a>3.Pixabay</h2><p>网址：<a href="https://pixabay.com/">https://pixabay.com/</a></p><p>拥有很多创意向，高清的图片，可以免费下载。</p><p><img src="https://img-blog.csdnimg.cn/20210420212000239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="4-wallhaven"><a href="#4-wallhaven" class="headerlink" title="4.wallhaven"></a>4.wallhaven</h2><p>网址：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>有很多不同种类的图片，分辨率非常高，适合用来当作壁纸或各种背景图。</p><p><img src="https://img-blog.csdnimg.cn/20210420212653446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="5-Iconfont"><a href="#5-Iconfont" class="headerlink" title="5.Iconfont"></a>5.Iconfont</h2><p>网址：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>这是国内第一个最大功能最全的矢量图标库，由阿里巴巴团队稻造的，拥有大量不同的图标，基本上都可以找到自己想要的。</p><p><img src="https://img-blog.csdnimg.cn/20210420213110352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="6-中国色"><a href="#6-中国色" class="headerlink" title="6.中国色"></a>6.中国色</h3><p>网址：<a href="http://zhongguose.com/">http://zhongguose.com/</a></p><p>带有国风色彩的颜色搭配网站。点击RGB搭配的右侧就可以复制、导入颜色了。</p><p><img src="https://img-blog.csdnimg.cn/20210420222253614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="7-ColorHexa"><a href="#7-ColorHexa" class="headerlink" title="7.ColorHexa"></a>7.ColorHexa</h3><p>网址：<a href="https://www.colorhexa.com/">https://www.colorhexa.com/</a></p><p>这是一个方便，颜色种类众多的色彩搭配网站，只需输入想要搭配的颜色，就可以给出不同种的颜色搭配方案。</p><p><img src="https://img-blog.csdnimg.cn/20210420222635239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="学术导航类"><a href="#学术导航类" class="headerlink" title="学术导航类"></a>学术导航类</h2><h3 id="1-科塔学术导航"><a href="#1-科塔学术导航" class="headerlink" title="1.科塔学术导航"></a>1.科塔学术导航</h3><p>网址：<a href="https://site.sciping.com/">https://site.sciping.com/</a></p><p>一个质量不错的学术导航网站，站内分类包括文献数据，期刊出版，学术工具，科研软件，科研数据，学术搜索等。</p><p>它还提供科研社交，科学传播，科研机构版块，每一个版块也会进行具体网站分类；最后，网站的常用推荐功能也可以让你发现很多高质量的学术网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214033485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p>网址：<a href="https://www.chongbuluo.com/">https://www.chongbuluo.com/</a></p><p>功能齐全、很实用的学术搜索网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214747828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="课程学习类"><a href="#课程学习类" class="headerlink" title="课程学习类"></a>课程学习类</h2><h3 id="1-MOOC"><a href="#1-MOOC" class="headerlink" title="1.MOOC"></a>1.MOOC</h3><p>网址：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></p><p>国内联合750所高校共同开发的教学网站。收录了非常多名师教学课程。课程种类也非常齐全。</p><p><img src="https://img-blog.csdnimg.cn/20210420215331708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Visuwords"><a href="#2-Visuwords" class="headerlink" title="2.Visuwords"></a>2.Visuwords</h3><p>网址：<a href="https://visuwords.com/">https://visuwords.com/</a></p><p>这是一个比较有趣的交互式单词学习网站，当你输入一个单词回车后，会给出这个单词的近义词、反义词、从属关系词、因果关系词、属性、实例、分词、动词等等。</p><p>它通过不同的颜色和线条，不同颜色的球体构成一个单词树状图，来代表不同单词之间的关系和类型。</p><p><img src="https://img-blog.csdnimg.cn/20210420220418339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-白描"><a href="#1-白描" class="headerlink" title="1.白描"></a>1.白描</h3><p>网址：<a href="https://web.baimiaoapp.com/">https://web.baimiaoapp.com/</a></p><p>这是一个在线扫描工具，有图片文字提取，电子表格识别，PDF转文字，都是免费使用。</p><p><img src="https://img-blog.csdnimg.cn/20210420221121669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Docsmall"><a href="#2-Docsmall" class="headerlink" title="2.Docsmall"></a>2.Docsmall</h3><p>网址：<a href="https://docsmall.com/">https://docsmall.com/</a></p><p>一个免费在线文件压缩网站，只要上传文件之后，进行处理，在下载就ok了，目前支持图片压缩、GIF压缩、PDF压缩、PDF合并、PDF分割功能。</p><p><img src="https://img-blog.csdnimg.cn/20210420221534842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="3-地图生成器"><a href="#3-地图生成器" class="headerlink" title="3.地图生成器"></a>3.地图生成器</h3><p>网址： <a href="http://datav.aliyun.com/tools/atlas/#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5">点击这里</a></p><p>可以下载国内省份，城市以及县城的svg格式的地图素材，并可以导入到PPT中，可编辑。</p><p><img src="https://img-blog.csdnimg.cn/20210420222012372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><hr><p>后续遇到比较不错的网址还会继续更新下去…</p>]]></content>
    
    
    <categories>
      
      <category>好用的网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
