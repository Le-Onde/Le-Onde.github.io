<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java笔记3 多线程常见问题</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是多线程"><a href="#一、什么是多线程" class="headerlink" title="一、什么是多线程"></a>一、什么是多线程</h3><p>线程是指程序在运行的过程中，能够执行程序代码的一个执行单元。</p><p>java语言中，线程有五种状态：新建、就绪、运行、阻塞、死亡。</p><p><img src="https://img-blog.csdn.net/20181009142636819?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODk2MTk0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="二、进程与线程的区别？"><a href="#二、进程与线程的区别？" class="headerlink" title="二、进程与线程的区别？"></a>二、进程与线程的区别？</h3><p>进程是指一段正在执行的程序。而线程有时也被成为轻量级的进程，它是程序执行的最小单元，一个进程可以有多个线程。各个线程之间共享程序的内存空间（代码段、数据段、堆空间）及一些进程级的文件（列如：打开的文件），但是各个线程拥有自己的栈空间。在操作系统级别上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行。 </p><h3 id="三、为什么要使用多线程？"><a href="#三、为什么要使用多线程？" class="headerlink" title="三、为什么要使用多线程？"></a>三、为什么要使用多线程？</h3><ul><li><strong>提高执行效率，减少程序的响应时间。</strong>因为单线程执行的过程只有一个有效的操作序列，如果某个操作很耗时（或等待网络响应），此时程序就不会响应鼠标和键盘等操作，如果使用多线程，就可以将耗时的线程分配到一个单独的线程上执行，从而使程序具备更好的交互性。</li><li>与进程相比，线程的创建和切换开销更小。因开启一个新的进程需要分配独立的地址空间，建立许多数据结构来维护代码块等信息，而运行于同一个进程内的线程共享代码段、数据段、线程的启动和切换的开销比进程要少很多。同时<strong>多线程在数据共享方面效率非常高。</strong></li><li>目前市场上服务器配置大多数都是多CPU或多核计算机等，它们本身而言就具有执行多线程的能力，如果使用单个线程，就无法重复利用计算机资源，造成资源浪费。因此在多CPU计算机上<strong>使用多线程能提高CPU的利用率。</strong></li><li><strong>利用多线程能简化程序程序的结构，是程序便于理解和维护。</strong>一个非常复杂的进程可以分成多个线程来执行。</li></ul><h3 id="四、同步与异步有什么区别"><a href="#四、同步与异步有什么区别" class="headerlink" title="四、同步与异步有什么区别"></a>四、同步与异步有什么区别</h3><ul><li><p><strong>同步</strong>，<strong>可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</strong>。  </p></li><li><p><strong>异步</strong>，**执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 **</p><p>在多线程的环境中，通常会遇到数据共享问题，为了确保共享资源的正确性和安全性，就必须对共享数据进行同步处理（也就是锁机制）。对共享数据进行同步操作（增删改），就必须要获得每个线程对象的锁（this锁），这样可以保证同一时刻只有一个线程对其操作，其他线程要想对其操作需要排队等候并获取锁。当然在等候队列中优先级最高的线程才能获得该锁，从而进入共享代码区。</p><p>Java语言在同步机制中提供了语言级的支持，可以通过使用<strong>synchronize</strong>关键字来实现同步，但该方法是以很大的系统开销作为代价的，有时候甚至可能造成死锁，所以，同步控制并不是越多越好，要避免所谓的同步控制。实现同步的方法有两种：<strong>①同步方法（this锁）。②同步代码块（this锁或者自定义锁）</strong>当使用this锁时，就与同步方法共享同一锁，只有当①释放，②才可以使用。同时，同步代码块的范围也小于同步方法，建议使用，相比之下能够提高性能。 </p></li></ul><h3 id="五、如何实现java多线程"><a href="#五、如何实现java多线程" class="headerlink" title="五、如何实现java多线程"></a>五、如何实现java多线程</h3><p>在Java语言中实现多线程的方法有三种，其中前两种为常用方法：</p><ol><li><strong>继承Thread类，重写run()方法</strong></li></ol><p>​     Thread本质上也是实现了Runnable接口的一个实例，它表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()方法，start()方法是一个本地（native）方法，它将启动一个新的线程，并执行run()方法（执行的是自己重写了Thread类的run()方法），同时调用start()方法并不是执行多线程代码，而是使得该线程变为可运行状态（Runnable）,什么时候运行多线程代码由操作系统决定。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<span class="hljs-comment">//线程的函数体</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread thread = <span class="hljs-keyword">new</span> Thread<br>     thread.run();<span class="hljs-comment">//开启线程</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实现Runnable接口，并实现该结构的run()方法</strong></li></ol><ul><li>自定义实现Runnable接口，实现run()方法。</li><li>创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。</li><li>调用Thread的start()方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>   <span class="hljs-function">pulic <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread myThread = <span class="hljs-keyword">new</span> MyThread;<br>     Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);<br>     thread.start();<span class="hljs-comment">//启动线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不管是哪种方法，最终都是通过Thread类的API来控制线程。</em></p><ol start="3"><li><p><strong>实现Callable接口，重写call()方法</strong></p><p>Callable接口实际是属于Executor框架中的功能类，Callable结构与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要体现在如下三点：</p><ol><li>Callable在任务结束后可以提供一个返回值，Runnable无法提供该功能。</li><li>Callable中的call()方法可以跑出异常，而Runnable中的run()不能跑出异常。</li><li>运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供能了检查计算是否完成的方法。由于线程输入异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监控目标线程来调用call()方法的情况，当调用Future的get()方法以获取结果时，当前线程会阻塞，直到目标线程的call()方法结束返回结果。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableAndFuture</span></span>&#123;<br>   <span class="hljs-comment">//创建线程类</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>     Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> CallableTest());<br>     <span class="hljs-keyword">try</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;waiting thread to finish&quot;</span>);<br>          System.out.println(future.get());<br>        &#125;<span class="hljs-keyword">catch</span>&#123;Exception e&#125;&#123;<br>          e.printStackTrace<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    建议：当需要实现多线程时，一般推荐使用Runnable接口方式，因为Thread类定义了多种方法可以被派生类使用或重写，但是只有run()方法必须被重写，在run()方法中实现这个线程的主要功能，这当然也是实现Runnable接口所需的方法。再者，我们很多时候继承一个类是为了去加强和修改这个类才去继承的。因此，如果我们没有必要重写Thread类中的其他方法，那么通过继承Thread类和实现Runnable接口的效果是相同的，这样的话最好还是使用Runnable接口来创建线程。 </p></li></ol><h3 id="六、run方法与start方法的区别"><a href="#六、run方法与start方法的区别" class="headerlink" title="六、run方法与start方法的区别"></a>六、run方法与start方法的区别</h3><p>通常，系统通过调用线程类的start()方法启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以别JVM调用执行，执行的过程中，JVM通过调用想成类的run()方法来完成实际的操作，当run()方法结束后，线程也就会终止。<br>如果直接调用线程类的run()方法，就会被当做一个普通函数调用，程序中仍然只有一个主程序，也就是说start()方法能够异步调用run()方法，但是直接调用run()方法却是同步的，也就无法达到多线程的目的。</p><h3 id="七、多线程数据同步实现的方法有哪些"><a href="#七、多线程数据同步实现的方法有哪些" class="headerlink" title="七、多线程数据同步实现的方法有哪些"></a>七、多线程数据同步实现的方法有哪些</h3><p>当使用多线程访问同一数据时，非常容易出现线程安全问题，因此采用同步机制解决。Java提供了三种方法：</p><ol><li><p><strong>synchronized关键字</strong></p><p> 在Java语言中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的synchronize代码时，需要先获取这个锁，然后再去执行相应的代码，执行结束后，释放锁。</p><p>synchronize关键字主要有两种用法（synchronize方法和synchronize代码块）</p><ul><li><p>synchronized方法：在方法的声明前加synchronize关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> synchronize <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>将需要对同步资源的操作放入test()方法中，就能保证此资源在同一时刻只能被一个线程调用，从而保证资源的安全性。然而当此方法体规模非常大时，会影响系统的效率。</p></li><li><p>synchronized块：既可以把任意的代码段声明为synchronized，也可以指定上锁的对象，有非常高的灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(syncObject)&#123;<br>    <span class="hljs-comment">//访问syncObject的代码块</span><br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>wait()方法与notify()方法</strong></p><p>当使用synchronized来修饰某个共享资源时，如果线程A1在执行synchronized代码，线程A2也要执行同一对象的统同一synchronize的代码，线程A2将要等到线程A1执行完后执行，这种情况可以使用wai()和notify()。必须是统一把锁，才生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;  <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> res[];  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumberPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, <span class="hljs-keyword">byte</span> a[])</span></span>&#123;  <br>           <span class="hljs-keyword">this</span>.number = number;  <br>           res = a;  <br>       &#125;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;  <br>           <span class="hljs-keyword">synchronized</span> (res)&#123;  <br>               <span class="hljs-keyword">while</span>(count-- &gt; <span class="hljs-number">0</span>)&#123;  <br>                   <span class="hljs-keyword">try</span> &#123;  <br>                       res.notify();<span class="hljs-comment">//唤醒等待res资源的线程，把锁交给线程（该同步锁执行完毕自动释放锁）  </span><br>                       System.out.println(<span class="hljs-string">&quot; &quot;</span>+number);  <br>                       res.wait();<span class="hljs-comment">//释放CPU控制权，释放res的锁，本线程阻塞，等待被唤醒。  </span><br>                       System.out.println(<span class="hljs-string">&quot;------线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;获得锁，wait()后的代码继续运行：&quot;</span>+number);  <br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                       <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>                       e.printStackTrace();  <br>                   &#125;  <br>               &#125;<span class="hljs-comment">//end of while  </span><br>               <span class="hljs-keyword">return</span>;  <br>           &#125;<span class="hljs-comment">//synchronized  </span><br>             <br>       &#125;  <br>   &#125;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;  <br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> a[] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//以该对象为共享资源  </span><br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">1</span>),a),<span class="hljs-string">&quot;1&quot;</span>).start();  <br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">2</span>),a),<span class="hljs-string">&quot;2&quot;</span>).start();  <br>       &#125;  <br>   &#125;  <br><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong> </p><p><img src="https://img-blog.csdnimg.cn/20210426222413506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p><strong>lock</strong></p><ul><li>lock()：以阻塞的方式获取锁，也就是说，如果获取到了锁，就会执行，其他线程需要等待，unlock()锁后别的线程才能执行，如果别的线程持有锁，当前线程等待，直到获取锁后返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span>(ProdLine.size() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;队列是空的，请稍候&quot;</span>);<br>                empty.await();<br>            &#125;<br>            m = ProdLine.removeFirst();<br>            full.signal(); <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>tryLock()。以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立即返回true，否则，返回false。</li><li>tryLock(long timeout,TimeUnit unit)。在给定的时间单元内，获取到了锁返回true，否则false。</li><li>lockInterruptibly().如果获取了锁，立即返回；如果没有锁，当前线程处于休眠状态，直到获取锁，或者当前线程被中断（会收到InterruptedException异常）。它与lock()方法最大的区别在于如果()方法获取不到锁，就会一直处于阻塞状态，且会忽略Interrupt()方法。</li></ul></li></ol><h3 id="八、sleep方法与wait方法有什么区别"><a href="#八、sleep方法与wait方法有什么区别" class="headerlink" title="八、sleep方法与wait方法有什么区别"></a>八、sleep方法与wait方法有什么区别</h3><p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法，直到被唤醒或等待时间超时。</p><p><strong>区别：</strong></p><ul><li><p>原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到时间一到，此线程会自动“苏醒”。</p><p>wait()方法是Object类的方法，用于线程间通讯，这个方法会使当前线程拥有该对象锁的进程等待，直到其他线程调用notify()方法（或notifyAll方法）时才“醒”来，不过开发人员可可以给它指定一个时间，自动“醒”来。与wait()方法配套的方法还有notify()和notifyAll()方法。</p></li><li><p>对锁的处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通讯，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，调用后会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。</p></li><li><p>使用区域不同，由于wait()的特殊意义，因此它必须放在同步控制方法或者同步代码块中使用，而sleep()则可以放在任何地方使用。</p></li><li><p>sleep()方法 必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。</p><p> sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep()方法。而推荐使用wait()方法。</p></li></ul><h3 id="九、sleep与yield区别"><a href="#九、sleep与yield区别" class="headerlink" title="九、sleep与yield区别"></a>九、sleep与yield区别</h3><ul><li>sleep()给其他线程运行机会时，不考虑线程的优先级，因此会给低优先级的线程以运行的机会，而yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</li><li>sleep()方法会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程很可能在进入到可执行状态后马上又被执行。</li></ul><h3 id="十、终止线程的方法有哪些"><a href="#十、终止线程的方法有哪些" class="headerlink" title="十、终止线程的方法有哪些"></a>十、终止线程的方法有哪些</h3><ul><li><p>stop()方法，它会释放已经锁定的所有监视资源，如果当前任何一个受监视资源保护的对象处于一个不一致的状态（执行了一部分），其他线程线程将会获取到修改了的部分值，这个时候就可能导致程序执行结果的不确定性，并且这种问题很难被定位。</p></li><li><p>suspend()方法，容易发生死锁。因为调用suspend()方法不会释放锁，这就会导致此线程挂起。</p><p>以上两种方法的不安全性，Java语言已经不建议使用以上两种方法来终止线程了。</p></li><li><p>一般建议采用的方法是让线程自行结束进入Dead状态。一个线程进入Dead状态，既执行完run()方法，也就是说提供一种能够自动让run()方法结束的方式，在实际中，我们可以通过flag标志来控制循环是否执行，从而使线程离开run方法终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Boolean flag;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>     flag=<span class="hljs-keyword">false</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(flag);<span class="hljs-comment">//do something</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述通过stop()方法虽然可以终止线程，但同样也存在问题；当线程处于阻塞状态时（sleep()被调用或wait()方法被调用或当被I/O阻塞时）,上面介绍的方法就不可用了。此时使用interrupt()方法来打破阻塞的情况，当interrupt()方法被调用时，会跑出interruptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;thread go to sleep&quot;</span>);<br>       <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//用休眠来模拟线程被阻塞</span><br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread finish&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;thread is interrupted!);</span><br><span class="hljs-string">           &#125;</span><br><span class="hljs-string">     &#125; </span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">thread.start();</span><br><span class="hljs-string">therad.interrupt();</span><br></code></pre></td></tr></table></figure><p><strong>程序运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">thread go to sleep<br>thread is interrupted!<br></code></pre></td></tr></table></figure><p>如果I/0停滞，进入非运行状态，基本上要等到I/O完成才能离开这个状态。或者通过出发异常，使用readLine()方法在等待网络上的一个信息，此时线程处于阻塞状态，让程序离开run()就出发close()方法来关闭流，这个时候就会跑出IOException异常，通过捕获此异常就可以离开run()。</p></li></ul><h3 id="十一、-synchronized与Lock有什么异同"><a href="#十一、-synchronized与Lock有什么异同" class="headerlink" title="十一、 synchronized与Lock有什么异同"></a>十一、 synchronized与Lock有什么异同</h3><p>Java语言中提供了两种锁机制的实现对某个共享资源的同步；synchronized和Lock。其中synchronized使用Object类对象本身的notify()、wait()、notifyAll()调度机制，而Lock使用condition包进行线程之间的调度，完成synchronized实现的所有功能</p><ul><li><p><strong>用法不一样。</strong>synchronized既可以加在方法上，也可以加在特定的代码块中，括号中表示需要的锁对象。而Lock需要显式的指定起始位置和终止位置。synchronized是托管给JVM执行的，而Lock的锁定是通过代码实现，他有比synchronized更精确的线程语义。</p></li><li><p><strong>性能不一样。</strong>在JDK5中增加了一个Lock接口的实现类ReentrantLock。它不仅拥有和synchronized相同的并发性和内存语义、还多了锁投票、定时锁、等候锁和中断锁。它们的性能在不同的情况下会有所不同；在资源竞争不激烈的情况下，synchronized的性能要优于RenntrantLock，但是资源竞争激烈的情况下，synchronized性能会下降的非常快，而ReentrantLock的性能基本保持不变。</p></li><li><p><strong>锁机制不一样。</strong>synchronized获得锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且自动解锁，而condition中的await()、signal()、signalAll()能够指定要释放的锁。不会因为异常而导致锁没有被释放从而引发死锁的问题。而Lock则需要开发人员手动释放，并且必须放在finally块中释放，否则会引起死锁问题。此外，Lock还提供了更强大的功能，他的tryLock()方法可以采用非阻塞的方式去获取锁。</p><p>虽然synchronized与Lock都可以实现多线程的同步，但是最好不要同时使用这两种同步机制给统一共享资源加锁（不起作用），因为ReentrantLock与synchronized所使用的机制不同，所以它们运行时独立的，相当于两个种类的锁，在使用的时候互不影响。</p></li></ul><p><strong>面试题</strong></p><ol><li>当一个线程进入一个对象的synchronized()方法后，其他线程是否能够进入此对象的其他方法？</li></ol><ul><li>其他线程可进入此对象的非synchronized修饰的方法。如果其他方法有synchronized修饰，都用的是同一对象锁，就不能访问。</li></ul><ol start="2"><li>如果其他方法是静态方法，且被synchronized修饰，是否可以访问？</li></ol><ul><li>可以的，因为static修饰的方法，它用的锁是当前类的字节码，而非静态方法使用的是this，因此可以调用。</li></ul><h3 id="十二、什么是线程守护"><a href="#十二、什么是线程守护" class="headerlink" title="十二、什么是线程守护"></a>十二、什么是线程守护</h3><p> Java提供了两种线程：<strong>守护线程和用户线程</strong>。守护线程又被称为“服务进程”、“精灵线程”、“后台线程”，是指在程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分，通俗点讲，每一个守护线程都是JVM中非守护线程的“保姆”。典型例子就是“垃圾回收器”。只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源。</p><p>用户线程和守护线程几乎一样，唯一的不同就在于如果用户线程已经全部退出运行，只剩下守护线程运行，JVM也就退出了因为当所有非守护线程结束时，没有了守护者，守护线程就没有工作可做，也就没有继续运行程序的必要了，程序也就终止了，同时会“杀死”所有的守护线程。也就是说，只要有任何非守护线程运行，程序就不会终止。</p><p>Java语言中，守护线程优先级都较低，它并非只有JVM内部提供，用户也可以自己设置守护线程，方法就是在调用线程的start()方法之前，设置setDaemon(true)方法，若将参数设置为false,则表示用户进程模式。需要注意的是，守护线程中产生的其它线程都是守护线程，用户线程也是如此。</p><p><strong>线程类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>守护线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public final void setDaemon(boolean on)：是否设置为守护进程。true：是；false：否</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemonTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ThreadDaemon td1 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>ThreadDaemon td2 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>td1.setName(<span class="hljs-string">&quot;A&quot;</span>);<br>td2.setName(<span class="hljs-string">&quot;B&quot;</span>);<br> <br><span class="hljs-comment">//添加守护线程</span><br>td1.setDaemon(<span class="hljs-keyword">true</span>);<br>td2.setDaemon(<span class="hljs-keyword">true</span>);<br><br>td1.start();<br>td2.start();<br><br>Thread.currentThread().setName(<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>A线程和B线程均设置为守护线程，C线程为用户进程。这三个线程均随机抢占CPU的使用权，当C抢占并且运行完毕之后，A和B这两个线程将在某一时间死亡，切记并不是立刻死亡，而是A线程执行完毕的一段时间后。</p><h3 id="十三、join方法作用"><a href="#十三、join方法作用" class="headerlink" title="十三、join方法作用"></a>十三、join方法作用</h3><p>在Java语言中，join()方法的作用是让调用该方法的线程在执行完run()方法后，再执行join方法后面的代码。简单点说就是将两个线程合并，并实现同步功能。具体而言，可以通过线程A的join()方法来等待线程A的结束，或者使用线程A的join(2000)方法来等待线程A的结束，但最多只等2s。示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Begin ThreadImp&quot;</span>);<br>       Thread.sleep(<span class="hljs-number">5000</span>);<br>       System.out.println(<span class="hljs-string">&quot;End ThreadImp&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadImp());<br>    t.start();<br>    <span class="hljs-keyword">try</span>&#123;<br>         t.join(<span class="hljs-number">1000</span>);<span class="hljs-comment">//主线程等待1s</span><br>         <span class="hljs-keyword">if</span>（t.isAlive())&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has not finished&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has finished&quot;</span>);<br>         &#125;<br>       System.out.println(<span class="hljs-string">&quot;joinFinish&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedExcetion e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426224744450.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记2 线程池学习</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程池"><a href="#一、线程池" class="headerlink" title="一、线程池"></a>一、线程池</h3><p>在java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。</p><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p><p>假设一个服务器完成一项任务所需时间为：T1创建线程池时间，T2在线程中执行任务的时间，T3销毁线程时间。</p><p>如果：T1+T3&gt;&gt;T2,则可以采用线程池，提高服务器性能。</p><h3 id="二、线程池的优势"><a href="#二、线程池的优势" class="headerlink" title="二、线程池的优势"></a>二、线程池的优势</h3><ul><li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限创建，不仅会损耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</li></ul><h3 id="三、线程池的使用"><a href="#三、线程池的使用" class="headerlink" title="三、线程池的使用"></a>三、线程池的使用</h3><p>线程池的真正实现类是<strong>ThreadPoolExecutor</strong>， 其构造方法有4种。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         threadFactory, defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), handler);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可看到，需要这几个参数：</p><ul><li><strong>corePoolSize</strong> (必需)：核心线程数。默认情况下，核心线程数会一直存货，但是当将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>maxmumPoolsize</strong> (必需)：线程池所能容纳的最大线程数。当活跃线程数到该数值后，后续的新任务将会阻塞。</li><li><strong>keepAliveTime</strong>(必需)：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。 如果将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>unit</strong> （必需）：指定keepAliveTime参数的时间单位。常用的有：<strong>TimeUnit.MILLISECONDS</strong> （毫秒）、<strong>TimeUnit.SECONDS</strong> （秒）、<strong>TimeUnit.MINUTES</strong> （分）</li><li><strong>Queue</strong> （必需）：任务队列。通过线程池的execute()方法提交的Runnable对象将存储在该参数中。其采用阻塞队列实现。</li><li><strong>threadFactory</strong> （可选）：线程工厂。用于指定为线程池创建新线程的方式。</li><li><strong>handler</strong> （可选）：拒绝策略。当达到最大线程数时需要执行的包和策略。</li></ul><p>线程池的使用流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br>ThreadPoolExecutor threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,<br>                                             MAXIMUM_POOL_SIZE,<br>                                             KEEP_ALIVE,<br>                                             TimeUnit.SECONDS,<br>                                             sPoolWorkQueue,<br>                                             sThreadFactory);<br><span class="hljs-comment">// 向线程池提交任务</span><br>threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        ... <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 关闭线程池</span><br>threadPool.shutdown(); <span class="hljs-comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span><br>threadPool.shutdownNow(); <span class="hljs-comment">// 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span><br></code></pre></td></tr></table></figure><h3 id="三、线程池的工作原理"><a href="#三、线程池的工作原理" class="headerlink" title="三、线程池的工作原理"></a>三、线程池的工作原理</h3><p>工作流程图：</p><p><img src="https://img-blog.csdnimg.cn/20210426193522921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="四、线程池的参数"><a href="#四、线程池的参数" class="headerlink" title="四、线程池的参数"></a>四、线程池的参数</h3><h4 id="1-任务队列（workqueue）"><a href="#1-任务队列（workqueue）" class="headerlink" title="1.任务队列（workqueue）"></a>1.任务队列（workqueue）</h4><p><img src="https://img-blog.csdnimg.cn/20210426202610254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在java中需要实现<strong>BlockingQueue</strong> 接口。但java已经提供了7种阻塞队列的实现：</p><ol><li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）</li><li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为<strong>Integer.MAX_VALUE</strong>。</li><li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排列的无界阻塞队列，对元素没有要求，可以实现<strong>Comparable</strong> 接口也可以提供Comparator来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</li><li><strong>DelayQueue</strong> ：类似于<strong>PriorityBlockingQueue</strong> ，是二叉堆实现的无界优先级阻塞队列。要求元素都实现<strong>Delayed</strong> 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</li><li><strong>SynchronousQueue</strong>： 一个不存储元素的阻塞队列，消费者线程调用take()方法的时候就会发送阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用put()方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</li><li><strong>LinkedBlockingDeque</strong>： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样FIFO（先进先出），也可以像栈一个FILO（先进后出）</li><li><strong>LinkedTransferQueue：</strong> 他是<strong>ConcurrentLinkedQueue</strong>、**LinkedBlockingQueue **和 **SynchronousQueue **的结合体，但是把它用在 ThreadPoolExecutor 中，和 **LinkedBlockingQueue **行为一致，但是是无界的阻塞队列。</li></ol><p><strong>注意有界队列和无界队列的区别：</strong> <em>如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</em> </p><h4 id="2-线程工厂（theadFactory）"><a href="#2-线程工厂（theadFactory）" class="headerlink" title="2.线程工厂（theadFactory）"></a>2.线程工厂（theadFactory）</h4><p>线程工厂指定创建线程的方式，需要实现 **ThreadFactory **接口，并实现 **newThread(Runnable r) **方法。该参数可以不用指定，Executors 框架已经为我们实现了一个默认的线程工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br> <br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                              Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                      poolNumber.getAndIncrement() +<br>                     <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                              namePrefix + threadNumber.getAndIncrement(),<br>                              <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-拒绝策略（handler）"><a href="#3-拒绝策略（handler）" class="headerlink" title="3.拒绝策略（handler）"></a>3.拒绝策略（handler）</h4><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现<strong>RejectedExecutionHanlder</strong>接口，并实现 **rejectedExecution(Runnabler, ThreadPoolExecutor executor) **方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p><ol><li><strong>AbortPolicy（默认）</strong>：丢弃任务并抛出 **RejectedExecutionException **异常。</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li><li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li></ol><h3 id="五、功能线程池"><a href="#五、功能线程池" class="headerlink" title="五、功能线程池"></a>五、功能线程池</h3><p>Executors已经为我们封装好了 4 种常见的功能线程池，如下：</p><ul><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool ）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ul><h4 id="1-定长线程池（FixedThreadPool）"><a href="#1-定长线程池（FixedThreadPool）" class="headerlink" title="1.定长线程池（FixedThreadPool）"></a>1.定长线程池（FixedThreadPool）</h4><p>创建方法源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 只有核心教程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 控制线程最大并发数。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3</span><br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>fixedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="2-定时线程池（ScheduledThreadPool）"><a href="#2-定时线程池（ScheduledThreadPool）" class="headerlink" title="2.定时线程池（ScheduledThreadPool）"></a>2.定时线程池（ScheduledThreadPool）</h4><p>创建方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="hljs-number">10L</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。</li><li><strong>应用场景</strong>： 执行定时或周期性的任务。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5</span><br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>scheduledThreadPool.schedule(task, <span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 延迟1s后执行任务</span><br>scheduledThreadPool.scheduleAtFixedRate(task,<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS);<span class="hljs-comment">// 延迟10ms后、每隔1000ms执行任务</span><br></code></pre></td></tr></table></figure><h4 id="3-可缓存线程池（CachedThreadPool）"><a href="#3-可缓存线程池（CachedThreadPool）" class="headerlink" title="3.可缓存线程池（CachedThreadPool）"></a>3.可缓存线程池（CachedThreadPool）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。</li><li><strong>应用场景</strong> ： 执行大量，耗时少的任务</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建可缓存线程池对象</span><br>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>cachedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-单线程化线程池（SingleThreadExecutor）"><a href="#5-单线程化线程池（SingleThreadExecutor）" class="headerlink" title="5.单线程化线程池（SingleThreadExecutor）"></a>5.单线程化线程池（SingleThreadExecutor）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong> ： 只有一个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 不合适并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建单线程化线程池</span><br>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>singleThreadExecutor.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-对比"><a href="#5-对比" class="headerlink" title="5.对比"></a>5.对比</h4><p><img src="https://img-blog.csdnimg.cn/20210426201526725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p> Executors 的 4 个功能线程有如下弊端：</p><ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：主要问题是堆积的请求处理队列均采用 <strong>LinkedBlockingQueue</strong>，可能会耗费非常大的内存，甚至 OOM。</li><li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><hr><p>学习文章：<a href="https://blog.csdn.net/u013541140/article/details/95225769">https://blog.csdn.net/u013541140/article/details/95225769</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记1 多线程学习</title>
    <link href="/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程和进程的区别"><a href="#一、线程和进程的区别" class="headerlink" title="一、线程和进程的区别"></a>一、线程和进程的区别</h3><p><strong>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。（进程是资源分配的最小单位）</strong></p><p><strong>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换开销小。（线程是cpu调度的最小单位）</strong></p><p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止</p><p>多线程指在同一个程序中有多个顺序流在执行，在操作系统能同时运行多个任务（程序）</p><ul><li>在java中要实现多线程有三种方式，Thread类，实现Runable接口，Callable接口</li></ul><h3 id="二、扩展java-lang-Thread类"><a href="#二、扩展java-lang-Thread类" class="headerlink" title="二、扩展java.lang.Thread类"></a>二、扩展java.lang.Thread类</h3><p>​    继承thread类的方法是常用的一种，如果说要起一条线程可以使用thread</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行  :  &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads mTh2=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;B&quot;</span>);<br>        mTh1.start();<br>        mTh2.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042517010912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>程序在启动运行main时，java虚拟机启动一个进程，主线程main在main()调用时被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</li><li>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</li><li>多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</li><li>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</li></ul><p><em>所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。但是start方法重复调用的话会出现<strong>java.lang.IllegalThreadStateException</strong>异常。</em></p><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>Threads mTh2=mTh1;<br>mTh1.start();<br>mTh2.start();<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425171539746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a>二、实现java.lang.Runnable接口</h3><p>只需将run方法重写就行</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads1</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;运行 : &quot;</span>+i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;C&quot;</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;D&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425172441669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>Threads1类通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个约定。所有多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</li><li>在启动多线程时，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码</li><li>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</li></ul><h3 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a>三、Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。</p><p><strong>实现Runnable接口比继承Thread类具有的优势：</strong></p><ul><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免java中的单继承限制</li><li>增加程序的健壮性、代码可以被多个线程共享，代码和数据独立</li><li>线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</li></ul><p>==注意：main方法也是一个线程，在java中所以的线程都是同时启动的，至于什么0候，哪个先执行，完全看谁先得到CPU的资源。==</p><p>==在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。==</p><h3 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h3><p><img src="https://img-blog.csdnimg.cn/20210425174938348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>新建状态：新创建一个线程对象</li><li>就绪状态：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</li><li>运行状态：就绪状态的线程获取了CPU，执行程序代码</li><li>阻塞状态：因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。<ul><li>阻塞状态三种情况<ul><li>等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待池中（wait会释放持有的锁）</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中</li><li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时，join等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li><li>死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul></li></ul><h3 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h3><h4 id="1-线程优先级"><a href="#1-线程优先级" class="headerlink" title="1.线程优先级"></a>1.线程优先级</h4><ul><li><p>java线程优先级高的会获得更多的运行机会</p></li><li><p>Java线程的优先级用整数表示，取值在1~10，Thread类有以下三个静态常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_PRIORITY <span class="hljs-comment">//线程可以具有的最高优先级，取值为10。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MIN_PRIORITY <span class="hljs-comment">//线程可以具有的最低优先级，取值为1。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NORM_PRIORITY <span class="hljs-comment">//分配给线程的默认优先级，取值为5。</span><br></code></pre></td></tr></table></figure><p><strong>用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread4 t1 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t1&quot;</span>);<br>Thread4 t2 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t2&quot;</span>);<br>t1.setPriority(Thread.MAX_PRIORITY);<br>t2.setPriority(Thread.MIN_PRIORITY);<br></code></pre></td></tr></table></figure></li><li><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有优先级，主线程优先级默认为Thread.NORM_PRIORITY。</p></li><li><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p></li></ul><h4 id="2-线程睡眠"><a href="#2-线程睡眠" class="headerlink" title="2.线程睡眠"></a>2.线程睡眠</h4><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><h4 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3.线程等待"></a>3.线程等待</h4><p> Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><h4 id="4-线程让步"><a href="#4-线程让步" class="headerlink" title="4.线程让步"></a>4.线程让步</h4><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><h4 id="5-线程加入"><a href="#5-线程加入" class="headerlink" title="5.线程加入"></a>5.线程加入</h4><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><h4 id="6-线程唤醒"><a href="#6-线程唤醒" class="headerlink" title="6.线程唤醒"></a>6.线程唤醒</h4><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><h3 id="六、常用函数"><a href="#六、常用函数" class="headerlink" title="六、常用函数"></a>六、常用函数</h3><ul><li><p><strong>sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</strong> sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p><p>leep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</p><p>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。</p></li><li><p><strong>join():指等待t线程终止。</strong></p><ul><li>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> AThread(); t.start(); t.join();<br></code></pre></td></tr></table></figure></li></ul><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p><strong>不加join情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426091527321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程比子线程结束早</p><p><strong>加上join方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            thread1.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            thread2.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Threads2.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426092435399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程会等待子线程结束之后在结束。</p><ul><li><p><strong>yield():暂停当前正在执行的线程对象，并执行其他线程</strong></p><p>Thread.yield()方法作用：暂停当前正在执行的线程对象，并执行其他线程。</p><p><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong> 所以，使用yield方法的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p><strong>yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果</strong> </p></li></ul><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadYield</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadYield</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">50</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">&quot;------&quot;</span>+i);<br>            <span class="hljs-comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">30</span>)&#123;<br>                <span class="hljs-keyword">this</span>.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadYield yield1 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;A&quot;</span>);<br>        ThreadYield yield2 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;B&quot;</span>);<br>        yield1.start();<br>        yield2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><ol><li><p>当A线程运行到30时，CPU让掉，这时A线程再次抢到CPU时间并执行</p><p><img src="https://img-blog.csdnimg.cn/20210426094258763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>当A线程运行到30时，CPU让掉，这时B线程抢到CPU时间并执行。</p></li></ol><h4 id="sleep-和yield-区别"><a href="#sleep-和yield-区别" class="headerlink" title="sleep()和yield()区别"></a>sleep()和yield()区别</h4><ol><li>sleep()使当前线程进入停滞状态, 所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</li><li>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</li><li>sleep 方法允许较低优先级的线程获得运行机会,但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</li></ol><ul><li><p>interrupt():不是中断某个线程， 只是线程发送一个中断信号，让线程 在无限等待时（如死锁）能够抛出，从而结束线程。</p></li><li><p>wait(): Obj.wait()与Obj.notify()必须要与synchronized一起使用，也就是针对已获取了Obj锁进行操作，从语法角度说必须放在synchronized(Obj){…}语句块内。</p><p>从功能上wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其他线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。</p><p>notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，不是马上就释放对象锁，而是在相应的synchronized(){}语句块执行结束后，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。</p><p>Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p><strong>案例：</strong></p><p><strong>建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。</strong> </p><p><strong>案例实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadText</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Object prev;<br>    <span class="hljs-keyword">private</span> Object self;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadText</span><span class="hljs-params">(String name,Object prev,Object self)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.self = self;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (prev)&#123;<br>                <span class="hljs-keyword">synchronized</span> (self)&#123;<br>                    System.out.println(name);<br>                    count -- ;<br>                    self.notify();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    prev.wait();<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Object a = <span class="hljs-keyword">new</span> Object();<br>        Object b = <span class="hljs-keyword">new</span> Object();<br>        Object c = <span class="hljs-keyword">new</span> Object();<br>        ThreadText pa = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;A&quot;</span>,c,a);<br>        ThreadText pb = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;B&quot;</span>,a,b);<br>        ThreadText pc = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;C&quot;</span>,b,c);<br><br>        <span class="hljs-keyword">new</span> Thread(pa).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pb).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pc).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021042610344056.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>案例分析</strong></p><p>该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。</p><p>为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。</p><p>可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p></li><li><p>wait()方法：wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</p><p>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</p></li></ul><h4 id="wait和sleep区别"><a href="#wait和sleep区别" class="headerlink" title="wait和sleep区别"></a>wait和sleep区别</h4><p><strong>相同点</strong></p><ol><li><p> 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。</p></li><li><p>wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。</p><p>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p><p>InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。</p></li></ol><p><strong>不同点</strong></p><ol><li><p>Thread类的方法：sleep(),yield()等。</p><p>Object类的方法：wait()和notify等。</p></li><li><p>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。</p><p>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p></li><li><p>wait，notify和notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用，<strong>所以sleep和wait最大的区别是：</strong></p><p><strong>sleep()睡眠时，保持对象锁，仍然占有该锁；</strong></p><p><strong>wait()睡眠时，释放对象锁</strong></p><p><strong>但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。</strong></p></li></ol><h3 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a>七、常见线程名词解释</h3><p>主线程：JVM调用程序main()所产生的线程</p><p>当前线程：一般指通过Thread.currentThread()来获取进程</p><p>后台进程：指为其他线程提供服务的线程，也成为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>前台线程：指接受后台线程服务的线程，其实前台后台线程是联系在一起，像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p><strong>线程类的一些常用方法：</strong> </p><p>　　<strong>sleep(): 强迫一个线程睡眠Ｎ毫秒。</strong> <br>　　<strong>isAlive(): 判断一个线程是否存活。</strong> <br>　　<strong>join(): 等待线程终止。</strong> <br>　　<strong>activeCount(): 程序中活跃的线程数。</strong> <br>　　<strong>enumerate(): 枚举程序中的线程。</strong> <br>    <strong>currentThread(): 得到当前线程。</strong> <br>　　<strong>isDaemon(): 一个线程是否为守护线程。</strong> <br>　　<strong>setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</strong> <br>　　<strong>setName(): 为线程设置一个名称。</strong> <br>　　<strong>wait(): 强迫一个线程等待。</strong> <br>　　<strong>notify(): 通知一个线程继续运行。</strong> <br>　　<strong>setPriority(): 设置一个线程的优先级。</strong></p><h3 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a>八、线程同步</h3><ul><li><strong>synchronized关键字的作用域有两种</strong> </li></ul><ol><li>是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</li><li>是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ol><ul><li><strong>除了除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</strong> 用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；</li><li><strong>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。</strong>继承类需要你显式的指定它的某个方法为synchronized方法；</li></ul><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>在进一步阐述之前，我们需要明确几点：</p><p>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>B．每个对象只有一个锁（lock）与之相关联。</p><p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><ol><li><p>把synchronized当作函数修饰符时，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>上边的示例代码等同于如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)  <span class="hljs-comment">//(1)&#123;</span><br>    <span class="hljs-comment">//..</span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p> (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱</p></li><li><p>同步块，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(SomeObject so)</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(so)&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] lock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>      <span class="hljs-comment">//..</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。==</p></li><li><p>将synchronized作用于static 函数，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodBB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Foo.class) <span class="hljs-comment">//class literal(类名称字面常量)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p></li></ol><p><strong>总结</strong></p><ol><li>线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</li><li>线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法</li><li>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</li><li>对于同步，要时刻清醒在哪个对象上同步，这是关键。</li><li>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</li><li>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</li><li>死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真但是，一旦程序发生死锁，程序将死掉。</li></ol><h3 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a>九、线程数据传递</h3><h4 id="1-通过构造方法传递数据"><a href="#1-通过构造方法传递数据" class="headerlink" title="1.通过构造方法传递数据"></a>1.通过构造方法传递数据</h4><p>在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用。下面的代码演示了如何通过构造方法来传递数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreads</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> MyThreads(<span class="hljs-string">&quot;word&quot;</span>);<br>    thread.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><h4 id="2-通过变量和方法传递数据"><a href="#2-通过变量和方法传递数据" class="headerlink" title="2.通过变量和方法传递数据"></a>2.通过变量和方法传递数据</h4><p>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads3 threads3 = <span class="hljs-keyword">new</span> Threads3();<br>        threads3.setName(<span class="hljs-string">&quot;world&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(threads3);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-通过回调函数传递数据"><a href="#3-通过回调函数传递数据" class="headerlink" title="3.通过回调函数传递数据"></a>3.通过回调函数传递数据</h4><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Data data,Integer ... num)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : num)&#123;<br>            data.value += n;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Work work;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads4</span><span class="hljs-params">(Work work)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.work = work;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        Data data = <span class="hljs-keyword">new</span> Data();<br>        <span class="hljs-keyword">int</span> n1 = random.nextInt(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">int</span> n2 = random.nextInt(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">int</span> n3 = random.nextInt(<span class="hljs-number">3000</span>);<br>        work.process(data,n1,n2,n3);<br>        System.out.println(String.valueOf(n1) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n2) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n3) + <span class="hljs-string">&quot;=&quot;</span> + data.value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Threads4(<span class="hljs-keyword">new</span> Work());<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>学习文章链接:<a href="http://blog.csdn.net/evankaka">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记10 事务与事务锁</title>
    <link href="/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/"/>
    <url>/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一、事务简介"><a href="#一、事务简介" class="headerlink" title="一、事务简介"></a>一、事务简介</h3><p>Redis执行命令过程中，多条连续执行的指令被干扰，打断，插队</p><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>redis事务就是一个命令执行的队列，将一系列预定命令包装成一个整体（一个队列）。当执行时，按照添加顺序依次执行，中间不会被打断或者干扰。</p><p>一个队列中，一次性，顺序性，排他性的执行一系列命令</p><h3 id="二、事务的基本操作"><a href="#二、事务的基本操作" class="headerlink" title="二、事务的基本操作"></a>二、事务的基本操作</h3><ul><li><p>开启事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multi<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li><p>执行事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</li></ul></li></ul><p><em>注意：</em> <strong>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行。</strong></p><ul><li><p>取消事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">discard<br></code></pre></td></tr></table></figure><ul><li>作用：终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul><h3 id="三、事物的工作流程"><a href="#三、事物的工作流程" class="headerlink" title="三、事物的工作流程"></a>三、事物的工作流程</h3><ul><li><p>未开启事务前的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423145755640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>创建事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150112123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150227995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的del指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150354629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>关闭事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150515144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>取消事务</p><p><img src="https://img-blog.csdnimg.cn/2021042315064864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="四、事物的注意事项"><a href="#四、事物的注意事项" class="headerlink" title="四、事物的注意事项"></a>四、事物的注意事项</h3><h4 id="定义事务的过程中，命令格式输入错误怎么办？"><a href="#定义事务的过程中，命令格式输入错误怎么办？" class="headerlink" title="定义事务的过程中，命令格式输入错误怎么办？"></a>定义事务的过程中，命令格式输入错误怎么办？</h4><ul><li><p>语法错误</p><p>指命令书写格式有误</p></li><li><p>处理结果</p><p>如果定义的事务中所包含的命令存在语法错误，整体事务中所以命令均不会执行。包括那些语法正确的命令。</p></li></ul><h4 id="定义事务的过程中，命令执行出现错误怎么办？"><a href="#定义事务的过程中，命令执行出现错误怎么办？" class="headerlink" title="定义事务的过程中，命令执行出现错误怎么办？"></a>定义事务的过程中，命令执行出现错误怎么办？</h4><ul><li><p>运行错误</p><p>指命令格式正确，但是无法正确的执行，列如对list进行incr操作</p></li><li><p>处理结果</p><p>能够正确运行的命令会执行，运行错误的命令不会执行</p></li></ul><p><em>注意：</em> <strong>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</strong></p><h4 id="手动进行事务回滚"><a href="#手动进行事务回滚" class="headerlink" title="手动进行事务回滚"></a>手动进行事务回滚</h4><ul><li>记录操作过程中被影响的数据之前的状态<ul><li>单数据：string</li><li>多数据：hash、list、set、zset</li></ul></li><li>设置指令恢复所有的被修改的项<ul><li>单数据：直接set（注意周边属性，列如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ul></li></ul><h3 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h3><h4 id="基于特定条件的事务执行——锁"><a href="#基于特定条件的事务执行——锁" class="headerlink" title="基于特定条件的事务执行——锁"></a>基于特定条件的事务执行——锁</h4><p><strong>业务场景1</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423160652713.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操纵修改后，将不适用于继续操作</li><li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li></ul><p><strong>解决方案</strong></p><ul><li><p>对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch key1 [key2...]<br></code></pre></td></tr></table></figure></li><li><p>取消对所有key的监视</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unwatch<br></code></pre></td></tr></table></figure></li><li><p>redis应用基于状态控制的批量任务执行</p></li></ul><h4 id="基于特定条件的事务执行——分布式锁"><a href="#基于特定条件的事务执行——分布式锁" class="headerlink" title="基于特定条件的事务执行——分布式锁"></a>基于特定条件的事务执行——分布式锁</h4><p><strong>业务场景2</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423161241863.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li><li>虽然redis是单线程的，但是多个客户端对同一个数据同时操作时，如何避免不被同时修改？</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用setnx设置一个公共锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p><ul><li>对于返回设置成功时，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul></li><li><p>操作完毕通过del操作释放锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del lock-key<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em> ： 上述解决方案是一种设计概念，依赖规范保障，具有风险性</p><ul><li>redis应有基于分布式对应的场景控制</li></ul><h4 id="基于特定条件的事务执行——分布式锁改良"><a href="#基于特定条件的事务执行——分布式锁改良" class="headerlink" title="基于特定条件的事务执行——分布式锁改良"></a>基于特定条件的事务执行——分布式锁改良</h4><p><strong>业务场景</strong></p><p>依赖分布式锁的机制，某个用户操作时对应客户机宕机，并且此时已经获取到锁，如何解决？</p><p><strong>业务分析</strong></p><ul><li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</li><li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用expire为锁key添加时间限定，到时不释放，放弃锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire lock-key second<br>pexpire lock-key millseconds<br></code></pre></td></tr></table></figure><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms</li><li>测试百万次最长执行时间对应命令的最大消耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时* 120%+平均网络延迟*110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记9 Redis持久化之AOF</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、AOF概念"><a href="#一、AOF概念" class="headerlink" title="一、AOF概念"></a>一、AOF概念</h3><ul><li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令，达到恢复数据的目的。与RDB相比可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></li><li>AOF的主要作用时解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li></ul><h3 id="二、AOF写数据过程"><a href="#二、AOF写数据过程" class="headerlink" title="二、AOF写数据过程"></a>二、AOF写数据过程</h3><p><img src="https://img-blog.csdnimg.cn/20210422194954247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="三、AOF写数据三种策略（appendfsync）"><a href="#三、AOF写数据三种策略（appendfsync）" class="headerlink" title="三、AOF写数据三种策略（appendfsync）"></a>三、AOF写数据三种策略（appendfsync）</h3><ul><li><p>always（每次）</p><p>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong></p></li><li><p>everysec（每秒）</p><p>每次将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，在系统突然宕机的情况下丢失1秒内的数据（建议使用，也是默认配置）</p></li><li><p>no（系统控制）</p><p>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></p><p>​</p></li></ul><h3 id="四、AOF功能开启"><a href="#四、AOF功能开启" class="headerlink" title="四、AOF功能开启"></a>四、AOF功能开启</h3><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly yes|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>是否开启AOF持久化功能，默认为不开启状态</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfsync always|everysec|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF写数据策略</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfilename filename<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dir<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li></ul><h3 id="五、AOF写数据遇到的问题"><a href="#五、AOF写数据遇到的问题" class="headerlink" title="五、AOF写数据遇到的问题"></a>五、AOF写数据遇到的问题</h3><p><strong>如果连续执行如下指令该如何处理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042220280729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p>AOF重写</p><h3 id="六、AOF重写"><a href="#六、AOF重写" class="headerlink" title="六、AOF重写"></a>六、AOF重写</h3><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是<strong>将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。</strong></p><h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令，如del key1、hdel key2、srem key3、set key4 123、set key4 222等</p></li><li><p>对同一数据的多条写命令合并为一条命令，如lpush list1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c。</p><p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型、每条指令最多写入64个元素</p></li></ul><h4 id="AOF重写方式（手动重写）"><a href="#AOF重写方式（手动重写）" class="headerlink" title="AOF重写方式（手动重写）"></a>AOF重写方式（手动重写）</h4><ul><li><p>手动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgrewriteaof<br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li></ul><h4 id="AOF手动重写——bgrewriteaof指令工作原理"><a href="#AOF手动重写——bgrewriteaof指令工作原理" class="headerlink" title="AOF手动重写——bgrewriteaof指令工作原理"></a>AOF手动重写——bgrewriteaof指令工作原理</h4><p><img src="https://img-blog.csdnimg.cn/20210422204256378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写方式（自动重写）"><a href="#AOF重写方式（自动重写）" class="headerlink" title="AOF重写方式（自动重写）"></a>AOF重写方式（自动重写）</h4><ul><li><p>自动重写触发条件格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percent<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发对比参数（运行指令info Persistence获取具体信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">aof_current_size<br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="https://img-blog.csdnimg.cn/20210422205637212.png" alt="img"></p><h4 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210052662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210223933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210422210336449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>AOF缓冲区同步文件策略，由参数appendfsync控制</li></ul><p><strong>系统调用write和fsync说明：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422210709540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="七、RDB与AOF区别"><a href="#七、RDB与AOF区别" class="headerlink" title="七、RDB与AOF区别"></a>七、RDB与AOF区别</h3><p><img src="https://img-blog.csdnimg.cn/20210422210809864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB与AOF选择之惑</strong></p><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用erverysecond，每秒钟fsync一次。该策略redis任然可以保持很好的处理性能，当出现问题时，最多丢失0-1秒中的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复数据较慢</li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人工手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降得很低</li></ul></li><li>综合对比<ol><li>RDB与AOF得选择实际上是在做一种权衡，每种都有利弊</li><li>如不能承受数分钟以内得数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内数据丢失，且追求大数据集得恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量</li></ol></li></ul><p><strong>持久化应用场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422211202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记8 Redis持久化之RDB</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、持久化简介"><a href="#一、持久化简介" class="headerlink" title="一、持久化简介"></a>一、持久化简介</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1.什么是持久化"></a>1.什么是持久化</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><h3 id="2-为什么要进行持久化"><a href="#2-为什么要进行持久化" class="headerlink" title="2.为什么要进行持久化"></a>2.为什么要进行持久化</h3><p>防止数据的意外丢失，确保数据安全性</p><h3 id="3-持久化过程保存什么"><a href="#3-持久化过程保存什么" class="headerlink" title="3.持久化过程保存什么"></a>3.持久化过程保存什么</h3><ul><li><p>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。</p></li><li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。</p><p><img src="https://img-blog.csdnimg.cn/2021042215521812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><h2 id="二、RDB"><a href="#二、RDB" class="headerlink" title="二、RDB"></a>二、RDB</h2><h3 id="1-RDB启动方式（手动执行）"><a href="#1-RDB启动方式（手动执行）" class="headerlink" title="1.RDB启动方式（手动执行）"></a>1.RDB启动方式（手动执行）</h3><p><strong>命令执行</strong></p><ul><li>谁：redis操作者（用户）</li><li>什么时间：即使（随时进行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save指令</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><p><strong>RDB启动方式——save指令相关配置</strong></p><ul><li><p>dbfilename dump.rdb</p><p>说明 : 设置本地数据库文件名，默认值为dump.rdb</p><p>经验 : 通常设置为<strong>dump-端口号.rdb</strong></p></li><li><p>dir</p><p>说明 : 设置存储.rdb文件路径</p><p>经验 : 通常设置成存储空间较大的目录 , 目录名称为data</p></li><li><p>rdbcompression yes</p><p>说明 : 设置存储至本地数据库时是否压缩数据 , 默认为yes , 采用LZF压缩</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节省CPU运行时间 , 但会使存储的文件变大(巨大)</p></li><li><p>rdbchecksum yes</p><p>说明 : 设置是否进行RDB文件格式校验 , 该校验过程在写文件个读文件过程均进行</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节约读写性过程约10%时间消耗 , 但是存储一定的数据损坏风险</p></li></ul><p><strong>RDB启动方式——save指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422160844486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> <strong>Redis是单线程的</strong>，所有命令都会在类似队列中排好队，不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成位置，有可能会造成长时间阻塞，<strong>线上环境不建议使用</strong></p><h3 id="2-RDB启动方式（后台执行）"><a href="#2-RDB启动方式（后台执行）" class="headerlink" title="2.RDB启动方式（后台执行）"></a>2.RDB启动方式（后台执行）</h3><p><strong>后台执行</strong></p><ul><li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li><li>什么时间：即使（发起）；合理时间（执行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——bgsave</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgsave<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但不是立即执行</p></li></ul><p><strong>RDB启动方式——bgsave指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422161702164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em>bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><p><strong>RDB启动方式——bgsave指令相关配置</strong></p><ul><li><p>stop-writes-on-bgsave-error yes</p><p>说明：后台存储过程中如果出现错误现象，是否停止保存操作</p><p>经验：默认为开启</p></li></ul><h3 id="3-RDB启动方式（自动执行）"><a href="#3-RDB启动方式（自动执行）" class="headerlink" title="3.RDB启动方式（自动执行）"></a>3.RDB启动方式（自动执行）</h3><p><strong>自动执行</strong></p><ul><li>谁：redis服务器发起指令（基于条件）</li><li>什么时间：满足条件</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save配置</strong></p><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save second changes<br></code></pre></td></tr></table></figure></li><li><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数</p><p>second：监控时间范围</p><p>changes：监控key的变化量</p></li><li><p>位置</p><p>conf文件中配置</p></li><li><p>范例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure></li></ul><p><strong>RDB启动方式——save配置原理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042216312487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> </p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li>save配置启动后执行的是bgsave操作</li></ul><p><strong>RDB三种启动方式对比</strong></p><ul><li>save配置启动后由于执行的还是bgsave操作所以不在进行对比。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210422163458239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB特殊启动方式</strong></p><ul><li><p>全量复制</p><p>在主从复制中详细介绍</p></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debug reload<br></code></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown<br></code></pre></td></tr></table></figure><ul><li>默认情况下执行shutdown命令时，自动执行bgsave（如果没有开启AOF持久化功能）</li></ul></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个<strong>时间点</strong>的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务器之间数据格式无法兼容现象</li></ul><h3 id="RDB存储的弊端"><a href="#RDB存储的弊端" class="headerlink" title="RDB存储的弊端"></a>RDB存储的弊端</h3><ul><li>存储数据量大，效率较低<ul><li>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li></ul></li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><p><strong>解决思路</strong></p><ul><li>不写全数据，仅记录部分数据</li><li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li><li>对所有操作均进行记录，排除丢失数据的风险</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记7 Jedis连接并操作Redis</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Jedis简介"><a href="#一、Jedis简介" class="headerlink" title="一、Jedis简介"></a>一、Jedis简介</h3><p><strong>编程语言与redis</strong></p><ul><li><p>Java语言连接redis服务</p><p>Jedis</p><p>SpringData Redis</p><p>Lettuce</p><p>​</p></li></ul><h3 id="二、Jedis操作Redis"><a href="#二、Jedis操作Redis" class="headerlink" title="二、Jedis操作Redis"></a>二、Jedis操作Redis</h3><p><strong>准备工作</strong></p><ul><li><p>基于maven导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>连接redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>)<br></code></pre></td></tr></table></figure></li><li><p>操作redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>关闭redis连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure></li><li><p>API文档</p><p><a href="https://xetorthio.github.io/jedis/">https://xetorthio.github.io/jedis/</a></p></li></ul><h4 id="Jedis简易工具类开发"><a href="#Jedis简易工具类开发" class="headerlink" title="Jedis简易工具类开发"></a>Jedis简易工具类开发</h4><p><strong>基于连接池获取数据</strong></p><ul><li><p>JedisPool：Jedis提供的连接池技术</p><p>​    poolConfig：连接池配置对象</p><p>​    host：redis服务地址</p><p>​    port：redis服务端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JedisPool</span> <span class="hljs-params">(GenericObjectPoolConfig poolConfig, String host, <span class="hljs-keyword">int</span> port)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>(poolConfig, host, port, <span class="hljs-number">2000</span>, (String)<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, (String)<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>封装连接参数</strong></p><ul><li><p>jedis.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jedis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">jedis.prot</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">jedis.maxTotal</span>=<span class="hljs-string">30</span><br><span class="hljs-meta">jedis.maxIdle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>加载配置信息</strong></p><ul><li><p>静态代码块初始化资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<br>    <span class="hljs-keyword">static</span> &#123;<br>        JedisPoolConfig jpc=<span class="hljs-keyword">new</span> JedisPoolConfig();<br>        ResourceBundle rb=ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br>        host=rb.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        port=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        maxTotal=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br>        maxIdle=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br>        jpc.setMaxTotal(maxTotal);<br>        jpc.setMaxIdle(maxIdle);<br>        jp=<span class="hljs-keyword">new</span> JedisPool(jpc,host,port);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>对外访问外接口，提供jedis连接对象，连接从连接池获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> jp.getResource();<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="三、Jedis读写redis数据"><a href="#三、Jedis读写redis数据" class="headerlink" title="三、Jedis读写redis数据"></a>三、Jedis读写redis数据</h3><p><strong>案例实现</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101849577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>需求分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101957835.png" alt="img"></p><p><strong>实现步骤</strong></p><ul><li><p>1.设定业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">(String id, <span class="hljs-keyword">long</span> num)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;业务发起调用&quot;</span>,<span class="hljs-string">&quot;当前第&quot;</span>+num+<span class="hljs-string">&quot;次&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2.设定多线类，模拟用户调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(ture)&#123;<br>    jd.service(id);<br>    <span class="hljs-comment">//模拟调用间隔，设定为1.x秒</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Random r = <span class="hljs-keyword">new</span> Random();<br>      Thread.sleep(<span class="hljs-number">1000</span>+r.nextInt(<span class="hljs-number">200</span>));<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3.设计redis控制方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(String id)</span></span>&#123;<br>  Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>  String value = jedis.get(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>  <span class="hljs-comment">//判定是否具有调用计数控制，利用异常进行控制处理</span><br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-keyword">null</span>)&#123;<br>    jedis.setex(<span class="hljs-string">&quot;compid:&quot;</span>+id,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;&quot;</span>+(Long.MAX_VALUE-<span class="hljs-number">10</span>));<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//有控制，自增，并调用业务</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Long val = redis.incr(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>      business(id,<span class="hljs-number">10</span>+val-Long.MAX_VALUE);<br>    &#125;<span class="hljs-keyword">catch</span>(JedisDataExpection e)&#123;<br>      System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;使用次数到达上线&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      jedis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设计启动主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[],args)</span></span>&#123;<br>  MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;初级用户&quot;</span>);<br>  t1.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记6 key和数据库通用指令</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、key通用操作"><a href="#一、key通用操作" class="headerlink" title="一、key通用操作"></a>一、key通用操作</h2><h3 id="1-key特征"><a href="#1-key特征" class="headerlink" title="1.key特征"></a>1.key特征</h3><ul><li>key是一个字符串，通过key获取redis中保存的数据</li></ul><h3 id="2-key设计的操作"><a href="#2-key设计的操作" class="headerlink" title="2.key设计的操作"></a>2.key设计的操作</h3><ul><li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li><li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li><li>对于key快速查询操作，例如：按指定策略查询key</li></ul><h3 id="3-key基本操作"><a href="#3-key基本操作" class="headerlink" title="3.key基本操作"></a>3.key基本操作</h3><ul><li><p>删除指定key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>获取key是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exists key<br></code></pre></td></tr></table></figure></li><li><p>获取key的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">type key<br></code></pre></td></tr></table></figure><p><strong>key扩展操作（时效性控制）</strong></p></li><li><p>为指定key设置有效期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire key seconds     #设置秒<br>pexpire key milliseconds #设置毫秒<br>expireat key timestamp   #秒时间戳<br>pexpireat key milliseconds-timestamp  #毫秒时间戳<br></code></pre></td></tr></table></figure></li><li><p>获取key的有效时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ttl key<br>pttl key<br></code></pre></td></tr></table></figure><ul><li>ttl命令下，如果返回值为-2则是key不存在；如果返回值是-1，则是key存在且没有设置有效期；如果key设置有效期，则返回当前剩余的有效时常。</li></ul></li><li><p>切换key从时效性到永久性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">persist key  <br></code></pre></td></tr></table></figure><p><strong>key扩展操作（查询模式）</strong></p></li><li><p>查询key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys pattern<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421210222191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="4-key其他操作"><a href="#4-key其他操作" class="headerlink" title="4.key其他操作"></a>4.key其他操作</h3><ul><li><p>为key改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rename key newkey<br>renamenx key newkey  #如果key不存在，就改名<br></code></pre></td></tr></table></figure></li><li><p>对所有key排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort<br></code></pre></td></tr></table></figure></li><li><p>其他key通用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help @generic<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、数据库通用操作"><a href="#二、数据库通用操作" class="headerlink" title="二、数据库通用操作"></a>二、数据库通用操作</h2><p><strong>key的重复问题</strong></p><ul><li>key是由程序员定义的</li><li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li><li>数据不区分种类，类别混杂在一起，极易出现重复或冲突</li></ul><p><strong>解决方案</strong></p><ul><li>redis为每个服务器提供有16个数据库，编号从0-15</li><li>每个数据库之间的数据互相独立</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421210716812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="1-db基本操作"><a href="#1-db基本操作" class="headerlink" title="1.db基本操作"></a>1.db基本操作</h3><ul><li><p>切换数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select index<br></code></pre></td></tr></table></figure></li><li><p>其他操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">quit<br>ping<br>echo message<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-db相关操作"><a href="#2-db相关操作" class="headerlink" title="2.db相关操作"></a>2.db相关操作</h3><ul><li><p>数据移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">move key db<br></code></pre></td></tr></table></figure></li><li><p>数据清除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">dbsize   #查看当前库中key的总数量<br>flushdb  #清除当前库中所有的key<br>flushall #清除所有库中的key<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记5 sorted_set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="sorted-set类型"><a href="#sorted-set类型" class="headerlink" title="sorted_set类型"></a>sorted_set类型</h2><ul><li>新的存储需求：数据排序有利于数据的有效显示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要的存储结构：新的存储模型，可以保存可排序的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421164359468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="sorted-set类型数据的基本操作"><a href="#sorted-set类型数据的基本操作" class="headerlink" title="sorted_set类型数据的基本操作"></a>sorted_set类型数据的基本操作</h2><ul><li><p>添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd key score1 member1 [score2 member2]<br><br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrange key start stop [WITHSCORES]<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrem key member [member1 ...]<br></code></pre></td></tr></table></figure></li><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrangebyscore key min max [WITHSCORES] [LIMIT]<br>zrevrangebyscore key max min [WITHSCORES] #逆排序<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421165618285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zremrangebyrank key start stop   #按索引删除<br>zremrangebyscore key min max<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em>：</p><ul><li><em>min与max用于限定搜索查询的条件</em></li><li><em>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</em></li><li><em>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</em></li></ul><p>​    </p><ul><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">zcard key<br>zcount key min max<br><br></code></pre></td></tr></table></figure></li><li><p>集合交、并操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zinterstore destination numkeys key [key ...]<br>zunionstore destination numkeys key [key ...]<br></code></pre></td></tr></table></figure></li></ul><h2 id="sorted-set类型数据的扩展操作"><a href="#sorted-set类型数据的扩展操作" class="headerlink" title="sorted_set类型数据的扩展操作"></a>sorted_set类型数据的扩展操作</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171218699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>获取数据对应的索引（排名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrank key member<br>zrevrank key member<br></code></pre></td></tr></table></figure></li><li><p>score 值获取与修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zscore key member<br>zincrby key increment member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421171509850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于计数器组合排序功能对应的排名</p></li></ul><h2 id="sorted-set类型数据操作的注意事项"><a href="#sorted-set类型数据操作的注意事项" class="headerlink" title="sorted_set类型数据操作的注意事项"></a>sorted_set类型数据操作的注意事项</h2><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时侯要慎重</li><li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171846808.png" alt="img"></p><p> <strong>解决方案</strong></p><ul><li><p>对于基于时间线限定的任务处理，将处理时间记录位score值，利用排序功能区分处理的先后顺序</p></li><li><p>记录下一个要处理的事件，当到期后处理对应的任务，移除redis中的记录，并记录下一个要处理的时间</p></li><li><p>当新任务加入时，判定并更新当前下一个要处理的任务时间</p></li><li><p>为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set.例如1小时内，1天内，年度等，操作时逐渐提升，将即将操作的若干个任务纳入到1小时内处理队列中</p></li><li><p>获取当前系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">time<br></code></pre></td></tr></table></figure><ul><li>redis应用于定时任务顺序管理或任务过期管理</li></ul></li></ul><p><strong>业务场景（任务/消息权重设定应用）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421172226972.png" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042117234594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><p>带有权重的任务，优先处理权重高的任务，采用score记录权重即可</p><p><img src="https://img-blog.csdnimg.cn/20210421172537332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记4 Set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p><p><img src="https://img-blog.csdnimg.cn/20210421154631120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2021042115482653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h2 id="set类型数据的基本操作"><a href="#set类型数据的基本操作" class="headerlink" title="set类型数据的基本操作"></a>set类型数据的基本操作</h2><ul><li><p>添加书籍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smembers key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srem key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scard key<br></code></pre></td></tr></table></figure></li><li><p> 判断集合中是否包含指定数据</p></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sismember key member<br></code></pre></td></tr></table></figure><h2 id="set类型数据的扩展操作1"><a href="#set类型数据的扩展操作1" class="headerlink" title="set类型数据的扩展操作1"></a>set类型数据的扩展操作1</h2><p><strong>业务操作</strong></p><p>每位用户首次使用进入头条时候会设置3项爱好的内容，但是后期为了增加用户的活跃度，兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？</p><p><strong>业务分析</strong></p><ul><li>系统分析出各个分类的最新或最热点信息条目并组织成set集合</li><li>随机挑选其中部分信息</li><li>配合用户关注信息分类中的热点信息组织展示的全信息集合</li></ul><p><strong>解决方案</strong></p><ul><li><p>随机获取集合中指定数量的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srandmember key [count]<br></code></pre></td></tr></table></figure></li><li><p>随机获取集合中的某个数据并将该数据移除集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">spop key<br></code></pre></td></tr></table></figure></li><li><p>redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等</p></li></ul><h2 id="set类型数据的扩展操作2"><a href="#set类型数据的扩展操作2" class="headerlink" title="set类型数据的扩展操作2"></a>set类型数据的扩展操作2</h2><ul><li><p>求两个集合的交、并、差集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinter key [key2]<br></code></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinterstore destination key1 [key2]<br>sunionstore destination key1 [key2]<br>sdiffstore destination key1 [key2]<br><br></code></pre></td></tr></table></figure></li><li><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smove source destination member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421162116514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</p></li><li><p>显示共同关注（一度）</p></li><li><p>显示共同好友（一度）</p></li><li><p>由用户A出发，获取到好友用户B的好友信息列表（一度）</p></li><li><p>由用户A出发，获取到好友用户B的购物清单列表（二度）</p></li><li><p>由用户A出发，获取到好友用户B的游戏充值列表（二度）</p></li></ul><h2 id="set类型数据操作的注意事项"><a href="#set类型数据操作的注意事项" class="headerlink" title="set类型数据操作的注意事项"></a>set类型数据操作的注意事项</h2><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421162650651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>依赖set集合数据不重复的特征，依赖set集合hash存储结构特征完成数据过滤与快速查询</li><li>根据用户id获取用户所有角色</li><li>根据用户所有角色获取用户所有操作权限放入set集合</li><li>根据用户所有觉得获取用户所有数据全选放入set集合</li></ul><p><strong>校验工作</strong>：</p><p>​    redis提供基础数据还是提供校验结果</p><ul><li>redis应用于同类型不重复数据的合并操作</li></ul><h2 id="set类型应用场景"><a href="#set类型应用场景" class="headerlink" title="set类型应用场景"></a>set类型应用场景</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163055810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>利用set集合的数据去重特征，记录各种访问数据</li><li>建立string类型数据，利用incr统计日访问量（PV)</li><li>建立set模型，记录不同cookie数量（UV)</li><li>建立set模型，记录不用IP数量（IP)</li></ul><p><strong>业务场景（黑白名单）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163311178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>基于经营战略设定问题用户发现、鉴别规则</p></li><li><p>周期性更行满足规则的用户黑名单，加入set集合</p></li><li><p>用户行为信息达到后与黑名单进行比比对，确认行为去向</p></li><li><p>黑名单过滤IP地址：应用于开放游客访问权限的信息源</p></li><li><p>黑名单过滤设备信息：应用于限定访问设备的信息源</p></li><li><p>黑名单过滤用户：应用于基于访问权限的信息源</p></li><li><p>redis应用于基于黑名单与白名单设定的服务控制</p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记3 List数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用双向链表存储结构实现</p><p><img src="https://img-blog.csdnimg.cn/20210421145318123.png" alt="img"></p></li></ul><h2 id="list类型数据基本操作"><a href="#list类型数据基本操作" class="headerlink" title="list类型数据基本操作"></a>list类型数据基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush key value [value2]...   #在key对应的list头部添加元素<br>rpush key value [value2]...   #在key对应的list尾部添加元素<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrange key start stop    <br>lindex key index<br>llen key<br><br></code></pre></td></tr></table></figure></li><li><p>获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpop key                      #在key对应的list头部删除元素<br>rpop key                      #在key对应的list尾部删除元素<br></code></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">blpop key1 [key2] timeout<br>brpop key1 [key2] timeout<br></code></pre></td></tr></table></figure><p>阻塞式获取，获取值如果还没有的时候等待，如果有值就获取。</p></li></ul><h2 id="list类型数据扩展操作"><a href="#list类型数据扩展操作" class="headerlink" title="list类型数据扩展操作"></a>list类型数据扩展操作</h2><p><strong>业务场景</strong></p><p>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息</p><p><img src="https://img-blog.csdnimg.cn/20210421151850933.png" alt="img"></p><p><strong>解决方案</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrem key count value<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421152228925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>redis 应用于具有操作先后顺序的数据控制</li></ul><h2 id="list类型数据操作注意事项"><a href="#list类型数据操作注意事项" class="headerlink" title="list类型数据操作注意事项"></a>list类型数据操作注意事项</h2><ul><li>list保存的数据都是string类型，数据总容量有限，最多2[^32]-1个元素。</li><li>list具有索引概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第二页及更多的信息通过数据库的形式加载</li></ul><h2 id="list类型应用场景"><a href="#list类型应用场景" class="headerlink" title="list类型应用场景"></a>list类型应用场景</h2><p><strong>业务场景</strong></p><ol><li>twitter、新浪微博、腾讯微博中个人用于的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的事件顺序展示</li><li>企业运营过程中，系统将产生出大量的运营数据，如何保障堕胎服务器操作日志的统一顺序输出？</li></ol><p><strong>解决方案</strong></p><ul><li>依赖list的数据具有顺序的特征对信息进行管理</li><li>使用队列模型解决多路信息汇总合并的问题</li><li>使用栈模型解决最新消息的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记2 Hash数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、hash类型"><a href="#一、hash类型" class="headerlink" title="一、hash类型"></a>一、hash类型</h2><ul><li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息。</p></li><li><p>需要的存储结构：一个存储空间保存多个键值对数据</p></li><li><p>hash类型：底层使用哈希表结构实现数据存储。</p><p><img src="https://img-blog.csdnimg.cn/20210413221436565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><strong>hash存储结构优化</strong></p><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul><h2 id="二、hash类型数据的基本操作"><a href="#二、hash类型数据的基本操作" class="headerlink" title="二、hash类型数据的基本操作"></a>二、hash类型数据的基本操作</h2><ul><li>添加/修改数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset key field value<br></code></pre></td></tr></table></figure></li><li>获取数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hget key field<br>hgetall key<br></code></pre></td></tr></table></figure></li><li>删除数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdel key field1 [field2]<br></code></pre></td></tr></table></figure></li><li>获取哈希表中是否存在指定的字段<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexists key field<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、hash类型数据拓展操作"><a href="#三、hash类型数据拓展操作" class="headerlink" title="三、hash类型数据拓展操作"></a>三、hash类型数据拓展操作</h2><ul><li>获取哈希表中所有的字段名或字段值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hkeys key<br></code></pre></td></tr></table></figure></li><li>设定指定字段的数值数据增加指定范围的值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby key field increment<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、hash类型数据操作的注意事项"><a href="#四、hash类型数据操作的注意事项" class="headerlink" title="四、hash类型数据操作的注意事项"></a>四、hash类型数据操作的注意事项</h2><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li><li>每个hash可以存储2的32次方-1个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，不可滥用，不能将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈。</li></ul><h2 id="五、hash类型的应用场景"><a href="#五、hash类型的应用场景" class="headerlink" title="五、hash类型的应用场景"></a>五、hash类型的应用场景</h2><p><strong>业务场景1</strong></p><p>电商网站购物车的实现</p><p><img src="https://img-blog.csdnimg.cn/20210414104649492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>业务分析</strong></p><ul><li>仅分析购物车的redis存储模型（添加、浏览、更改数量、删除、清空</li><li>购物车与数据库间持久化同步</li><li>购物车与订单间关系（提交购物车：读取数据生成订单 商家临时价格调整：隶属于订单级别）</li><li>未登录用户购物车信息存储（cookie存储）</li></ul><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414110019950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210414110917809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>当前设计是否加速了购物车的呈现</strong><br>当前仅仅是将数据存储到reids中，并没有起到加速的作用，商品还需要二次查询数据库</p><ul><li>每条购物车中的商品记录保存成两条field</li><li>field1专用于保存购买数量<br> 命名格式：商品id：nums<pre><code> 保存数据：数值</code></pre></li><li>field2专用于保存购物车中的显示信息，包含文字描述，图片地址，所属商家信息等<br>命名格式：商品id：info<br>保存数据：json</li></ul><p><strong>我们可以把field2作为独立hash，来减少数据的重复</strong><br><font color=#999AAA>创建数据，如果已存在数据则创建失败，如果没有则创建成功</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hsetnx key field value<br></code></pre></td></tr></table></figure><p><strong>业务场景2</strong></p><p>抢购活动</p><p><img src="https://img-blog.csdnimg.cn/20210414111343238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414111420146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><font color=#999AAA>创建id为00001的商铺，货物1 25个，货物2 100个。</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hmset shopping:id:00001 good1 25 good2 100<br></code></pre></td></tr></table></figure><p><font color=#999AAA>店铺货物1被抢走了10个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby shopping:id:00001 good1 -10<br></code></pre></td></tr></table></figure><hr><p>学习链接:<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记1 String数据类型</title>
    <link href="/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><ol><li>String</li><li>Hash</li><li>list</li><li>set</li><li>sorted_set</li></ol><h1 id="String数据类型"><a href="#String数据类型" class="headerlink" title="String数据类型"></a>String数据类型</h1><h2 id="1-redis-数据存储格式"><a href="#1-redis-数据存储格式" class="headerlink" title="1.redis 数据存储格式"></a>1.redis 数据存储格式</h2><ul><li><p> redis自身是一个Map，其中所有的数据类型都是采用key：value的形式存储。</p></li><li><p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>name</td><td>Ruby</td></tr><tr><td>age</td><td>17</td></tr></tbody></table></li></ul><h2 id="2-string类型"><a href="#2-string类型" class="headerlink" title="2.string类型"></a>2.string类型</h2><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>-存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数形式展示，可作为数字操作使用。</li></ul><h2 id="3-string类型数据的基本操作"><a href="#3-string类型数据的基本操作" class="headerlink" title="3.string类型数据的基本操作"></a>3.string类型数据的基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key value<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">get key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mset key1 value1 key2 value2 ...<br></code></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mget key<br></code></pre></td></tr></table></figure></li><li><p>获取数据字符串个数（字符串长度）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">strlen key<br></code></pre></td></tr></table></figure></li><li><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">append key value<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-string类型数据的拓展操作"><a href="#4-string类型数据的拓展操作" class="headerlink" title="4.string类型数据的拓展操作"></a>4.string类型数据的拓展操作</h2><ul><li><p>设置数据具有指定的生命周期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key seconds value<br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><p><em>设置user时效为5s，超出5秒则无法获取。</em></p><p><img src="https://img-blog.csdnimg.cn/20210413204021597.png" alt="img"></p></li><li><p>redis控制数据的生命周期，通过数据是否失效控制业务，适用于所有具有时效性限定控制的操作</p></li></ul><h2 id="5-string类型数据操作的注意事项"><a href="#5-string类型数据操作的注意事项" class="headerlink" title="5.string类型数据操作的注意事项"></a>5.string类型数据操作的注意事项</h2><pre><code>1. 表示运行结果是否成功 （integer）0 → false 失败 （integer）1 → true 成功</code></pre><ol start="2"><li>表示运行结果值<br>（integer） 3 → 3 3个<br> （integer） 1 →1 1个</li><li>数据未获取<br>（nil）== null</li><li>数据最大存储量<br>512MB</li><li>数据计算最大范围（java中的long的最大值）<br>9223372036854775807</li></ol><h2 id="6-业务场景"><a href="#6-业务场景" class="headerlink" title="6.业务场景"></a>6.业务场景</h2><ul><li>主页高频访问信息显示控制，列如新浪微博大V主页显示粉丝数于微博数量</li></ul><p><strong>解决方案</strong> </p><ul><li>在redis中为大v用户设定用户信息，以用户主键和属性值为key，后台设定定时刷新策略。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210413210057424.png" alt="img"></p><ul><li><p>在redis中以json格式存储大v用户，定时刷新</p><p><img src="https://img-blog.csdnimg.cn/20210413210832666.png" alt="img"></p></li></ul><h2 id="7-key的设置约定"><a href="#7-key的设置约定" class="headerlink" title="7.key的设置约定"></a>7.key的设置约定</h2><ul><li><p>热点数据key命名管理</p><p><img src="https://img-blog.csdnimg.cn/20210413211455137.png" alt="img"></p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的网站推荐</title>
    <link href="/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<p>一些我平常使用的网站，个人觉得还都挺不错的，就写在上面推荐一下。</p><h2 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h2><h3 id="1-Canva"><a href="#1-Canva" class="headerlink" title="1.Canva"></a>1.Canva</h3><p>网址：<a href="https://www.canva.cn/">https://www.canva.cn</a></p><p>这是一个在线设计的网站。各种实用模板，包括海报，PPT、微信公众号封面，LOGI等。还有一些不同的图片素材。</p><p><img src="https://img-blog.csdnimg.cn/20210420210755800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Pexels"><a href="#2-Pexels" class="headerlink" title="2.Pexels"></a>2.Pexels</h3><p>网址：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>具有很丰富的高质量图片网站，不光可以免费下载高清图片，而且还可以下载视频，没有版权。</p><p><img src="https://img-blog.csdnimg.cn/20210420211431755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="3-Pixabay"><a href="#3-Pixabay" class="headerlink" title="3.Pixabay"></a>3.Pixabay</h2><p>网址：<a href="https://pixabay.com/">https://pixabay.com/</a></p><p>拥有很多创意向，高清的图片，可以免费下载。</p><p><img src="https://img-blog.csdnimg.cn/20210420212000239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="4-wallhaven"><a href="#4-wallhaven" class="headerlink" title="4.wallhaven"></a>4.wallhaven</h2><p>网址：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>有很多不同种类的图片，分辨率非常高，适合用来当作壁纸或各种背景图。</p><p><img src="https://img-blog.csdnimg.cn/20210420212653446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="5-Iconfont"><a href="#5-Iconfont" class="headerlink" title="5.Iconfont"></a>5.Iconfont</h2><p>网址：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>这是国内第一个最大功能最全的矢量图标库，由阿里巴巴团队稻造的，拥有大量不同的图标，基本上都可以找到自己想要的。</p><p><img src="https://img-blog.csdnimg.cn/20210420213110352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="6-中国色"><a href="#6-中国色" class="headerlink" title="6.中国色"></a>6.中国色</h3><p>网址：<a href="http://zhongguose.com/">http://zhongguose.com/</a></p><p>带有国风色彩的颜色搭配网站。点击RGB搭配的右侧就可以复制、导入颜色了。</p><p><img src="https://img-blog.csdnimg.cn/20210420222253614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="7-ColorHexa"><a href="#7-ColorHexa" class="headerlink" title="7.ColorHexa"></a>7.ColorHexa</h3><p>网址：<a href="https://www.colorhexa.com/">https://www.colorhexa.com/</a></p><p>这是一个方便，颜色种类众多的色彩搭配网站，只需输入想要搭配的颜色，就可以给出不同种的颜色搭配方案。</p><p><img src="https://img-blog.csdnimg.cn/20210420222635239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="学术导航类"><a href="#学术导航类" class="headerlink" title="学术导航类"></a>学术导航类</h2><h3 id="1-科塔学术导航"><a href="#1-科塔学术导航" class="headerlink" title="1.科塔学术导航"></a>1.科塔学术导航</h3><p>网址：<a href="https://site.sciping.com/">https://site.sciping.com/</a></p><p>一个质量不错的学术导航网站，站内分类包括文献数据，期刊出版，学术工具，科研软件，科研数据，学术搜索等。</p><p>它还提供科研社交，科学传播，科研机构版块，每一个版块也会进行具体网站分类；最后，网站的常用推荐功能也可以让你发现很多高质量的学术网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214033485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p>网址：<a href="https://www.chongbuluo.com/">https://www.chongbuluo.com/</a></p><p>功能齐全、很实用的学术搜索网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214747828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="课程学习类"><a href="#课程学习类" class="headerlink" title="课程学习类"></a>课程学习类</h2><h3 id="1-MOOC"><a href="#1-MOOC" class="headerlink" title="1.MOOC"></a>1.MOOC</h3><p>网址：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></p><p>国内联合750所高校共同开发的教学网站。收录了非常多名师教学课程。课程种类也非常齐全。</p><p><img src="https://img-blog.csdnimg.cn/20210420215331708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Visuwords"><a href="#2-Visuwords" class="headerlink" title="2.Visuwords"></a>2.Visuwords</h3><p>网址：<a href="https://visuwords.com/">https://visuwords.com/</a></p><p>这是一个比较有趣的交互式单词学习网站，当你输入一个单词回车后，会给出这个单词的近义词、反义词、从属关系词、因果关系词、属性、实例、分词、动词等等。</p><p>它通过不同的颜色和线条，不同颜色的球体构成一个单词树状图，来代表不同单词之间的关系和类型。</p><p><img src="https://img-blog.csdnimg.cn/20210420220418339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-白描"><a href="#1-白描" class="headerlink" title="1.白描"></a>1.白描</h3><p>网址：<a href="https://web.baimiaoapp.com/">https://web.baimiaoapp.com/</a></p><p>这是一个在线扫描工具，有图片文字提取，电子表格识别，PDF转文字，都是免费使用。</p><p><img src="https://img-blog.csdnimg.cn/20210420221121669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Docsmall"><a href="#2-Docsmall" class="headerlink" title="2.Docsmall"></a>2.Docsmall</h3><p>网址：<a href="https://docsmall.com/">https://docsmall.com/</a></p><p>一个免费在线文件压缩网站，只要上传文件之后，进行处理，在下载就ok了，目前支持图片压缩、GIF压缩、PDF压缩、PDF合并、PDF分割功能。</p><p><img src="https://img-blog.csdnimg.cn/20210420221534842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="3-地图生成器"><a href="#3-地图生成器" class="headerlink" title="3.地图生成器"></a>3.地图生成器</h3><p>网址： <a href="http://datav.aliyun.com/tools/atlas/#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5">点击这里</a></p><p>可以下载国内省份，城市以及县城的svg格式的地图素材，并可以导入到PPT中，可编辑。</p><p><img src="https://img-blog.csdnimg.cn/20210420222012372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><hr><p>后续遇到比较不错的网址还会继续更新下去…</p>]]></content>
    
    
    <categories>
      
      <category>好用的网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
