<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程下篇 - (线程安全集合类、linkedblockingqueue原理）</title>
    <link href="/2021/12/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B%E7%AF%87-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E3%80%81linkedblockingqueue%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <url>/2021/12/13/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B%E7%AF%87-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E3%80%81linkedblockingqueue%E5%8E%9F%E7%90%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h2><p>线程安全集合类可以分为三大类</p><ul><li>遗留的线程安全集合如Hashtable、Vector</li><li>使用Collections装饰的线程安全集合，如：<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li></ul></li><li>java.util.concurrent</li></ul><p>重点介绍java.util.concurrent.下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：Blocking、CopyOnWrite、Concurrent</p><ul><li>Blocking大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite之类容器修改开销相对较重</li><li>Concurrent类型的容器<ul><li>内部很多操作使用cas优化，一般可以提高较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size操作未必是100%准确的</li><li>读取弱一致性</li></ul></li></ul></li></ul><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p><h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2><h3 id="1-JDK7-HashMap并发死链"><a href="#1-JDK7-HashMap并发死链" class="headerlink" title="1.JDK7 HashMap并发死链"></a>1.JDK7 HashMap并发死链</h3><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 测试 java 7 中哪些数字的 hash 结果相等</span><br>       System.out.println(<span class="hljs-string">&quot;长度为16时，桶下标为1的key&quot;</span>);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">16</span> == <span class="hljs-number">1</span>) &#123;<br>               System.out.println(i);<br>           &#125;<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;长度为32时，桶下标为1的key&quot;</span>);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (hash(i) % <span class="hljs-number">32</span> == <span class="hljs-number">1</span>) &#123;<br>               System.out.println(i);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span><br>       <span class="hljs-keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>       <span class="hljs-comment">// 放 12 个元素</span><br>       map.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">8</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">9</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">10</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">16</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">35</span>, <span class="hljs-keyword">null</span>);<br>       map.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>);<br><br>       System.out.println(<span class="hljs-string">&quot;扩容前大小[main]:&quot;</span>+map.size());<br>       <span class="hljs-keyword">new</span> Thread() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span><br>               map.put(<span class="hljs-number">50</span>, <span class="hljs-keyword">null</span>);<br>               System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());<br>           &#125;<br>       &#125;.start();<br>       <span class="hljs-keyword">new</span> Thread() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-comment">// 放第 13 个元素, 发生扩容</span><br>               map.put(<span class="hljs-number">50</span>, <span class="hljs-keyword">null</span>);<br>               System.out.println(<span class="hljs-string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());<br>           &#125;<br>       &#125;.start();<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>           <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>       &#125;<br>       h ^= k.hashCode();<br>       h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>       <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>在 HashMap 源码 590 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> newCapacity = newTable.length;<br></code></pre></td></tr></table></figure><p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p><p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable.length==<span class="hljs-number">32</span> &amp;&amp;<br>( <br>    Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-0&quot;</span>)|| <br>    Thread.currentThread().getName().equals(<span class="hljs-string">&quot;Thread-1&quot;</span>) <br>)<br></code></pre></td></tr></table></figure><p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行 运行代码，程序在预料的断点位置停了下来，输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">长度为<span class="hljs-number">16</span>时，桶下标为<span class="hljs-number">1</span>的key<br><span class="hljs-number">1</span> <br><span class="hljs-number">16</span> <br><span class="hljs-number">35</span> <br><span class="hljs-number">50</span> <br>长度为<span class="hljs-number">32</span>时，桶下标为<span class="hljs-number">1</span>的key <br><span class="hljs-number">1</span> <br><span class="hljs-number">35</span> <br>扩容前大小[main]:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>接下来进入扩容流程调试</p><p>在 HashMap 源码 594 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Entry&lt;K,V&gt; next = e.next; <span class="hljs-comment">// 593 </span><br><span class="hljs-keyword">if</span> (rehash) <span class="hljs-comment">// 594 </span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread().getName().equals(“Thread-0”)）</p><p>这时可以在 Variables 面板观察到 e 和 next 变量，使用 view as -&gt; Object 查看节点状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">e(<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">16</span>)-&gt;<span class="hljs-keyword">null</span><br><br>next(<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">16</span>)-&gt;<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">扩容后大小:<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">e(<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br>    <br>next(<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结 果正确，但它结束后 Thread-0 还要继续运行</p><p>接下来就可以单步调试（F8）观察死链的产生了</p><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">newTable[<span class="hljs-number">1</span>](<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br><br>e (<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br><br>next(<span class="hljs-number">1</span>)-&gt;<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>再看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">e.next = newTable[<span class="hljs-number">1</span>]; <br><span class="hljs-comment">// 这时 e (1,35) </span><br><span class="hljs-comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span><br><br>newTable[<span class="hljs-number">1</span>] = e; <br><span class="hljs-comment">// 再尝试将 e 作为链表头, 死链已成</span><br><br>e = next; <br><span class="hljs-comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span><br></code></pre></td></tr></table></figure><h4 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h4><p>HashMap 的并发死链发生在扩容时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 table 迁移至 newTable</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;<br><span class="hljs-keyword">int</span> newCapacity = newTable.length; <br>  <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123; <br>      Entry&lt;K,V&gt; next = e.next; <br>      <span class="hljs-comment">// 1 处 </span><br>      <span class="hljs-keyword">if</span> (rehash) &#123; <br>        e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key); <br>      &#125; <br>      <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity); <br>      <span class="hljs-comment">// 2 处 </span><br>      <span class="hljs-comment">// 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next </span><br>      e.next = newTable[i]; <br>      newTable[i] = e; <br>      e = next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设 map 中初始元素是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">原始链表，格式：[下标] (key,next) <br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">16</span>)-&gt;(<span class="hljs-number">16</span>,<span class="hljs-keyword">null</span>)<br><br>线程 a 执行到 <span class="hljs-number">1</span> 处 ，此时局部变量 e 为 (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)，而局部变量 next 为 (<span class="hljs-number">35</span>,<span class="hljs-number">16</span>) 线程 a 挂起<br><br>线程 b 开始执行 <br>第一次循环 <br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br><br>第二次循环 <br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br><br>第三次循环<br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br>[<span class="hljs-number">17</span>] (<span class="hljs-number">16</span>,<span class="hljs-keyword">null</span>)<br><br>切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)，而 next 的内 容被改为 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>) <br>第一次循环 <br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br><br>第二次循环，注意这时 e 是 (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>) 并链向 (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>) 所以 next 又是 (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br><br>[<span class="hljs-number">1</span>] (<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)<br><br>第三次循环，e 是 (<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>)，而 next 是 <span class="hljs-keyword">null</span>，但 e 被放入链表头，这样 e.next 变成了 <span class="hljs-number">35</span> （<span class="hljs-number">2</span> 处） <br>[<span class="hljs-number">1</span>] (<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)-&gt;(<span class="hljs-number">35</span>,<span class="hljs-number">1</span>)-&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">35</span>)<br><br>已经是死链了<br></code></pre></td></tr></table></figure><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><ul><li>原因是因为在多线程环境下使用了非线程安全的map集合</li><li>JDK8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</li></ul><h3 id="2-JDK8-ConcurrentHashMap"><a href="#2-JDK8-ConcurrentHashMap" class="headerlink" title="2.JDK8 ConcurrentHashMap"></a>2.JDK8 ConcurrentHashMap</h3><p>重要属性和内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认为0</span><br><span class="hljs-comment">//当初始化时，为-1</span><br><span class="hljs-comment">//当扩容时，为-（1 + 扩容线程数）</span><br><span class="hljs-comment">//当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<br><br><span class="hljs-comment">//整个ConcurrentHashMap 就是一个Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">//hash 表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">//扩容时的新hash表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br><br><span class="hljs-comment">//扩容时如果某个bin迁移完毕，用ForwardingNode作为旧table bin的头节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardingNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;&#125;<br><br><span class="hljs-comment">//用在compute以及computeIfAbsent时，用来占位，计算完成后替换为普通Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReservationNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//作为treebin的头节点，存储root和first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeBin</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;&#125;<br><br><span class="hljs-comment">//作为treebin的节点，存储parent，left，right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>重要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Node[] 中第i个Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab,<span class="hljs-keyword">int</span> i)<br><br><span class="hljs-comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>&lt;K,V&gt; <span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab,<span class="hljs-keyword">int</span> i,Node&lt;K,V&gt; c,Node&lt;K,V&gt; v)</span></span><br><span class="hljs-function">  </span><br><span class="hljs-function"><span class="hljs-comment">//直接修改Node[] 中第i个Node的值，v为新值</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab,<span class="hljs-keyword">int</span> i,Node&lt;K,V&gt; v)</span></span><br></code></pre></td></tr></table></figure><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><h3 id="1-入队操作"><a href="#1-入队操作" class="headerlink" title="1)入队操作"></a>1)入队操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * One of:</span><br><span class="hljs-comment">         * - the real successor Node(真正的后继节点)</span><br><span class="hljs-comment">         * - this Node, meaning the successor is head.next(自己, 发生在出队的时候)</span><br><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)(null, 表示没有后继节点, 是最后了)</span><br><span class="hljs-comment">         */</span><br>        Node&lt;E&gt; next;<br><br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;<br>      <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>      <span class="hljs-comment">// assert last.next == null;</span><br>      last = last.next = node;<br>  &#125;<br></code></pre></td></tr></table></figure><p>初始化链表 last = head = new Node(null); Dummy节点用来占位，item为null</p><p><img src="https://img-blog.csdnimg.cn/20210216161404781.png"></p><p>当一个节点入队last = last.next = node;</p><p><img src="https://img-blog.csdnimg.cn/20210216161624811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>再来一个节点入队 last = last.next = node;</p><p><img src="https://img-blog.csdnimg.cn/20210216161707424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><h3 id="2-出队操作"><a href="#2-出队操作" class="headerlink" title="2)出队操作"></a>2)出队操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>      <span class="hljs-comment">// assert head.item == null;</span><br>      Node&lt;E&gt; h = head;<br>      Node&lt;E&gt; first = h.next;<br>      h.next = h; <span class="hljs-comment">// help GC</span><br>      head = first;<br>      E x = first.item;<br>      first.item = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span> x;<br>  &#125;<br></code></pre></td></tr></table></figure><p>h = head;</p><p><img src="https://img-blog.csdnimg.cn/20210216162300461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>first = h.next;</p><p><img src="https://img-blog.csdnimg.cn/20210216162322684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>h.next = h;</p><p><img src="https://img-blog.csdnimg.cn/20210216162407729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>head = first;</p><p><img src="https://img-blog.csdnimg.cn/20210216162428589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><h3 id="3-加锁分析"><a href="#3-加锁分析" class="headerlink" title="3)加锁分析"></a>3)加锁分析</h3><p>高明指出在于 <strong>用了两把锁和dummy节点</strong></p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li>当节点总数大于2时（包括dummy节点），putLock保证的是last节点的线程安全，takeLock保证的是head节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于2时（即一个dummy节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于1时（就一个dummy节点）这时take线程会被notEmpty条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<br></code></pre></td></tr></table></figure><h3 id="4）put操作"><a href="#4）put操作" class="headerlink" title="4）put操作"></a>4）put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br>Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);<br><span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;<br><span class="hljs-comment">// count 用来维护元素计数</span><br><span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>putLock.lockInterruptibly();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 满了等待</span><br><span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br><span class="hljs-comment">// 倒过来读就好: 等待 notFull</span><br>notFull.await();<br>&#125;<br><span class="hljs-comment">// 有空位, 入队且计数加一</span><br>enqueue(node);<br>c = count.getAndIncrement(); <br><span class="hljs-comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span><br><span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>notFull.signal();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>putLock.unlock();<br>&#125;<br><span class="hljs-comment">// 如果队列中有一个元素, 叫醒 take 线程</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span><br>signalNotEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）take操作"><a href="#5）take操作" class="headerlink" title="5）take操作"></a>5）take操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>E x;<br><span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br><span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;<br>takeLock.lockInterruptibly();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>notEmpty.await();<br>&#125;<br>x = dequeue();<br>c = count.getAndDecrement();<br><span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>notEmpty.signal();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>takeLock.unlock();<br>&#125;<br><span class="hljs-comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span><br><span class="hljs-comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span><br><span class="hljs-keyword">if</span> (c == capacity)<br><span class="hljs-comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span><br>signalNotFull()<br><span class="hljs-keyword">return</span> x; <br> &#125;<br></code></pre></td></tr></table></figure><p>注意：由put唤醒put是为了避免信号不足</p><h3 id="6）性能比较"><a href="#6）性能比较" class="headerlink" title="6）性能比较"></a>6）性能比较</h3><p>主要例举LinkedBlockingQueue与ArrayBlockingQueue的性能比较</p><ul><li>Linked支持有界，Array强制有界</li><li>Linked实现是链表，Array实现是数组</li><li>Linked是懒惰的，而Array需要提前初始化Node数组</li><li>Linked每次入队会生成新Node，而Array的Node是提前创建好的</li><li>Linked两把锁，Array一把锁</li></ul><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue的设计与LinkedBlockingQueue非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者和一个消费者）执行</li><li>dummy节点的引入让两把【锁】将来锁住的是不同的对象，避免竞争</li><li>只是这【锁】使用了CAS来实现</li></ul><p>事实上，ConcurrentLinkedQueue应用还是非常广泛的</p><p>例如之前讲的Tomcat的Connect结构时，Accept作为生产者向Poller消费者传递事件信息时，正式采用了ConcurrentLinkedQueue将SocketChannel给Poller使用</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>copyOnWriteArraySet是它的马甲</p><p>底层实现采用了 <strong>写入时拷贝</strong> 的思想，增删改操作会将底层数据拷贝一份，更改操作在新数组上执行，这时不会影响其他线程的 <strong>并发读，读写分离</strong></p><p>以新增为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>    <span class="hljs-comment">//获取旧的数组</span><br>    Object[] es = getArray();<br>    <span class="hljs-keyword">int</span> len = es.length;<br>    <span class="hljs-comment">//拷贝新的数组（这里是比较耗时的操作，但不影响其他线程)</span><br>    es = Arrays.copyOf(es,len + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//添加新元素</span><br>    es[len] = e;<br>    <span class="hljs-comment">//替换旧的数组</span><br>    setArray(es);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的源码版本是Java11，在Java1.8中使用的是可重入锁而不是synchronized</p><p>其他读操作并未加锁，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consume&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span></span>&#123;<br>  Objects.requireNonNull(action);<br>  <span class="hljs-keyword">for</span>(Object x : <span class="hljs-function">get <span class="hljs-title">Array</span><span class="hljs-params">()</span>)</span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) x;<br>    action.accept(e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>适合【读多写少】的应用场景</p><p>不足：弱一致性</p><p>不要觉得弱一致性就不好</p><ul><li>数据库的MVCC都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程下篇 - (读写锁原理、Semaphore、CountdownLatch、CyclicBarrier）</title>
    <link href="/2021/12/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B%E7%AF%87-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81Semaphore%E3%80%81CountdownLatch%E3%80%81CyclicBarrier%EF%BC%89/"/>
    <url>/2021/12/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B%E7%AF%87-%E8%AF%BB%E5%86%99%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81Semaphore%E3%80%81CountdownLatch%E3%80%81CyclicBarrier%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h2><h3 id="1-ReentrantReadWriteLock"><a href="#1-ReentrantReadWriteLock" class="headerlink" title="1.ReentrantReadWriteLock"></a>1.ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<strong>读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的</strong></p><p>提供一个数据容器类内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_12_ReadWriteLockTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        DataContainer dataContainer = <span class="hljs-keyword">new</span> DataContainer();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            dataContainer.read();<br><span class="hljs-comment">//            dataContainer.write();</span><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-comment">//        Thread.sleep(100);</span><br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">//            dataContainer.read();</span><br>            dataContainer.write();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainer&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Object object = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>        readLock.lock();<br>        log.info(<span class="hljs-string">&quot;拿到读锁！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;读取操作 ...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>            log.info(<span class="hljs-string">&quot;释放读锁！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>&#123;<br>        writeLock.lock();<br>        log.info(<span class="hljs-string">&quot;拿到写锁！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;写操作 ... &quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>            log.info(<span class="hljs-string">&quot;释放写锁！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>读锁不支持条件变量</p></li><li><p>重入时升级不支持：即持有读锁的情况下去获取锁，会导致获取写锁永久等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    w.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">finally</span>&#123;<br>        w.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span>&#123;<br>    r.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>重入时降级支持：即持有写锁的情况下去获取读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedData</span> </span>&#123;<br>    Object data;<br>    <span class="hljs-comment">// 是否有效，如果失效，需要重新计算 data</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> cacheValid;<br>    <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processCachedData</span><span class="hljs-params">()</span> </span>&#123;<br>        rwl.readLock().lock();<br>        <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>            <span class="hljs-comment">// 获取写锁前必须释放读锁</span><br>            rwl.readLock().unlock();<br>            rwl.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span><br>                <span class="hljs-keyword">if</span> (!cacheValid) &#123;<br>                    data = ...<br>                    cacheValid = <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span><br>                rwl.readLock().lock();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br><br>                rwl.writeLock().unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 自己用完数据, 释放读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            use(data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rwl.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-应用之缓存"><a href="#2-应用之缓存" class="headerlink" title="2.应用之缓存"></a>2.应用之缓存</h3><p><strong>缓存更新策略：</strong></p><p>更新时，是先清缓存还是先更新数据库？</p><ul><li>应先更新数据库</li></ul><p>先清除缓存操作：</p><p><img src="https://img-blog.csdnimg.cn/20210212161110405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>先更新数据库操作如下：</p><p><img src="https://img-blog.csdnimg.cn/20210212161021523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>补充一种情况，假设查询线程A查询数据时恰好缓存数据由于时间到期失效，或是第一次查询：这种情况的出现机率非常小：</p><p><img src="https://img-blog.csdnimg.cn/20210212162602284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ReentrantReadWriteLock 读写锁解决 缓存与数据库一致性问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_13_ReadWriteCacheTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        GeneriCacheDao&lt;Object&gt; generiCacheDao = <span class="hljs-keyword">new</span> GeneriCacheDao&lt;&gt;();<br><br>        Object[] objects = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">2</span>];<br>        generiCacheDao.queryOne(Object.class,<span class="hljs-string">&quot;Test&quot;</span>,objects);<br>        generiCacheDao.queryOne(Object.class,<span class="hljs-string">&quot;Test&quot;</span>,objects);<br>        generiCacheDao.queryOne(Object.class,<span class="hljs-string">&quot;Test&quot;</span>,objects);<br>        generiCacheDao.queryOne(Object.class,<span class="hljs-string">&quot;Test&quot;</span>,objects);<br>        System.out.println(generiCacheDao.map);<br>        generiCacheDao.update(<span class="hljs-string">&quot;Test&quot;</span>,objects);<br>        System.out.println(generiCacheDao.map);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneriCacheDao</span>&lt;<span class="hljs-title">T</span>&gt;  <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericDao</span> </span>&#123;<br><br>    HashMap&lt;SqlPair, T&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    ReentrantReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    GenericDao genericDao = <span class="hljs-keyword">new</span> GenericDao();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql, Object... params)</span></span>&#123;<br>        lock.writeLock().lock();<br>        SqlPair sqlPair = <span class="hljs-keyword">new</span> SqlPair(sql, params);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 先查询数据库再更新缓存,但是这里加了锁，谁先谁后都没关系</span><br>            <span class="hljs-keyword">int</span> update = genericDao.update(sql, params);<br>            map.clear();<br>            <span class="hljs-keyword">return</span> update;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">queryOne</span><span class="hljs-params">(Class beanClass, String sql, Object... params)</span></span>&#123;<br>        SqlPair key = <span class="hljs-keyword">new</span> SqlPair(sql, params);<br>        <span class="hljs-comment">// 加读锁, 防止其它线程对缓存更改</span><br>        lock.readLock().lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            T t = map.get(key);<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.readLock().unlock();<br>        &#125;<br><br>        <span class="hljs-comment">// 加写锁, 防止其它线程对缓存读取和更改</span><br>        lock.writeLock().lock();<br>        <span class="hljs-comment">// get 方法上面部分是可能多个线程进来的, 可能已经向缓存填充了数据</span><br>        <span class="hljs-comment">// 为防止重复查询数据库, 再次验证</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            T value = map.get(key);<br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)&#123;<br>                value = (T) genericDao.queryOne(beanClass, sql, params);<br>                map.put(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlPair</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String sql;<br><br>        <span class="hljs-keyword">private</span> Object[] params;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqlPair</span><span class="hljs-params">(String sql, Object[] params)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.sql = sql;<br>            <span class="hljs-keyword">this</span>.params = params;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            SqlPair sqlMap = (SqlPair) o;<br>            <span class="hljs-keyword">return</span> Objects.equals(sql, sqlMap.sql) &amp;&amp;<br>                    Arrays.equals(params, sqlMap.params);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> result = Objects.hash(sql);<br>            result = <span class="hljs-number">31</span> * result + Arrays.hashCode(params);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericDao</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(String sql, Object... params)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">queryOne</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... params)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;查询数据库中&quot;</span>);<br>        <span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">new</span> Object();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-读写锁原理"><a href="#3-读写锁原理" class="headerlink" title="3.读写锁原理"></a>3.读写锁原理</h3><p><strong>图解流程</strong></p><p>读写锁用的是同一个Sync同步器，因此等待队列、state等也是同一个</p><p><strong>下面执行：t1 w.lock，t2 r.lock情况</strong></p><p>1） t1成功上锁，流程与ReentrantLock加锁相比没有特殊之处，不同是写锁状态占了state的低16位，而读锁使用的是state的高16位</p><p><img src="https://img-blog.csdnimg.cn/20210212170746395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>2）t2执行r.lock，这时进入读锁的sync.acquireShared(1)流程，首先会进入tryAcquireShared流程。如果有写锁占据，那么tryAcquireShared返回-1表示失败。tryAcquireShared返回值表示</p><ul><li>-1表示失败</li><li>0表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，我们这里的读写锁返回1</li></ul><p><img src="https://img-blog.csdnimg.cn/2021021218030677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>3）这时会进入sync.doAcquireShared(1)流程，首先也是调用addWaiter添加节点，不同之处在于节点被设置为Node.SHARED模式而非Node.EXCLUSIVE模式，注意此时t2仍处于活跃状态</p><p><img src="https://img-blog.csdnimg.cn/20210212180902957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>4）t2会看看自己的节点是不是老二，如果是，还会再次调用tryAcquireShared(1)来尝试获取锁</p><p>5）如果没有成功，在doAcquireShared内for(;;)循环一次，把前驱节点的waitStatus改为-1，再for(;;)循环一次尝试truAcquireShared(1)如果还不成功，那么在parkAndCheckInterrupt()处park。</p><p><img src="https://img-blog.csdnimg.cn/20210212181921417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p><strong>又继续执行：</strong> t3：r.lock，t4：w.lock</p><p>这种状态下，假设又有t3加读锁和t4加写锁，这期间t1仍然持有锁，就变成如下：</p><p><img src="https://img-blog.csdnimg.cn/20210212182152625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p><strong>继续执行t1 w.unlock</strong></p><p>这时会走到写锁的sync.release(1)流程，调用sync.tryRelease(1)成功，变成下面：</p><p><img src="https://img-blog.csdnimg.cn/20210212182546213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>接下来执行唤醒流程sync.unparkSuccessor，即让老二恢复运行，这时t2在doAcquireShared内parkAndCheckInterrupt()处恢复运行，图中的t2从黑色变成蓝色（ <strong>注意这里只是恢复运行，并没有获取到锁</strong> ）这回再来一次for(;;)执行tryAcquireShared成功则让读锁计数加1</p><p><img src="https://img-blog.csdnimg.cn/20210212183239284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>这时t2已经恢复运行，接下来t2调用setHeadAndPropagate(node,1)，它原本所在节点被置为头节点</p><p><img src="https://img-blog.csdnimg.cn/20210212183316937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>在setHeadAndPropagate方法内还会检查下一个节点是否shared，如果是，则调用doReleaseShared()将head的状态从-1改为0并唤醒老二，这时t3在doAcquireShared内parkAndCheckInterrupt()处恢复运行</p><p><img src="https://img-blog.csdnimg.cn/20210212193351405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>这回再来一次for(;;)执行try AcquireShared成功则让读锁计数加1</p><p><img src="https://img-blog.csdnimg.cn/20210212194216321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>这时t3已经恢复运行，接下来t3调用setHeadAndPropagate（node,1)，它原本所在节点被置为头节点</p><p><img src="https://img-blog.csdnimg.cn/20210212194406314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>再继续执行t2：r.unlock，t3：r.unlock</p><p>t2进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，但由于计数还不为0</p><p><img src="https://img-blog.csdnimg.cn/20210212194632296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>t3进入sync.releaseShared(1)中，调用tryRelease Shared(1)让计数减一，这回计数为0了，进入doReleaseShared()将头节点从-1改为0并唤醒老二，即</p><p><img src="https://img-blog.csdnimg.cn/202102121947327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>之后t4在acquireQueued中parkAndCheckInterrupt()处恢复运行，再次for(;;)这次自己是老二，并且没有其他竞争，tryAcquire(1)成功，修改头节点，流程结束</p><p><img src="https://img-blog.csdnimg.cn/20210212194801727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>源码分析</p><p><strong>写锁上锁流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// ... 省略无关代码</span><br><br>    <span class="hljs-comment">// 外部类 WriteLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 尝试获得写锁失败</span><br>                !tryAcquire(arg) &amp;&amp;<br>                        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span><br>                        <span class="hljs-comment">// 进入 AQS 队列阻塞</span><br>                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-comment">// 获得低 16 位, 代表写锁的 state 计数</span><br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">int</span> w = exclusiveCount(c);<br><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// c != 0 and w == 0 表示有读锁返回错误，读锁不支持锁升级, 或者</span><br>                    w == <span class="hljs-number">0</span> ||<br>                            <span class="hljs-comment">// c != 0 and w == 0 表示有写，如果 exclusiveOwnerThread 不是自己</span><br>                            current != getExclusiveOwnerThread()<br>            ) &#123;<br>                <span class="hljs-comment">// 获得锁失败</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 写锁计数超过低 16 位, 报异常</span><br>            <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 写锁重入, 获得锁成功</span><br>            setState(c + acquires);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 判断写锁是否该阻塞这里返回false, 或者</span><br>                writerShouldBlock() ||<br>                        <span class="hljs-comment">// 尝试更改计数失败</span><br>                        !compareAndSetState(c, c + acquires)<br>        ) &#123;<br>            <span class="hljs-comment">// 获得锁失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获得锁成功</span><br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">writerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写锁释放流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// ... 省略无关代码</span><br><br>    <span class="hljs-comment">// WriteLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-comment">// 尝试释放写锁成功</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-comment">// unpark AQS 中等待的线程</span><br>            Node h = head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">int</span> nextc = getState() - releases;<br>        <span class="hljs-comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span><br>        <span class="hljs-keyword">boolean</span> free = exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (free) &#123;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读锁上锁流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><br>    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquireShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) &#123;<br>            doAcquireShared(arg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// 如果是其它线程持有写锁, 获取读锁失败</span><br>        <span class="hljs-keyword">if</span> (<br>                exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>                        getExclusiveOwnerThread() != current<br>        ) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> r = sharedCount(c);<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 读锁不该阻塞(如果老二是写锁，读锁该阻塞), 并且</span><br>                !readerShouldBlock() &amp;&amp;<br>                        <span class="hljs-comment">// 小于读锁计数, 并且</span><br>                        r &lt; MAX_COUNT &amp;&amp;<br>                        <span class="hljs-comment">// 尝试增加计数成功</span><br>                        compareAndSetState(c, c + SHARED_UNIT)<br>        ) &#123;<br>            <span class="hljs-comment">// ... 省略不重要的代码</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>    &#125;<br><br>    <span class="hljs-comment">// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁</span><br>    <span class="hljs-comment">// true 则该阻塞, false 则不阻塞</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readerShouldBlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> apparentlyFirstQueuedIsExclusive();<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullTryAcquireShared</span><span class="hljs-params">(Thread current)</span> </span>&#123;<br>        HoldCounter rh = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != current)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readerShouldBlock()) &#123;<br>                <span class="hljs-comment">// ... 省略不重要的代码</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (sharedCount(c) == MAX_COUNT)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>                <span class="hljs-comment">// ... 省略不重要的代码</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span><br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">// 再一次尝试获取读锁</span><br>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                    <span class="hljs-comment">// 成功</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// ㈠</span><br><span class="hljs-comment">// r 表示可用资源数, 在这里总是 1 允许传播</span><br>                        <span class="hljs-comment">//（唤醒 AQS 中下一个 Share 节点）</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                    <span class="hljs-comment">// 是否在获取读锁失败时阻塞（前一个阶段 waitStatus == Node.SIGNAL）</span><br>                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                                <span class="hljs-comment">// park 当前线程</span><br>                                parkAndCheckInterrupt()<br>                ) &#123;<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;<br>        Node h = head; <span class="hljs-comment">// Record old head for check below</span><br>        <span class="hljs-comment">// 设置自己为 head</span><br>        setHead(node);<br><br>        <span class="hljs-comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span><br>        <span class="hljs-comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>        <span class="hljs-comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span><br>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>                (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>            Node s = node.next;<br>            <span class="hljs-comment">// 如果是最后一个节点或者是等待共享读锁的节点</span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) &#123;<br>                <span class="hljs-comment">// 进入 ㈡</span><br>                doReleaseShared();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE, 为了解决 bug, 见后面分析，参考这里：http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#5propagate-%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Node h = head;<br>            <span class="hljs-comment">// 队列还有节点</span><br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>                    <span class="hljs-comment">// 下一个节点 unpark 如果成功获取读锁</span><br>                    <span class="hljs-comment">// 并且下下个节点还是 shared, 继续 doReleaseShared</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读锁释放流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br><br>    <span class="hljs-comment">// ReadLock 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>        <span class="hljs-comment">// ... 省略不重要的代码</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-keyword">int</span> nextc = c - SHARED_UNIT;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc)) &#123;<br>                <span class="hljs-comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程</span><br>                <span class="hljs-comment">// 计数为 0 才是真正释放</span><br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Node h = head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-keyword">int</span> ws = h.waitStatus;<br>                <span class="hljs-comment">// 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span><br>                <span class="hljs-comment">// 防止 unparkSuccessor 被多次执行</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop to recheck cases</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-comment">// 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                        !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head) <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-StampedLock"><a href="#4-StampedLock" class="headerlink" title="4.StampedLock"></a>4.StampedLock</h3><p>该类自JDK8加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p>加解读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure><p>加解写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><p>乐观读，StampedLock支持tryOptimisticRead()方法（乐观读），读取完毕后需要做一次 <strong>戳校验</strong> 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没有通过，需要从乐观读 锁升级为读锁，保证数据安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> stamp = lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br> <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><p>提供一个数据容器类 内部分别使用读锁保护数据的read()方法，写锁保护数据的write()方法</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_14_StampedLockTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        StampedLockDataContainer dataContainer = <span class="hljs-keyword">new</span> StampedLockDataContainer(<span class="hljs-number">1</span>);<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(dataContainer.read(<span class="hljs-number">1</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br><br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-comment">//            try &#123;</span><br><span class="hljs-comment">//                dataContainer.read(0);</span><br><span class="hljs-comment">//            &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                e.printStackTrace();</span><br><span class="hljs-comment">//            &#125;</span><br>            dataContainer.write(<span class="hljs-number">10</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t2.start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.StampedLockDataContainer&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StampedLockDataContainer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">private</span> StampedLock stampedLock = <span class="hljs-keyword">new</span> StampedLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StampedLockDataContainer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> readTime)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = stampedLock.tryOptimisticRead();<br>        log.info(<span class="hljs-string">&quot;optimistic read locking ...&#123;&#125;&quot;</span>, stamp);<br>        Thread.sleep(readTime * <span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span>(stampedLock.validate(stamp)) &#123;<br>            log.info(<span class="hljs-string">&quot;read finish... &#123;&#125;&quot;</span>, stamp);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-comment">// 锁升级 - 读锁</span><br>        log.info(<span class="hljs-string">&quot;update to read lock ...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = stampedLock.readLock();<br>            log.info(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>            Thread.sleep(readTime * <span class="hljs-number">1000</span>);<br>            log.info(<span class="hljs-string">&quot;read finish ... &#123;&#125;&quot;</span>, stamp);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newData)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> stamp = stampedLock.writeLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br>            <span class="hljs-keyword">this</span>.data = newData;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;write finish ... &#123;&#125;&quot;</span>, stamp);<br>            log.info(<span class="hljs-string">&quot;write newData ... &#123;&#125;&quot;</span>, <span class="hljs-keyword">this</span>.data);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>StampedLock不支持条件变量</p><p>StampedLock不支持可重入</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>信号量，用来限制能同时访问共享资源的线程上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 创建一个对象</span><br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2. 开 10 个线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-comment">// 获取一个许可</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;start ...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.info(<span class="hljs-string">&quot;end ....&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;t&quot;</span> + (i + <span class="hljs-number">1</span>)).start();;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-图解流程"><a href="#2-图解流程" class="headerlink" title="2.图解流程"></a>2.图解流程</h3><p>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。</p><p>刚开始，permits(state)为3，这时5个线程来获取资源</p><p><img src="https://img-blog.csdnimg.cn/20210212232646519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>假设其中Thread-1，Thread-2，Thread-4 CAS竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞</p><p><img src="https://img-blog.csdnimg.cn/20210212232925148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>这时Thread-4释放了permits，状态如下</p><p><img src="https://img-blog.csdnimg.cn/20210212233133428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>接下来Thread-0竞争成功，permits再次设置为0，设置自己为head节点，断开原来的head节点，unpark接下来的Thread-3节点，但由于permits是0，因此Thread-3在尝试不成功后再次进入park状态</p><p><img src="https://img-blog.csdnimg.cn/20210212233704847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2694183684443567898L</span>;<br>    NonfairSync(<span class="hljs-keyword">int</span> permits) &#123;<br>        <span class="hljs-comment">// permits 即 state</span><br>        <span class="hljs-keyword">super</span>(permits);<br>    &#125;<br><br>    <span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获得共享锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> available = getState();<br>            <span class="hljs-keyword">int</span> remaining = available - acquires;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span><br>                    remaining &lt; <span class="hljs-number">0</span> ||<br>                            <span class="hljs-comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span><br>                            compareAndSetState(available, remaining)<br>            ) &#123;<br>                <span class="hljs-keyword">return</span> remaining;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">// 再次尝试获取许可</span><br>                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span><br>                        <span class="hljs-comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span><br>                        <span class="hljs-comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span><br>  <span class="hljs-comment">// r 表示可用资源数, 为 0 则不会继续传播</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                        failed = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                        parkAndCheckInterrupt())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Semaphore 方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> current = getState();<br>            <span class="hljs-keyword">int</span> next = current + releases;<br>            <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>            <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p><strong>CountDownLatch允许多线程阻塞在一个地方，直至所有线程的任务都执行完毕。</strong>在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保很好的了解它</p><p>CountDownLatch是共享锁的一种实现，它默认构造AQS的state值为count。当线程使用countDown方法时，其实使用了tryReleaseShared方法以CAS的操作来减少state，直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park，并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行</p><p>当用来进行线程同步协作，等待所有线程完成倒计时。其中构造参数用来舒适化等待计数值，await()用来等待计数归零，countDown()用来让计数减一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.CountDownLatch&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_16_CountDownLatchTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        method3();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t1 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;t1 end ...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t2 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;t2 end ...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t3 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;t3 end ...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br><br>        log.info(<span class="hljs-string">&quot;main wait ...&quot;</span>);<br>        countDownLatch.await();<br>        log.info(<span class="hljs-string">&quot;main wait end ...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        executorService.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t1 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            countDownLatch.countDown();<br>            log.info(<span class="hljs-string">&quot;t1 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());<br>        &#125;);<br><br>        executorService.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t2 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;t2 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());<br>            countDownLatch.countDown();<br>        &#125;);<br><br>        executorService.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;t3 start ...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1500</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;t3 end ...&#123;&#125;&quot;</span>, countDownLatch.getCount());<br>            countDownLatch.countDown();<br>        &#125;);<br><br>        executorService.submit(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;main wait ...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                countDownLatch.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;main wait end ...&quot;</span>);<br>            executorService.shutdown();<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">10</span>);<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        String[] all = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            executorService.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">100</span>; j++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(random.nextInt(<span class="hljs-number">100</span>));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    all[id] = j + <span class="hljs-string">&quot;%&quot;</span>;<br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<br>                &#125;<br>                countDownLatch.countDown();<br>            &#125;);<br>        &#125;<br>        countDownLatch.await();<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;游戏开始&quot;</span>);<br>        executorService.shutdown();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置【计数个数】，每个线程执行到某个需要“同步”的时刻调用await()方法进行等待，当等待的线程数满足【计数个数】时，继续执行。</p><p>跟CountDownLatch一样，但这个可以重用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">2</span>, () -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;task2 finish ...&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            executorService.submit(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;task1 begin ...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            executorService.submit(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;task2 begin ...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    cyclicBarrier.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        executorService.shutdown();<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程中篇 - (JUC之AQS原理、ReentrantLock原理)</title>
    <link href="/2021/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%AF%87-JUC%E4%B9%8BAQS%E5%8E%9F%E7%90%86%E3%80%81ReentrantLock%E5%8E%9F%E7%90%86/"/>
    <url>/2021/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%AF%87-JUC%E4%B9%8BAQS%E5%8E%9F%E7%90%86%E3%80%81ReentrantLock%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、AQS原理"><a href="#一、AQS原理" class="headerlink" title="一、AQS原理"></a>一、AQS原理</h3><p><img src="https://img-blog.csdnimg.cn/20210202223902808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p><code>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</code>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p><img src="https://img-blog.csdnimg.cn/20210119105644735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li>特点：<ul><li>用<code>state</code>属性来表示<code>资源的状态</code>（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state状态</li><li>setState - 设置 state状态</li><li>compareAndSetState - cas机制设置 state状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li><strong>提供了基于FIFO的等待队列，类似于Monitor的EntryList</strong></li><li><strong>条件变量来实现等待、唤醒机制、支持多个条件变量，类似于Monitor的WaitSet</strong></li></ul></li></ul><p>子类主要实现这样一些方法（默认抛出UnsupportedOperationException）</p><ul><li><strong>tryAcquire</strong></li><li><strong>tryRelease</strong></li><li><strong>tryAcquireShared</strong></li><li><strong>tryReleaseShared</strong></li><li><strong>isHeldExclusively</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁的姿势</span><br><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br> <span class="hljs-comment">// 入队, 可以选择阻塞当前线程 park unpark</span><br>&#125;<br><br><span class="hljs-comment">//释放锁的姿势</span><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br> <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>下面实现一个不可重入的阻塞式锁：使用<code>AbstractQueuedSynchronizer</code>自定义一个同步器来实现自定义锁！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/1/4 23:10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestAQS&quot;)</span><br><span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAqs</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyLock lock = <span class="hljs-keyword">new</span> MyLock();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>            <span class="hljs-comment">// 不可重入锁, 同一线程在锁释放前, 只能加一次锁</span><br><span class="hljs-comment">//            lock.lock();</span><br><span class="hljs-comment">//            log.debug(&quot;locking...&quot;);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>                Sleeper.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义锁（不可重入锁）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-comment">// 独占锁  同步器类</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-comment">// 确保原子性</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 加上了锁，并设置 owner 为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-comment">// 这里不需要确定原子性, 因为是持锁者进行释放</span><br>            <span class="hljs-comment">// 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题</span><br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的, 具体见volatile原理(写屏障)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 是否持有独占锁</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> MySync sync = <span class="hljs-keyword">new</span> MySync();<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁（不成功会进入等待队列）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁，可打断</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁（一次）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁，带超时</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 创建条件变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、ReentrantLock-原理"><a href="#二、ReentrantLock-原理" class="headerlink" title="二、ReentrantLock 原理"></a>二、ReentrantLock 原理</h3><ul><li>ReentrantLock提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/14f43b7a0fa8b979b9101ab5170398cc.png"></p><h4 id="1-非公平锁实现原理"><a href="#1-非公平锁实现原理" class="headerlink" title="1.非公平锁实现原理"></a>1.非公平锁实现原理</h4><p><strong>图解流程</strong></p><ul><li><code>加锁，解锁</code>流程，先从构造器开始看，默认为非公平锁实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br> sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NonfairSync</strong> extends Sync extends AbstractQueuedSynchronizer</p><ul><li><p>没有竞争时</p><ul><li>Thread - 0成为锁的持有者</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5ed1f22fcfc9dda5a8b3b1cc737f2bb5.png"></p></li><li><p>第一个竞争出现时，查看源码的NonfairSync的lock方法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/07d53face5cb7d27d43a9b8dbee38820.png"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 非公平锁的lock</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>Thread - 1执行了</p><ol><li> <strong>lock方法中CAS尝试将state由0改为1，结果失败（因为此时CAS操作，已经state为1了</strong></li><li> lock方法中进一步调用<code>acquire</code>方法,进入<code>tryAcquire</code>逻辑，这里我们认为这时state已经是1，结果仍然失败</li><li> 接下来进入acquire方法的<code>addWaiter</code>逻辑，构造<strong>Node队列（双向链表实现）</strong></li><li>下图中<code>黄色三角</code>表示该Node的<code>waitStatus</code>状态，其中0为默认正常状态</li><li>Node的创建是懒惰的</li><li><strong>其中第一个Node称为Dummy（哑元）或哨兵，用来占位，并不关联线程</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/be834858592889523943183e15acfa58.png"></p><p>当线程进入acquire方法的acquireQueued逻辑</p><ol><li>acquireQueued会在一个死循环中不断尝试获得锁，失败后进入<code>park</code>阻塞</li><li>如果自己是紧邻着head（排第二位），那么再次tryAcquire尝试获取锁，我们这里设置这时state仍为1，失败</li><li>进入<code>shouldParkAfterFailedAcquire</code>逻辑，将<code>前驱node</code>，即head的waitStatus改为-1，这次返回false</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/d66b53fa0c1ecaffa3fae6580c846292.png"></p><ol start="4"><li>shouldParkAfterFailedAcquire执行完毕回到acquireQueued，再次tryAcquire尝试获取锁，当然这时state仍为1，失败</li><li>当再次进入shouldParkAfterFailedAcquire时，这时因为其前驱node的waitStatus已经是-1，这次返回true</li><li>进入<code>parkAndCheckInterrupt</code>，Thread -1 park（灰色表示已经阻塞）</li></ol><p><img src="https://img-blog.csdnimg.cn/20210105234001801.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/844a2077a9096fed80b31ae91e8e8c13.png"></p><ul><li>再次有多个线程经历上述过程竞争失败：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c673a02e84847dd8e7fbef4944863a5f.png"></p><p>Thread - 0调用unlock方法里的release方法释放锁，进入<code>tryRelease(使用ctrl+alt+b查看tryRelease方法的具体ReentrantLock实现)</code>流程，如果成功， <strong>设置exclusiveOwnerThread 为 null，state = 0</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/674d24535dcb379439c6105468bcb72b.png"></p><p>unlock方法里的release方法中，如果当前队列不为null，并且head的waitStatus = -1，进入unparkSuccessor流程：<code>unparkSuccessor中会找到队列中离head最近的一个Node（没取消的），unpark唤醒Thread - 1恢复其运行，</code>本例中即为Thread -1回到Thread-1阻塞的位置继续执行，会继续执行acquireQueued流程</p><p><img src="https://img-blog.csdnimg.cn/20210105235033126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0c4dd83170dbced9979e3c0a5b7cc69c.png"></p><p><strong>如果加锁成功（没有竞争）</strong>，会设置（acquireQueued方法中）</p><ol><li>exclusiveOwnerThread为Thread -1，state = 1</li><li>head指向刚刚Thread-1所在的Node，该Node清空Thread</li><li>原本的head因为从链表断开，而可被垃圾回收</li></ol><p><strong>如果这时候有其他线程来竞争（非公平的体现），例如这时有Thread-4来了</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/990731fe3d516c3947623aeba1a356d3.png"></p><p>如果不巧被Thread - 4占了先</p><ol><li>Thread-4被设置为exclusiveOwnerThread，state=1</li><li><code>Thread-1再次进入acquireQueued流程，获取锁失败，重新进入park阻塞</code></li></ol><p><code>加锁</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br><br>     <span class="hljs-comment">// 加锁实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 如果尝试失败，进入 ㈠</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-comment">// ㈡ tryAcquire</span><br>        <span class="hljs-keyword">if</span> (<br>                !tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span><br>                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ 进入 ㈢</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// 如果还没有获得锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-comment">// state++</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取失败, 回到调用处</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br><span class="hljs-comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0</span><br>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>        Node pred = tail;<br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>            node.prev = pred;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                <span class="hljs-comment">// 双向链表</span><br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Node t = tail;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node())) &#123;<br>                    tail = head;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span><br>                    setHead(node);<br>                    <span class="hljs-comment">// 上一个节点 help GC</span><br>                    p.next = <span class="hljs-keyword">null</span>;<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-comment">// 返回中断标记 false</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                    <span class="hljs-comment">// 判断是否应当 park, 进入 ㈦</span><br>                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    <span class="hljs-comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span><br>                    parkAndCheckInterrupt()<br>                ) &#123;<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取上一个节点的状态</span><br>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>            <span class="hljs-comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// &gt; 0 表示取消状态</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这次还没有阻塞</span><br>            <span class="hljs-comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈧ 阻塞当前线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>解锁</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// 解锁实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-comment">// 尝试释放锁, 进入 ㈠</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-comment">// 队列头节点 unpark</span><br>            Node h = head;<br>            <span class="hljs-keyword">if</span> (<br>                <span class="hljs-comment">// 队列不为 null</span><br>                h != <span class="hljs-keyword">null</span> &amp;&amp;<br>                <span class="hljs-comment">// waitStatus == Node.SIGNAL 才需要 unpark</span><br>                h.waitStatus != <span class="hljs-number">0</span><br>            ) &#123;<br>                <span class="hljs-comment">// unpark AQS 中等待的线程, 进入 ㈡</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-comment">// state--</span><br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉</span><br>        <span class="hljs-comment">// 不成功也可以</span><br>        <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) &#123;<br>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span><br>        Node s = node.next;<br>        <span class="hljs-comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = t;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-可重入原理"><a href="#2-可重入原理" class="headerlink" title="2.可重入原理"></a>2.可重入原理</h4><ul><li>同一个线程，锁重入，会对state进行自增，释放锁的时候，state进行自减；当state自减为0的时候，此时线程才会将锁释放成功，才会进一步去唤醒<code>其他线程</code>来竞争锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-comment">// state++</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-comment">// state--</span><br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-可打断原理"><a href="#3-可打断原理" class="headerlink" title="3.可打断原理"></a>3.可打断原理</h4><ul><li>不可打断模式：在此模式下， <strong>即使它被打断，仍会驻留在AQS队列中，一直要等到获得锁后方能得知自己被打断了</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承自 AQS</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果打断标记已经是 true, 则 park 会失效</span><br>        <span class="hljs-comment">// 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// interrupted 会清除打断标记; 下次park仍然可以阻塞</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-keyword">null</span>;<br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-comment">// 还是需要获得锁后, 才能返回打断状态</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<br>                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                                parkAndCheckInterrupt()<br>                ) &#123;<br>                    <span class="hljs-comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span><br>                    interrupted = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<br>                !tryAcquire(arg) &amp;&amp;<br>                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            <span class="hljs-comment">// 如果打断状态为 true</span><br>            selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错</span><br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可打断模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        <span class="hljs-comment">// 如果没有获得到锁, 进入 ㈠</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>            doAcquireInterruptibly(arg);<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ 可打断的获取锁流程</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                        parkAndCheckInterrupt()) &#123;<br>                    <span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br>                    <span class="hljs-comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-公平锁实现原理"><a href="#4-公平锁实现原理" class="headerlink" title="4.公平锁实现原理"></a>4.公平锁实现原理</h4><p>看AQS队列中，自己（线程）有没有前驱节点（线程），（该节点不是占位的哨兵节点）；如果有就不去竞争锁。如果没有，才会CAS操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<br>                !tryAcquire(arg) &amp;&amp;<br>                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)<br>        ) &#123;<br>            selfInterrupt();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>        Node t = tail;<br>        Node h = head;<br>        Node s;<br>        <span class="hljs-comment">// h != t 时表示队列中有 Node</span><br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>                (<br>                        <span class="hljs-comment">// (s = h.next) == null 表示队列中还有没有老二</span><br>                        (s = h.next) == <span class="hljs-keyword">null</span> || <span class="hljs-comment">// 或者队列中老二线程不是此线程</span><br>                                s.thread != Thread.currentThread()<br>                );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-条件变量原理"><a href="#5-条件变量原理" class="headerlink" title="5.条件变量原理"></a>5.条件变量原理</h4><p><strong>图解流程</strong></p><p>每个条件变量其实就对应着一个<code>等待队列</code>，其实现类是<code>ConditionObject</code></p><ul><li><code>await流程</code>开始Thread-0持有锁，conditionObject对象调用<code>await</code>，进入ConditionObject的addConditionWaiter流程，创建新的Node状态为-2（Node.CONDITION)，关联Thread-0，加入等待队列尾部</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/09246ff55afe135799cd51abc4986653.png"></p><p>接下来进入AQS的<code>fullRelease</code> 流程，释放同步器上的所有的锁（因为可能线程发生可重入，锁有很多层）</p><p><code>unparkSuccessor(h);</code>—&gt; unpark唤醒 AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 <code>Thread-1</code> 竞争成功</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e792aec6dc7581bb2dc160ede42c9e46.png"></p><p>LockSupport.park(this); —&gt; park 阻塞 Thread-0</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7917fb349c6c2af1cd40575968f829da.png"></p><ul><li><code>signal流程</code><ul><li>假设Thread-1要来唤醒Thread-0</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果没有持有锁，会抛出异常 --&gt; 这里表示Thread-1要持有锁, </span><br><span class="hljs-comment">//才可以去条件变量中去唤醒等待的线程</span><br>        <span class="hljs-keyword">if</span> (!isHeldExclusively()) <br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/aca67cba0461a01aca2ba48fbf04203c.png"></p><p>进入ConditionObject的<code>doSignal</code>流程，取得等待队列中第一个Node，即Thread-0所在Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// 去firstWaiter条件变量中将等待的线程拿出来.</span><br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 转移到AQS的队列中, 等待竞争锁</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a0d8ac2c5ea30e856db42691f2eb1a2b.png"></p><p>执行<code>transferForSignal</code>流程， <strong>将该Node加入AQS队列尾部，将Thread-0的waitStatus改为0，Thread-3的waitStatus改为-1，</strong> 改为-1就有责任去唤醒自己的后续节点</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c9e2f0c07b88d0dcd7b4b9a49238a50a.png"></p><p>Thread-1释放锁，进入unlock流程</p><p><strong>源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;<br><br>    <span class="hljs-comment">// 第一个等待节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><br>    <span class="hljs-comment">// 最后一个等待节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// ㈠ 添加一个 Node 至等待队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>        Node t = lastWaiter;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>            unlinkCancelledWaiters();<br>            t = lastWaiter;<br>        &#125;<br>        <span class="hljs-comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span><br>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>            firstWaiter = node;<br>        <span class="hljs-keyword">else</span><br>            t.nextWaiter = node;<br>        lastWaiter = node;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <span class="hljs-comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 已经是尾节点了</span><br>            <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) &#123;<br>                lastWaiter = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (<br>            <span class="hljs-comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span><br>                !transferForSignal(first) &amp;&amp;<br>                        <span class="hljs-comment">// 队列还有节点</span><br>                        (first = firstWaiter) != <span class="hljs-keyword">null</span><br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-comment">// 设置当前node状态为0（因为处在队列末尾），如果状态已经不是 Node.CONDITION, 说明被取消了</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 加入 AQS 队列尾部</span><br>        Node p = enq(node);<br>        <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>        <span class="hljs-keyword">if</span> (<br>            <span class="hljs-comment">// 插入节点的上一个节点被取消</span><br>                ws &gt; <span class="hljs-number">0</span> ||<br>                        <span class="hljs-comment">// 插入节点的上一个节点不能设置状态为 Node.SIGNAL</span><br>                        !compareAndSetWaitStatus(p, ws, Node.SIGNAL)<br>        ) &#123;<br>            <span class="hljs-comment">// unpark 取消阻塞, 让线程重新同步状态</span><br>            LockSupport.unpark(node.thread);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><span class="hljs-comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        Node next = first.nextWaiter;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        transferForSignal(first);<br>        first = next;<br>    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);<br>&#125;<br><br>    <span class="hljs-comment">// ㈡</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果没有持有锁，会抛出异常</span><br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        Node first = firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>            doSignal(first);<br>    &#125;<br>    <span class="hljs-comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        Node first = firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>            doSignalAll(first);<br>    &#125;<br>    <span class="hljs-comment">// 不可打断等待 - 直到被唤醒</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        Node node = addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁, 见 ㈣</span><br>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// park 阻塞</span><br>            LockSupport.park(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-comment">// 如果被打断, 仅设置打断状态</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted)<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-comment">// 外部类方法, 方便阅读, 放在此处</span><br>    <span class="hljs-comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放，获取state，然后把它全部减掉，以全部释放</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">int</span> savedState = getState();<br>            <span class="hljs-comment">// 唤醒等待队列队列中的下一个节点</span><br>            <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">return</span> savedState;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                node.waitStatus = Node.CANCELLED;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 打断模式 - 在退出等待时重新设置打断状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 打断模式 - 在退出等待时抛出异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断打断模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>                <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ㈤ 应用打断模式</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>            selfInterrupt();<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        Node node = addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁</span><br>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// park 阻塞              </span><br>            LockSupport.park(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>            unlinkCancelledWaiters();<br>        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>        <span class="hljs-comment">// 添加一个 Node 至等待队列, 见 ㈠</span><br>        Node node = addConditionWaiter();<br>        <span class="hljs-comment">// 释放节点持有的锁</span><br>        <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>        <span class="hljs-comment">// 获得最后期限</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<br>        <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            <span class="hljs-comment">// 已超时, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>                transferAfterCancelledWait(node);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span><br>            <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>                LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);<br>            <span class="hljs-comment">// 如果被打断, 退出等待队列</span><br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            nanosTimeout = deadline - System.nanoTime();<br>        &#125;<br>        <span class="hljs-comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)<br>            unlinkCancelledWaiters();<br>        <span class="hljs-comment">// 应用打断模式, 见 ㈤</span><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>        <span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-comment">// 工具方法 省略 ...</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程中篇 - (线程池、ThreadPoolExecutor、ScheduledExecutorService、Fork/Join)</title>
    <link href="/2021/12/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%AF%87-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81ThreadPoolExecutor%E3%80%81ScheduledExecutorService%E3%80%81Fork-Join/"/>
    <url>/2021/12/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%AF%87-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81ThreadPoolExecutor%E3%80%81ScheduledExecutorService%E3%80%81Fork-Join/</url>
    
    <content type="html"><![CDATA[<h2 id="一、共享模型值工具"><a href="#一、共享模型值工具" class="headerlink" title="一、共享模型值工具"></a>一、共享模型值工具</h2><h3 id="1-线程池（重点）"><a href="#1-线程池（重点）" class="headerlink" title="1.线程池（重点）"></a>1.线程池（重点）</h3><ul><li>池化技术有很多，比如线程池、数据库连接池、HTTP连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</li></ul><p>线程池提供了一种限制和管理资源（包括执行一个任务）。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p><strong>线程池的好处</strong></p><ul><li><code>降低资源消耗。</code><strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</strong>（创建的线程，实际最后要和操作系统的线程做映射，很消耗资源）</li><li><code>提高响应速度。</code><strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</strong></li><li><code>提高线程的可管理性。</code><strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</strong></li></ul><h4 id="1-1自定义一个简单的线程池"><a href="#1-1自定义一个简单的线程池" class="headerlink" title="1.1自定义一个简单的线程池"></a>1.1自定义一个简单的线程池</h4><p><strong>图解</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/11a58fc2d33881fcdf40e1980ca56cdb.png"></p><ul><li>阻塞队列中维护了由主线程（或者其他线程）所产生的任务</li><li>主线程类似于生产者，产生任务并放入阻塞队列中</li><li>线程池类似于消费者，得到阻塞队列中已有的任务并执行</li></ul><p>自定义线程池的实现步骤</p><ul><li>步骤1：自定义拒绝策略接口</li><li>步骤2：自定义任务阻塞队列</li><li>步骤3：自定义线程池</li><li>步骤4：测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 自定义一个简单的线程池</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/30 20:47</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPool</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadPool threadPool = <span class="hljs-keyword">new</span> ThreadPool(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> RejectPolicy&lt;Runnable&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockingQueue&lt;Runnable&gt; queue, Runnable task)</span> </span>&#123;<br>                <span class="hljs-comment">// 拒绝策略</span><br>                <span class="hljs-comment">// 1、死等</span><br>                <span class="hljs-comment">// queue.put(task);</span><br><br>                <span class="hljs-comment">// 2、带超时等待</span><br>                queue.offer(task, <span class="hljs-number">2000</span>, TimeUnit.MILLISECONDS);<br><br>                <span class="hljs-comment">// 3、让调用者放弃任务执行</span><br>                <span class="hljs-comment">// log.debug(&quot;放弃-&#123;&#125;&quot;, task);</span><br><br>                <span class="hljs-comment">// 4、让调用者抛弃异常</span><br>                <span class="hljs-comment">// throw new RuntimeException(&quot;任务执行失败&quot; + task);</span><br><br>                <span class="hljs-comment">// 5、让调用者自己执行任务</span><br>                <span class="hljs-comment">// task.run();</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 创建5个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = i;<br>            threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestPool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br><br>    <span class="hljs-comment">// 阻塞任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> coreSize;<br><br>    <span class="hljs-comment">// 获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timeout;<br><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-comment">// 拒绝策略</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> coreSize, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit, <span class="hljs-keyword">int</span> queueCapacity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.coreSize = coreSize;<br>        <span class="hljs-keyword">this</span>.timeout = timeout;<br>        <span class="hljs-keyword">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-keyword">this</span>.taskQueue = <span class="hljs-keyword">new</span> BlockingQueue&lt;&gt;(queueCapacity);<br>        <span class="hljs-keyword">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-comment">// 当任务没有超过线程数, 说明当前worker线程可以消费这些任务, 不用将任务加入到阻塞队列中</span><br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                Worker worker = <span class="hljs-keyword">new</span> Worker(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker &#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// taskQueue.put(task); // 这一种死等</span><br>                <span class="hljs-comment">// 拒绝策略</span><br>                <span class="hljs-comment">// 1、死等</span><br>                <span class="hljs-comment">// 2、带超时等待</span><br>                <span class="hljs-comment">// 3、让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4、让调用者抛弃异常</span><br>                <span class="hljs-comment">// 5、让调用者自己执行任务</span><br>                taskQueue.tryPut(rejectPolicy, task);<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// 1): 当task不为空, 执行任务</span><br>            <span class="hljs-comment">// 2): 当task执行完毕, 从阻塞队列中获取任务并执行</span><br>            <span class="hljs-comment">//while (task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 将线程集合中的线程移除</span><br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker被移除 &#123;&#125;&quot;</span>, <span class="hljs-keyword">this</span>);<br>                workers.remove(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于存放任务的阻塞队列</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; Runnable, 任务抽象为Runnable</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestPool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 1、任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>    <span class="hljs-comment">// 2、锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-comment">// 3、生产者的条件变量 (当阻塞队列塞满任务的时候, 没有空间, 此时进入条件变量中等待)</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">// 4、消费者的条件变量 (当没有任务可以消费的时候, 进入条件变量中等待)</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet = lock.newCondition();<br><br>    <span class="hljs-comment">// 5、阻塞队列的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 从阻塞队列中获取任务, 如果没有任务, 会等待指定的时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将timeout统一转换为纳秒</span><br>            <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 表示超时, 无需等待, 直接返回null</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 返回值的时间(剩余时间) = 等待时间 - 经过时间 所以不存在虚假唤醒(时间还没等够就被唤醒,然后又从新等待相同时间)</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            T t = queue.removeFirst();<br>            fullWaitSet.signal(); <span class="hljs-comment">// 唤醒生产者进行生产, 此时阻塞队列没有满</span><br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从阻塞队列中获取任务, 如果没有任务,会一直等待</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 阻塞队列是否为空</span><br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-comment">// 进入消费者的条件变量中等待,此时没有任务供消费</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 阻塞队列不为空, 获取队列头部任务</span><br>            T t = queue.removeFirst();<br>            fullWaitSet.signal(); <span class="hljs-comment">// 唤醒生产者进行生产, 此时阻塞队列没有满</span><br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 往阻塞队列中添加任务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 阻塞队列是否满了</span><br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待进入阻塞队列...&quot;</span>);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addLast(task);<br>            log.debug(<span class="hljs-string">&quot;加入任务阻塞队列 &#123;&#125;&quot;</span>, task);<br>            emptyWaitSet.signal(); <span class="hljs-comment">// 此时阻塞队列中有任务了, 唤醒消费者进行消费任务</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 往阻塞队列中添加任务(带超时)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(T task, <span class="hljs-keyword">long</span> timeout, TimeUnit timeUnit)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> nanos = timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待进入阻塞队列 &#123;&#125;...&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务阻塞队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal(); <span class="hljs-comment">// 此时阻塞队列中有任务了, 唤醒消费者进行消费任务</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取队列大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断队列是否满</span><br>            <span class="hljs-keyword">if</span> (queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-keyword">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 有空闲</span><br>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现了一个简单的线程池</strong></p><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了生产者消费者模式</li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用<strong>任务对象（Runnable Callable）</strong>的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h4 id="1-2、ThreadPoolExecutor"><a href="#1-2、ThreadPoolExecutor" class="headerlink" title="1.2、ThreadPoolExecutor"></a>1.2、ThreadPoolExecutor</h4><h5 id="1-2-1-线程池的继承关系"><a href="#1-2-1-线程池的继承关系" class="headerlink" title="1.2.1 线程池的继承关系"></a>1.2.1 线程池的继承关系</h5><p><img src="https://img-blog.csdnimg.cn/20210102231106611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h5 id="1-2-2Executor框架结构：主要由三大部分组成"><a href="#1-2-2Executor框架结构：主要由三大部分组成" class="headerlink" title="1.2.2Executor框架结构：主要由三大部分组成"></a>1.2.2Executor框架结构：主要由三大部分组成</h5><ul><li><p>任务类（<code>Runnable</code>/<code>Callable</code>）</p><ul><li>执行任务需要实现的Runnable接口或Callable接口。Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</li></ul></li><li><p>任务的执行（<code>Executor</code>）</p><ul><li>如上图所示，包括任务执行机制的核心接口<strong>Executor</strong>，以及继承自Executor接口的ExecutorService接口。<strong>ThreadPoolExecutor</strong>和<strong>ScheduledThreadPoolExecutor这两个关键类实现了ExecutorService接口</strong></li><li>这里有很多底层的关系，但是，实际上我们需要更多关注的是<strong>ThreadPoolExecutor</strong>这个类，它在我们实际使用线程池的过程中，使用频率很高</li></ul></li><li><p>异步计算的结果（<code>Future</code>）</p><ul><li><p>Future接口以及Future接口的实现类FutureTask类都可以代表异步计算的结果。</p></li><li><p>当把Runnable接口或Callable接口的实现类提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行（调用 <code>submit()</code> 方法时会返回一个 <code>FutureTask</code>对象）</p><ul><li><p>Future和join方法类似，Future的get方法需要等待线程执行完毕，才可以获取的线程的执行结果。也称之为<code>保护性暂停</code></p><p><img src="https://img-blog.csdnimg.cn/20210102232801152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p></li></ul></li></ul></li></ul><h5 id="1-2-3-Executor框架的使用示意图"><a href="#1-2-3-Executor框架的使用示意图" class="headerlink" title="1.2.3 Executor框架的使用示意图"></a>1.2.3 Executor框架的使用示意图</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png"></p><ol><li>主线程首先要创建实现<strong>Runnable或者Callable接口</strong>的任务对象</li><li>把创建完成的实现<strong>Runnable/Callable接口的对象</strong>直接交给<strong>ExecutorService</strong>执行<ul><li><code>ExecutorService.execute（Runnable command）</code></li><li><code>ExecutorService.submit（Runnable task）</code></li><li><code>ExecutorService.submit（Callable &lt;T&gt; task）</code></li></ul></li><li>如果执行ExecutorService.submit（…），ExecutorService将返回一个<code>实现Future接口的对象</code><ul><li>（刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask</code> 对象）</li></ul></li><li>最后，<strong>主线程可以执行Future Task.get()方法来等待任务执行完成。</strong>主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行</li></ol><h4 id="1-3-线程池状态"><a href="#1-3-线程池状态" class="headerlink" title="1.3 线程池状态"></a>1.3 线程池状态</h4><ul><li>ThreadPoolExecutor使用int的高3位来表示线程池状态，低29位表示线程数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程池状态</span><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-comment">// RUNNING 高3位为111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// SHUTDOWN 高3位为000</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 001</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 010</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// 高3位 011</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">状态名称</th><th align="center">高3位的值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">111</td><td align="center">接受新任务，同时处理任务队列中的任务</td></tr><tr><td align="center">SHUTDOWN</td><td align="center">000</td><td align="center">不接受新任务，但是处理任务队列中的任务</td></tr><tr><td align="center">STOP</td><td align="center">001</td><td align="center">中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td align="center">TIDYING</td><td align="center">010</td><td align="center">任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td align="center">TERMINATED</td><td align="center">011</td><td align="center">终结状态</td></tr></tbody></table><ul><li>从数字上比较（第一位是符号位），<code>TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</code>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></li><li>使用一个数来表示两个值的主要原因是： <strong>可以通过一次CAS同时更改两个属性的值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">// 并不是所有平台的int都是32位。</span><br><span class="hljs-comment">// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="hljs-comment">// 高3位为0，剩余位数全为1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="hljs-comment">// CAPACITY 的高3位为 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>获取线程池状态、线程数量以及合并两个值的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-comment">// 获取运行状态</span><br><span class="hljs-comment">// 该操作会让除高3位以外的数全部变为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><br><span class="hljs-comment">// 获取运行线程数</span><br><span class="hljs-comment">// 该操作会让高3位为0</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><br><span class="hljs-comment">// 计算ctl新值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p>这些信息存储在一个原子变量ctl中，目的是将线程池状态与线程个数合二为一，这样就可以用一次cas原子操作进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// c 为旧值， ctlOf 返回结果为新值</span><br>ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));<br><br><span class="hljs-comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h4 id="线程池的属性"><a href="#线程池的属性" class="headerlink" title="线程池的属性"></a>线程池的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 工作线程，内部封装了Thread</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br><span class="hljs-comment">// 锁</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br><span class="hljs-comment">//  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210102234631532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h4 id="1-4构造方法及参数"><a href="#1-4构造方法及参数" class="headerlink" title="1.4构造方法及参数"></a>1.4构造方法及参数</h4><ul><li>ThreadPoolExecutor最全的构造方法</li><li>也是构造自定义线程池的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><p><strong>参数解释</strong></p><ul><li><strong>corePoolSize：</strong> 核心线程数</li><li><strong>maximumPoolSize：</strong> 最大线程数<ul><li>maximumPoolSize - corePoolSize = 救急线程数</li><li>注意： 救济线程在 <strong>没有空闲的核心线程</strong> 和 <strong>任务队列满了</strong> 的情况才使用救济线程</li></ul></li><li><strong>keepAliveTime：</strong> 救济线程空闲时最大生存时间（核心线程可以一直运行）</li><li><strong>unit：</strong> 时间单位（针对救急线程）</li><li><strong>workQueue：</strong> 阻塞队列（存放任务）<ul><li>有界阻塞队列ArrayBlockingQueue</li><li>无界阻塞队列LinkedBlockingQueue</li><li>最多只有一个同步元素的SynchronousQueue</li><li>优先队列PriorityBlockingQueue</li></ul></li><li><strong>threadFactory：</strong>线程工厂（给线程取名字）</li><li><strong>handler：</strong> 拒绝策略</li></ul><p><strong>工作方式</strong></p><p><img src="https://img-blog.csdnimg.cn/20210202214622633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li>当一个任务传给线程池以后，可能有以下几种可能<ul><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务<ul><li>救济线程用完以后，超过生存时间（keepAliveTime）后会被释放</li></ul></li><li>任务总数大于了最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒绝策略</li></ul></li></ul><p><strong>拒绝策略</strong></p><ul><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9c9e1f25573ca20f44ac080a5f6540c5.png"></p><p>口诀法：<strong>拒中丢老调</strong>（线程池拒绝策略：中止策略、丢弃策略、弃老策略、调用者运行策略）</p><p>简单回答：</p><ol><li>中止策略：无特殊场景</li><li>丢弃策略：无关紧要的任务（博客阅读量）</li><li>弃老策略：发布信息</li><li>调用者运行策略：不允许失败场景（对性能要求不高、并发量较小）</li></ol><ul><li><p><code>CallerRunsPolicy 调用者运行策略</code>：由调用线程处理该任务。</p><blockquote><ul><li>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。</li><li>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</li></ul></blockquote></li></ul><blockquote><ol><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前<code>4 种实现</code>，其它著名框架也提供了实现<ol><li>ThreadPoolExecutor.AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务</li><li>ThreadPoolExecutor.DiscardPolicy 放弃本次任务</li><li>ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ol></li><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger threadId = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 手动创建线程池</span><br>        <span class="hljs-comment">// 创建有界阻塞队列, 用来存放任务对象</span><br>        ArrayBlockingQueue&lt;Runnable&gt; runnable = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 创建线程工厂: 主要给线程起名字</span><br>        ThreadFactory threadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;guizy_thread&quot;</span> + threadId.getAndIncrement());<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 手动创建线程池</span><br>        <span class="hljs-comment">// 拒绝策略采用默认策略</span><br>        ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS, runnable, threadFactory);<br><br><span class="hljs-comment">// 执行20个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    System.out.println(Thread.currentThread());<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210103001214433.png"></p><p>根据这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p><h4 id="1-5-newFixedThreadPool（固定大小线程池）"><a href="#1-5-newFixedThreadPool（固定大小线程池）" class="headerlink" title="1.5 newFixedThreadPool（固定大小线程池）"></a>1.5 newFixedThreadPool（固定大小线程池）</h4><ul><li>这个是<code>Executors类</code>提供的工厂方法来创建线程池！<code>Executors</code> 是Executor 框架的工具类！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFixedThreadPool</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 自定义线程工厂</span><br>      ThreadFactory factory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;<br>         AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br><br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;myThread_&quot;</span> + atomicInteger.getAndIncrement());<br>         &#125;<br>      &#125;;<br><br>      <span class="hljs-comment">// 创建核心线程数量为2的线程池</span><br>      <span class="hljs-comment">// 通过 ThreadFactory可以给线程添加名字</span><br><br>      ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">2</span>, factory);<br><br>      <span class="hljs-comment">// 任务</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(Thread.currentThread().getName());<br>            System.out.println(<span class="hljs-string">&quot;this is fixedThreadPool&quot;</span>);<br>         &#125;<br>      &#125;;<br>      <br>      executorService.execute(runnable);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>固定大小的线程池可以传入两个参数</p><ul><li>核心线程数： <strong>nThreads</strong></li><li>线程工厂： <strong>threadFactory</strong></li></ul><p>内部调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ol><li>核心线程数 == 最大线程数（没有救急线程数被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li><li><strong>适用于任务量已知，相对耗时的任务</strong></li></ol><h4 id="1-6-newCachedThreadPool（带缓冲线程池）"><a href="#1-6-newCachedThreadPool（带缓冲线程池）" class="headerlink" title="1.6 newCachedThreadPool（带缓冲线程池）"></a>1.6 newCachedThreadPool（带缓冲线程池）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService executorService = Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p>内部构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li> <strong>没有核心线程</strong> 最大线程数为<code>Integer.MAX_VALUE</code>，所有创建的线程都是救济线程（可以无限创建），空闲时生存时间为60s</li><li> 阻塞队列使用的是 <strong>SynchronousQueue</strong></li><li>SynchronousQueue是一种特殊的队列<ul><li><strong>没有容量；</strong> 没有线程来取是放不进去的</li><li>只有当线程取任务时，才会将任务放入该阻塞队列中</li></ul></li><li> <strong>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1min后释放线程。适合任务数比较密集，但每个任务执行时间较短的情况</strong></li></ul><h4 id="1-7-newSingleThreadExecutor（单线程线程池）"><a href="#1-7-newSingleThreadExecutor（单线程线程池）" class="headerlink" title="1.7 newSingleThreadExecutor（单线程线程池）"></a>1.7 newSingleThreadExecutor（单线程线程池）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ol><li><strong>希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。</strong>任务执行完毕，这唯一的线程也不会被释放</li><li>区别：<ol><li><code>和自己创建单线程执行任务的区别</code>： <strong>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而newSingleThreadExecutor线程池还会新建一个线程，保证池的正常工作</strong></li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ol><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li></ol></li><li><code>和Executors.newFixedThreadPool(1) 初始时为1时的区别</code>：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ol></li></ol><h4 id="Executors-返回线程池对象的弊端如下-重点"><a href="#Executors-返回线程池对象的弊端如下-重点" class="headerlink" title="Executors 返回线程池对象的弊端如下 (重点)"></a>Executors 返回线程池对象的弊端如下 (<code>重点</code>)</h4><blockquote><p><code>注意:</code> Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE (无界阻塞队列),可能堆积大量的请求，从而导致 OOM。</strong></li><li><strong>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</strong></li></ul><p>建议使用<code>ThreadPoolExecutor</code>来创建线程</p></blockquote><p>避免上面的措施 : <strong>使用有界队列，控制线程创建数量。</strong></p><p>除了避免OOM的原意之外，不推荐使用Executors提供的两种快捷的线程池的原因还有：</p><ol><li><strong>实际使用中需要根据自己机器的性能，业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等</strong></li><li>我们应该显示给我们的线程池命名，这样有助于我们定位问题</li></ol><h4 id="1-8执行-提交任务-execute-submit"><a href="#1-8执行-提交任务-execute-submit" class="headerlink" title="1.8执行/提交任务 execute/submit"></a>1.8执行/提交任务 execute/submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br><br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span><br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="hljs-keyword">throws</span> InterruptedException;<br> <br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br></code></pre></td></tr></table></figure><p><strong>execute()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">execute(Runnable command)<br></code></pre></td></tr></table></figure><ul><li>传入一个Runnable对象、执行其中的run方法</li></ul><p>源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>    <span class="hljs-comment">// 获取ctl</span><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <br>    <span class="hljs-comment">// 判断当前启用的线程数是否小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 为该任务分配线程</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-comment">// 分配成功就返回</span><br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 分配失败再次获取ctl</span><br>        c = ctl.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分配和信息线程失败以后</span><br>    <span class="hljs-comment">// 如果池状态为RUNNING并且插入到任务队列成功</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <br>        <span class="hljs-comment">// 双重检测，可能在添加后线程池状态变为了非RUNNING</span><br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <br>        <span class="hljs-comment">// 如果池状态为非RUNNING，则不会执行新来的任务</span><br>        <span class="hljs-comment">// 将该任务从阻塞队列中移除</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            <span class="hljs-comment">// 调用拒绝策略，拒绝该任务的执行</span><br>            reject(command);<br>        <br>        <span class="hljs-comment">// 如果没有正在运行的线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 就创建新线程来执行该任务</span><br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果添加失败了（任务队列已满），就调用拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中调用了 **addWoker()**方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-comment">// 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-comment">// 创建新线程失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获得当前工作线程数</span><br>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>            <span class="hljs-comment">// 参数中 core 为true</span><br>            <span class="hljs-comment">// CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span><br>            <span class="hljs-comment">// 如果工作线程数大于了核心线程数，则创建失败</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-comment">// 通过CAS操作改变c的值</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-comment">// 更改成功就跳出多重循环，且不再运行循环</span><br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 更改失败，重新获取ctl的值</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 跳出多重循环，且重新进入循环</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于标记work中的任务是否成功执行</span><br>    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 用于标记worker是否成功加入了线程池中</span><br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建新线程来执行任务</span><br>        w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>        <span class="hljs-keyword">final</span> Thread t = w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            <span class="hljs-comment">// 加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-comment">// 加锁的同时再次检测</span><br>                <span class="hljs-comment">// 避免在释放锁之前调用了shut down</span><br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    <span class="hljs-comment">// 将线程添加到线程池中</span><br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    <span class="hljs-comment">// 添加成功标志位变为true</span><br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 如果worker成功加入了线程池，就执行其中的任务</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                <span class="hljs-comment">// 启动成功</span><br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果执行失败</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            <span class="hljs-comment">// 调用添加失败的函数</span><br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>submit()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span><br></code></pre></td></tr></table></figure><ul><li>传入一个Callable对象，用Future来 <strong>捕获返回值</strong></li></ul><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过submit执行Callable中的call方法</span><br><span class="hljs-comment">// 通过Future来捕获返回值</span><br>Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;String&gt;() &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello submit&quot;</span>;<br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 查看捕获的返回值</span><br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><h4 id="1-9关闭线程池-shutdown"><a href="#1-9关闭线程池-shutdown" class="headerlink" title="1.9关闭线程池 shutdown()"></a>1.9关闭线程池 shutdown()</h4><p><strong>shutdown()</strong></p><ul><li><strong>将线程池的状态改为SHUTDOWN</strong></li><li><strong>不再接受新任务，但是会将阻塞队列中的任务执行完</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 SHUTDOWN</span><br><span class="hljs-comment">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <br>        <span class="hljs-comment">// 修改线程池状态为 SHUTDOWN</span><br>        advanceRunState(SHUTDOWN);<br>        <br>  <span class="hljs-comment">// 中断空闲线程（没有执行任务的线程）</span><br>        <span class="hljs-comment">// Idle：空闲的</span><br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，不一定成功</span><br>    <span class="hljs-comment">// </span><br>    tryTerminate();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryTerminate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">// 终结失败的条件</span><br>        <span class="hljs-comment">// 线程池状态为RUNNING</span><br>        <span class="hljs-comment">// 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span><br>        <span class="hljs-comment">// 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">// 如果活跃线程数不为0</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            <span class="hljs-comment">// 中断空闲线程</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处于可以终结的状态</span><br>            <span class="hljs-comment">// 通过CAS将线程池状态改为TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 通过CAS将线程池状态改为TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shutdownNow()</strong></p><ul><li><strong>将线程池的状态改为STOP</strong></li><li><strong>不再接受新任务，也不会在执行阻塞队列中的任务</strong></li><li>会将阻塞队列中未执行的任务返回给调用者</li><li>并用interrupt的方式中断正在执行的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将线程池的状态改为 STOP</span><br><span class="hljs-comment">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><br><span class="hljs-comment">* 会将阻塞队列中未执行的任务返回给调用者</span><br><span class="hljs-comment">* 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <br>        <span class="hljs-comment">// 修改状态为STOP，不执行任何任务</span><br>        advanceRunState(STOP);<br>        <br>        <span class="hljs-comment">// 中断所有线程</span><br>        interruptWorkers();<br>        <br>        <span class="hljs-comment">// 将未执行的任务从队列中移除，然后返回给调用者</span><br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 尝试终结，一定会成功，因为阻塞队列为空了</span><br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitTermination</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure><h3 id="2-异步模式之工作线程"><a href="#2-异步模式之工作线程" class="headerlink" title="2.异步模式之工作线程"></a>2.异步模式之工作线程</h3><p><strong>定义</strong></p><ul><li><code>让有限的工作线程（Worker thread）来轮流异步处理无限多的任务。</code> 也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式</li><li>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</li></ul><p>注意： <strong>不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</strong></p><ul><li>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</li></ul><p><strong>饥饿</strong></p><ul><li>固定大小线程池会有饥饿现象</li></ul><ol><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作<ol><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ol></li><li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好; 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li></ol><p><strong>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，不同任务类型，采用不同的线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestDeadLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStarvation</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="hljs-string">&quot;地三鲜&quot;</span>, <span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;辣子鸡丁&quot;</span>, <span class="hljs-string">&quot;烤鸡翅&quot;</span>);<br>    <span class="hljs-keyword">static</span> Random RANDOM = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">cooking</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService waiterPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        ExecutorService cookPool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        waiterPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                <span class="hljs-keyword">return</span> cooking();<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程池中线程设置多少为好"><a href="#线程池中线程设置多少为好" class="headerlink" title="线程池中线程设置多少为好?"></a><code>线程池中线程设置多少为好?</code></h4><p>过小会导致程序不能充分的利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存</p><ol><li><p><strong>CPU 密集型运算</strong></p><p>通常采用 <strong>cpu 核数 + 1</strong> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p></li><li><p><strong>I/O 密集型运算</strong></p><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><ol><li><p>经验公式如下：线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间<br>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% / 50% = 8<br>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p>4 * 100% * 100% / 10% = 40</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210202220401865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p></li></ol><h4 id="2-1任务调度线程池ScheduleExecutorService（重点）"><a href="#2-1任务调度线程池ScheduleExecutorService（重点）" class="headerlink" title="2.1任务调度线程池ScheduleExecutorService（重点）"></a>2.1任务调度线程池ScheduleExecutorService（重点）</h4><ul><li>在『任务调度线程池』功能加入之前，可以使用<code>java.util.Timer</code>来实现定时功能，Timer的优点在于简单易用，但由于所有任务都是由<code>同一个线程</code>来调度，因此所有任务都是<code>串行</code>执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestTimer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTimer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Timer timer = <span class="hljs-keyword">new</span> Timer();<br>        TimerTask task1 = <span class="hljs-keyword">new</span> TimerTask() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;task 1&quot;</span>);<br>                Sleeper.sleep(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;;<br><br>        TimerTask task2 = <span class="hljs-keyword">new</span> TimerTask() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;task 2&quot;</span>);<br>            &#125;<br>        &#125;;<br><span class="hljs-comment">// 使用timer添加两个任务, 希望他们都在1s后执行</span><br><span class="hljs-comment">// 由于timer内只有一个线程来执行队列中的任务, 所以task2必须等待task1执行完成才能执行</span><br>        timer.schedule(task1, <span class="hljs-number">1000</span>);<br>        timer.schedule(task2, <span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br><br>08:<span class="hljs-number">21</span>:<span class="hljs-number">17.548</span> guizy.TestTimer [Timer-<span class="hljs-number">0</span>] - task <span class="hljs-number">1</span><br>08:<span class="hljs-number">21</span>:<span class="hljs-number">19.553</span> guizy.TestTimer [Timer-<span class="hljs-number">0</span>] - task <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>使用ScheduleExecutorService</p><ul><li>ScheduleExecutorService中schedule方法的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTimer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>        executor.schedule(() -&gt; System.out.println(<span class="hljs-string">&quot;任务1, 执行时间:&quot;</span> + <span class="hljs-keyword">new</span> Date()), <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br>        executor.schedule(() -&gt; System.out.println(<span class="hljs-string">&quot;任务2, 执行时间:&quot;</span> + <span class="hljs-keyword">new</span> Date()), <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br><br>任务<span class="hljs-number">1</span>, 执行时间:Sun Jan <span class="hljs-number">03</span> 08:<span class="hljs-number">53</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2021</span><br>任务<span class="hljs-number">2</span>, 执行时间:Sun Jan <span class="hljs-number">03</span> 08:<span class="hljs-number">53</span>:<span class="hljs-number">54</span> CST <span class="hljs-number">2021</span><br></code></pre></td></tr></table></figure><ul><li><strong>ScheduledExecutorService 中 scheduleAtFixedRate方法的使用</strong></li><li>睡眠时间 &gt; 速率, 按睡眠时间打印</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTimer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;start....&quot;</span>);<br>        <span class="hljs-comment">// 延迟1s后, 按1s的速率打印running</span><br>        executor.scheduleAtFixedRate(() -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br><br>08:<span class="hljs-number">51</span>:<span class="hljs-number">59.930</span> guizy.TestTimer [main] - start....<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">01.050</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">02.049</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">03.045</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">04.046</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">05.045</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">52</span>:<span class="hljs-number">06.047</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTimer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;start....&quot;</span>);<br>        <span class="hljs-comment">// 延迟1s后, 按1s的速率打印running</span><br>        executor.scheduleAtFixedRate(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 睡眠时间 &gt; 速率, 按睡眠时间打印</span><br>08:<span class="hljs-number">54</span>:<span class="hljs-number">58.567</span> guizy.TestTimer [main] - start....<br>08:<span class="hljs-number">54</span>:<span class="hljs-number">59.675</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">55</span>:<span class="hljs-number">01.684</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">55</span>:<span class="hljs-number">03.685</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">55</span>:<span class="hljs-number">05.690</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br></code></pre></td></tr></table></figure><ul><li>ScheduledExecutorService 中scheduleWithFixedDelay方法的使用</li><li>睡眠时间 + 速率时间, 为打印的间隔时间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTimer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;start....&quot;</span>);<br>        <span class="hljs-comment">// 延迟1s后, 按1s的速率打印running</span><br>        executor.scheduleWithFixedDelay(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br><br>08:<span class="hljs-number">56</span>:<span class="hljs-number">22.581</span> guizy.TestTimer [main] - start....<br>08:<span class="hljs-number">56</span>:<span class="hljs-number">23.674</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">56</span>:<span class="hljs-number">26.679</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">56</span>:<span class="hljs-number">29.680</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br>08:<span class="hljs-number">56</span>:<span class="hljs-number">32.689</span> guizy.TestTimer [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] - running<br></code></pre></td></tr></table></figure><ul><li>整个线程池表现为：线程数固定，任务多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务</li></ul><p>eg：如何让每周四18：00：00定时执行任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSchedule</span> </span>&#123;<br><br>    <span class="hljs-comment">// 如何让每周四 18:00:00 定时执行任务？</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//  获取当前时间</span><br>        LocalDateTime now = LocalDateTime.now();<br>        System.out.println(now);<br>        <span class="hljs-comment">// 获取周四时间</span><br>        LocalDateTime time = now.withHour(<span class="hljs-number">18</span>).withMinute(<span class="hljs-number">0</span>).withSecond(<span class="hljs-number">0</span>).withNano(<span class="hljs-number">0</span>).with(DayOfWeek.THURSDAY);<br>        <span class="hljs-comment">// 如果 当前时间 &gt; 本周周四，必须找到下周周四</span><br>        <span class="hljs-keyword">if</span>(now.compareTo(time) &gt; <span class="hljs-number">0</span>) &#123;<br>            time = time.plusWeeks(<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(time);<br>        <span class="hljs-comment">// initailDelay 代表当前时间和周四的时间差</span><br>        <span class="hljs-comment">// period 一周的间隔时间</span><br>        <span class="hljs-keyword">long</span> initailDelay = Duration.between(now, time).toMillis();<br>        <span class="hljs-keyword">long</span> period = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>;<br>        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        pool.scheduleAtFixedRate(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>        &#125;, initailDelay, period, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-正确处理执行任务异常"><a href="#2-2-正确处理执行任务异常" class="headerlink" title="2.2 正确处理执行任务异常"></a>2.2 正确处理执行任务异常</h4><ul><li>可以发现，如果线程池中的线程执行任务时， <strong>如果任务抛出了异常，默认是中断执行该任务而不是抛出异常或者打印异常信息</strong></li></ul><p>方法1： <strong>主动捉异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br> <span class="hljs-keyword">try</span> &#123;<br> log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br> &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br> log.error(<span class="hljs-string">&quot;error:&quot;</span>, e);<br> &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>方法2： <strong>使用future，错误信息都被封装进submit方法的返回方法中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;<br> log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;);<br>log.debug(<span class="hljs-string">&quot;result:&#123;&#125;&quot;</span>, f.get());<br></code></pre></td></tr></table></figure><h3 id="3-Tomcat线程池"><a href="#3-Tomcat线程池" class="headerlink" title="3.Tomcat线程池"></a>3.Tomcat线程池</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/68b780b8c314dc2ac18b537500b90f03.png"></p><ol><li>LimitLatch用来限流，可以控制最大连接个数，类似J.U.C中的 <strong>Semaphore</strong>后面再讲</li><li>Acceptor只负责【接收新的socket连接】</li><li>Poller只负责监听socket channel是否有【可读的I/O事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给Executor线程池处理</li><li>Executor线程池中的工作线程最终负责【处理请求】</li></ol><p>体现了不同的线程池做不同的工作</p><p>Tomcat线程池扩展了ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程达到maximumPoolSize，这时不会立刻抛RejectedExecutionException异常，而是再次尝试将任务放入队列，如果还失败，才抛出RejectedExecutionException异常</li></ul><p>源码 tomcat-7.0.42</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;<br>    submittedCount.incrementAndGet();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>            <span class="hljs-keyword">final</span> TaskQueue queue = (TaskQueue)<span class="hljs-keyword">super</span>.getQueue();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 使任务从新进入阻塞队列</span><br>                <span class="hljs-keyword">if</span> (!queue.force(command, timeout, unit)) &#123;<br>                    submittedCount.decrementAndGet();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Queue capacity is full.&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123;<br>                submittedCount.decrementAndGet();<br>                Thread.interrupted();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(x);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            submittedCount.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> rx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TaskQueue.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">force</span><span class="hljs-params">(Runnable o, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">if</span> ( parent.isShutdown() )<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<br>                <span class="hljs-string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span><br>        );<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.offer(o,timeout,unit); <span class="hljs-comment">//forces the item onto the queue, to be used if the task is rejected</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Connector配置</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f5273f7da471b4a4d24a241559f29492.png"></p><p>Executor线程配置</p><p>守护线程的意思就是线程会随着主线程的结束而结束</p><p><img src="https://img-blog.csdnimg.cn/20210205230254525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>可以看到该线程池实现的是一个无界的队列，所以说是不是执行任务的线程数大于了核心线程数，都会添加到阻塞队列中，那么救急线程是不是就不会用到呢，其实不是，分析如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210205225434672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>当添加新的任务时，如果提交的任务大于核心线程数小于最大线程数就创建救急线程，否则就加入任务队列中</p><ul><li>有点错误，<code>提交任务&lt;核心线程</code>, 应该直接交给核心线程执行。</li></ul><h3 id="4-Fork-Join（熟悉）"><a href="#4-Fork-Join（熟悉）" class="headerlink" title="4.Fork/Join（熟悉）"></a>4.Fork/Join（熟悉）</h3><p><strong>概念</strong></p><ol><li>Fork/Join是JDK1.7加入的新的线程池实现，它体现的是一种<code>分治思想</code>，适用于能够进行任务拆分的cpu密集型运算</li><li><strong>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。</strong> 跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</li><li><strong>Fork/Join在分治的基础上加入了多线程，</strong> 可以把每个任务的分解和合并不同的线程来完成，进一步提升了运算效率</li><li>Fork/Join默认会创建与cpu核心数大小相同的线程池</li></ol><p><strong>使用</strong></p><ul><li>提交给Fork/Join线程池的任务需要继承RecursiveTask（有返回值）或RecursiveAction（没有返回值）</li></ul><p>当调用fork，会重新执行compute方法，进行递归运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestForkJoin2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestForkJoin2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ForkJoinPool pool = <span class="hljs-keyword">new</span> ForkJoinPool(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> MyTask(<span class="hljs-number">5</span>)));<br><br>        <span class="hljs-comment">// new MyTask(5)  5+ new MyTask(4)  4 + new MyTask(3)  3 + new MyTask(2)  2 + new MyTask(1)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1~n 之间整数的和</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.MyTask&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        AddTask1 t1 = <span class="hljs-keyword">new</span> AddTask1(n - <span class="hljs-number">1</span>);<br>        t1.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br><br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-keyword">int</span> result = n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程上篇 - (Synchronized原理,LockSupport原理,ReentrantLock原理)</title>
    <link href="/2021/11/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A%E7%AF%87-Synchronized%E5%8E%9F%E7%90%86-LockSupport%E5%8E%9F%E7%90%86-ReentrantLock%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A%E7%AF%87-Synchronized%E5%8E%9F%E7%90%86-LockSupport%E5%8E%9F%E7%90%86-ReentrantLock%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这就开启了一个进程</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进行（例如笔记本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等）</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>一个线程之内可以分为一到多个线程</li><li>一个线程就是一个指令流，将指令流中的一条条指令已一定的顺序交给CPU执行。</li><li>Java中，线程作为小调度单位，进程作为资源分配的最小单位</li></ul><h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><ul><li>进程基本上相互独立，而线程存在于进程内，是进程的一个子集，进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul><li>进程间通信较为复杂 同一台计算机的进程通信称为IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li></ul></li><li>进程通信相对简单，因为它们共享进程内的内存，一个例子是多线程可以访问同一个共享变量线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h3 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h3><p>并发是一个CPU在不同的时间去不同线程中执行指令</p><p>并行是多个CPU同时处理不同的线程</p><ul><li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li></ul><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><h4 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h4><p>以调用方法的角度讲，如果</p><ul><li>需要等待结果返回才能继续运行的话就是<strong>同步</strong></li><li>不需要等待就是<strong>异步</strong></li></ul><p><strong>1）设计</strong></p><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，那么 cpu 只能等 5 秒，啥都不能做。</p><p><strong>2）结论</strong></p><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程<br>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程<br>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1） 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p><p>2）多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul><p>3）IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化</p><h2 id="二、Java线程"><a href="#二、Java线程" class="headerlink" title="二、Java线程"></a>二、Java线程</h2><h3 id="1-线程创建与运行"><a href="#1-线程创建与运行" class="headerlink" title="1.线程创建与运行"></a>1.线程创建与运行</h3><h4 id="方法1，使用Thread"><a href="#方法1，使用Thread" class="headerlink" title="方法1，使用Thread"></a>方法1，使用Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 匿名内部类方式创建 Thread</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="方法二，使用Runnable配合Thread（推荐）"><a href="#方法二，使用Runnable配合Thread（推荐）" class="headerlink" title="方法二，使用Runnable配合Thread（推荐）"></a>方法二，使用Runnable配合Thread（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 lambda 表达式，因为 Runnable 接口 </span><br>        <span class="hljs-comment">// 标注了 @FunctionalInterface 这个注解，表示是一个函数式接口，可以使用 lambda 表达式</span><br>        Runnable r = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="比较方法一与方法二："><a href="#比较方法一与方法二：" class="headerlink" title="比较方法一与方法二："></a>比较方法一与方法二：</h4><p>方法1是把线程和任务合并在了一起</p><p>方法2是把线程和任务分开了，用Runnable更容易与线程池等高级API配合，用Runnable让任务类脱离了Thread继承体系，更灵活</p><p>通过查看源码可以发现，方法二其实还是使用了Thread类中的run方法执行的</p><h4 id="方法三，Future-Task配合Thread"><a href="#方法三，Future-Task配合Thread" class="headerlink" title="方法三，Future Task配合Thread"></a>方法三，Future Task配合Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 使用 FutureTask 传入 Callable 接口方式创建</span><br>        FutureTask&lt;Integer&gt; future = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 休眠</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;);<br>        <span class="hljs-comment">// 2. 传入 future, 因为 FutureTask 这个类是实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(future, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 3. 获取返回结果时</span><br>        <span class="hljs-comment">// 当主线程获取 t1 线程的返回值时, 需要等 2 秒，此时主线程进入阻塞状态</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,  future.get());<br>    &#125;<br></code></pre></td></tr></table></figure><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br><span class="hljs-comment">// 取消任务</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><span class="hljs-comment">// 获取任务执行结果</span><br><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><span class="hljs-comment">// 获取任务执行结果，带有超时时间限制</span><br><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException,                             ExecutionException,  TimeoutException</span>;<br><span class="hljs-comment">// 判断任务是否已经取消</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 判断任务是否已经结束</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Future Task类是Future 接口和Runable接口的实现弥补runnable创建线程没有返回值的缺陷</p><h3 id="2-线程运行原理"><a href="#2-线程运行原理" class="headerlink" title="2.线程运行原理"></a>2.线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>拟机栈描述的是Java方法执行的内存模型：</p><p>每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</p><p>当java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，当方法执行完会来到栈帧中的方法出口地址位置，然后从栈中 pop 出栈帧。</p><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码</p><h5 id="被动原因"><a href="#被动原因" class="headerlink" title="被动原因"></a>被动原因</h5><ul><li>线程的cpu时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li></ul><h5 id="主动原因"><a href="#主动原因" class="headerlink" title="主动原因"></a>主动原因</h5><ul><li>线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p><h3 id="3-Thread的常见方法"><a href="#3-Thread的常见方法" class="headerlink" title="3.Thread的常见方法"></a>3.Thread的常见方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">static</th><th align="center">功能说明</th><th align="center">注意</th></tr></thead><tbody><tr><td align="center">start()</td><td align="center"></td><td align="center">启动一个新线程，在新线程中运行run方法中的代码</td><td align="center">start方法只是让线程进入就绪状态，里面代码不一定立刻运行，只有当CPU将时间片分给线程时，才能进入运行状态，执行代码。每个线程的start方法只能调用一次，调用多次就会出现  IllegalThreadStateException</td></tr><tr><td align="center">run()</td><td align="center"></td><td align="center">新线程启动会调用的方法</td><td align="center">如果在构造 Thread 对象时传递了 Runnable 参数， 则线程启动后会调用 Runnable 中的 run 方法， 否则默认不执行任何操作。 但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td align="center">join()</td><td align="center"></td><td align="center">等待线程运行结束</td><td align="center"></td></tr><tr><td align="center">join(long n)</td><td align="center"></td><td align="center">等待线程运行结束，最多等待n毫秒</td><td align="center"></td></tr><tr><td align="center">getId()</td><td align="center"></td><td align="center">获取线程长整型的 id</td><td align="center">id 唯一</td></tr><tr><td align="center">getName()</td><td align="center"></td><td align="center">获取线程名</td><td align="center"></td></tr><tr><td align="center">setName(String)</td><td align="center"></td><td align="center">修改线程名</td><td align="center"></td></tr><tr><td align="center">getPriority()</td><td align="center"></td><td align="center">获取线程优先级</td><td align="center"></td></tr><tr><td align="center">setPriority(int)</td><td align="center"></td><td align="center">修改线程优先级</td><td align="center">java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的几率</td></tr><tr><td align="center">getState()</td><td align="center"></td><td align="center">获取线程状态</td><td align="center">Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td></tr><tr><td align="center">isInterrupted()</td><td align="center"></td><td align="center">判断是否被打断</td><td align="center">不会清除 打断标记</td></tr><tr><td align="center">isAlive()</td><td align="center"></td><td align="center">线程是否存活（还没有运行完毕）</td><td align="center"></td></tr><tr><td align="center">interrupt()</td><td align="center">static</td><td align="center">打断线程</td><td align="center">会清除 打断标记</td></tr><tr><td align="center">currentThread()</td><td align="center">static</td><td align="center">获取当前正在执行的线程</td><td align="center"></td></tr><tr><td align="center">sleep(long n)</td><td align="center">static</td><td align="center">让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td><td align="center"></td></tr><tr><td align="center">yield()</td><td align="center">static</td><td align="center">提示线程调度器让出当前线程对CPU的使用</td><td align="center">主要是为了测试和调</td></tr></tbody></table><h4 id="1）start-VS-run"><a href="#1）start-VS-run" class="headerlink" title="1）start() VS run()"></a>1）start() VS run()</h4><p>直接调用run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running....&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 测试通过 Thread 类实例 t1 对象直接调用 run 方法</span><br>        t1.run();<br><br>        log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> [main] c.Code_05_Test - main running....<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> [main] c.Code_05_Test - main running...<br></code></pre></td></tr></table></figure><p>调用start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running....&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 测试通过 Thread 类实例 t1 对象直接调用 run 方法</span><br><span class="hljs-comment">//        t1.run();</span><br>        <span class="hljs-comment">// 调用 start 方法</span><br>        t1.start();<br><br>        log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">35</span> [main] c.Code_05_Test - main running...<br><span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">35</span> [t1] c.Code_05_Test - t1 running....<br></code></pre></td></tr></table></figure><p>发现两种结果是不一样的，使用 start 方式，CPU 会为创建的线程分配时间片，线程进入运行状态，然后线程调用 run 方法执行逻辑。直接使用 run 的方式，虽然会创建了线程，但是它是直接调用方法，而不是像 start 方式那样触发的，这个线程对象会处一直处在新建状态，从结果上也可以看出，run 方法是 main 线程调用，而不是 t1 线程。</p><h4 id="2）sleep-与-yield"><a href="#2）sleep-与-yield" class="headerlink" title="2）sleep() 与 yield()"></a>2）sleep() 与 yield()</h4><h5 id="sleep（使线程阻塞）"><a href="#sleep（使线程阻塞）" class="headerlink" title="sleep（使线程阻塞）"></a>sleep（使线程阻塞）</h5><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），可通过state()方法查看</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><h5 id="yield-让出当前线程"><a href="#yield-让出当前线程" class="headerlink" title="yield(让出当前线程)"></a>yield(让出当前线程)</h5><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p><h4 id="3）join-方法"><a href="#3）join-方法" class="headerlink" title="3）join() 方法"></a>3）join() 方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用t1.join()，则是主线程等待t1线程结束，join采用同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread();<br><span class="hljs-comment">//等待 t1 线程执行结束</span><br>t1.join();<br><span class="hljs-comment">// 最多等待 1000ms,如果 1000ms 内线程执行完毕，则会直接执行下面的语句，不会等够 1000ms</span><br>t1.join(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="4）interrupt-方法"><a href="#4）interrupt-方法" class="headerlink" title="4）interrupt()方法"></a>4）interrupt()方法</h4><h5 id="interrupt-打断线程有两种情况。如下"><a href="#interrupt-打断线程有两种情况。如下" class="headerlink" title="interrupt 打断线程有两种情况。如下"></a>interrupt 打断线程有两种情况。如下</h5><ul><li>如果一个线程在运行中被打断，打断标记会被置为true</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><h5 id="isInterrupted-与-interrupted-比较，如下："><a href="#isInterrupted-与-interrupted-比较，如下：" class="headerlink" title="isInterrupted() 与  interrupted() 比较，如下："></a>isInterrupted() 与  interrupted() 比较，如下：</h5><p>首先，isInterrupted 是实例方法，interrupted 是静态方法，它们的用处都是查看当前打断的状态，但是 isInterrupted 方法查看线程的时候，不会将打断标记清空，也就是置为 false，interrupted 查看线程打断状态后，会将打断标志置为 false，也就是清空打断标记，简单来说，interrupt() 方法类似于 setter 设置中断值，isInterrupted() 类似于 getter 获取中断值，interrupted() 类似于 getter + setter 先获取中断值，然后清除标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试 isInterrupted 与 interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_14_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_14_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;park&quot;</span>);<br>            LockSupport.park();<br>            log.info(<span class="hljs-string">&quot;unpark&quot;</span>);<br><span class="hljs-comment">//            log.info(&quot;打断标记为:&#123;&#125;&quot;, Thread.currentThread().isInterrupted());</span><br>            log.info(<span class="hljs-string">&quot;打断标记为:&#123;&#125;&quot;</span>, Thread.interrupted());<br><br>            <span class="hljs-comment">// 使用 Thread.currentThread().isInterrupted() 查看打断标记为 true, LockSupport.park() 失效</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 执行结果：</span><br><span class="hljs-comment">             * 11:54:17 [t1] c.Code_14_Test - park</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - 打断标记为:true</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 使用 Thread.interrupted() 查看打断标记为 true, 然后清空打断标记为 false, LockSupport.park() 不失效</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 执行结果：</span><br><span class="hljs-comment">             * 11:58:12 [t1] c.Code_14_Test - park</span><br><span class="hljs-comment">             * 11:58:13 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             * 11:58:13 [t1] c.Code_14_Test - 打断标记为:true</span><br><span class="hljs-comment">             */</span><br>            LockSupport.park();<br>            log.info(<span class="hljs-string">&quot;unpark&quot;</span>);<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 主线程休眠 1 秒</span><br>        t1.interrupt();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="终止模式之两阶段终止模式，如下："><a href="#终止模式之两阶段终止模式，如下：" class="headerlink" title="终止模式之两阶段终止模式，如下："></a>终止模式之两阶段终止模式，如下：</h5><p>Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。</p><p><img src="https://img-blog.csdnimg.cn/2021012811453967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="两阶段终止模式"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 interrupt 进行两阶段终止模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_13_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_13_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoParseTermination twoParseTermination = <span class="hljs-keyword">new</span> TwoParseTermination();<br>        twoParseTermination.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        twoParseTermination.stop();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoParseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoParseTermination</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">// 启动线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Thread thread = Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(thread.isInterrupted()) &#123; <span class="hljs-comment">// 调用 isInterrupted 不会清除标记</span><br>                    log.info(<span class="hljs-string">&quot;料理后事 ...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        log.info(<span class="hljs-string">&quot;执行监控的功能 ...&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        log.info(<span class="hljs-string">&quot;设置打断标记 ...&quot;</span>);<br>                        thread.interrupt();<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;monitor&quot;</span>);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 终止线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）sleep、yiled、wait、join对比"><a href="#5）sleep、yiled、wait、join对比" class="headerlink" title="5）sleep、yiled、wait、join对比"></a>5）sleep、yiled、wait、join对比</h4><p>参考文章：<a href="https://www.cnblogs.com/aspirant/p/8876670.html">点这里</a></p><h4 id="6）守护线程"><a href="#6）守护线程" class="headerlink" title="6）守护线程"></a>6）守护线程</h4><p>默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码，未执行完java进程也会停止。普通线程t1可以调用<strong>t1.setDeamon(true)；</strong>方法变成守护线程。</p><p>注意 垃圾回收器线程就是一种守护线程。 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p><h3 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4.线程状态"></a>4.线程状态</h3><h4 id="1）线程的5种状态"><a href="#1）线程的5种状态" class="headerlink" title="1）线程的5种状态"></a>1）线程的5种状态</h4><p>从操作系统层划分，线程有5种状态</p><p><img src="https://img-blog.csdnimg.cn/20210128153015533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="线程五种状态"></p><ol><li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thead thread = new Thead();，还未与操作系统线程关联</p></li><li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p></li><li><p>运行状态，指线程获取了CPU时间片，正在运行</p><p>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</p></li><li><p>阻塞状态</p><ol><li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</li><li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li></ol></li><li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ol><h4 id="2）线程的6种状态"><a href="#2）线程的6种状态" class="headerlink" title="2）线程的6种状态"></a>2）线程的6种状态</h4><p>这是从JavaAPI层面来描述的，我们主要研究的就是这种。参考文章：<a href="https://blog.csdn.net/pange1991/article/details/53860651">点这里</a></p><p><img src="https://img-blog.csdnimg.cn/2021012815330125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="线程的六种状态"></p><ul><li>NEW 跟五种状态里的初始状态是一个意思</li></ul><ul><li>RUNNABLE 是当调用了 start() 方法之后的状态，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li></ul><ul><li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分。</li></ul><p>演示线程的 6 种状态，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 java 线程的 6 种状态(NEW, RUNNABLE, TERMINATED, BLOCKED, WAITING, TIMED_WAITING)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_15_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_15_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// NEW</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;NEW 状态&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// RUNNABLE</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t2.start();<br><br>        <span class="hljs-comment">// TERMINATED</span><br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;running&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>);<br>        t3.start();<br><br>        <span class="hljs-comment">// TIMED_WAITING</span><br>        Thread t4 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Code_15_Test.class) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>);<br>        t4.start();<br><br>        <span class="hljs-comment">// WAITING</span><br>        Thread t5 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t2.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t5&quot;</span>);<br>        t5.start();<br><br>        Thread t6 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Code_15_Test.class) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t6&quot;</span>);<br>        t6.start();<br><br>        <span class="hljs-comment">// 主线程休眠 1 秒, 目的是为了等待 t3 线程执行完</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;t1 线程状态: &#123;&#125;&quot;</span>, t1.getState());<br>        log.info(<span class="hljs-string">&quot;t2 线程状态: &#123;&#125;&quot;</span>, t2.getState());<br>        log.info(<span class="hljs-string">&quot;t3 线程状态: &#123;&#125;&quot;</span>, t3.getState());<br>        log.info(<span class="hljs-string">&quot;t4 线程状态: &#123;&#125;&quot;</span>, t4.getState());<br>        log.info(<span class="hljs-string">&quot;t5 线程状态: &#123;&#125;&quot;</span>, t5.getState());<br>        log.info(<span class="hljs-string">&quot;t6 线程状态: &#123;&#125;&quot;</span>, t6.getState());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>本章的重点在于掌握</p><ol><li>线程的创建</li><li>线程重要的API，如start、run、sleep、yield、join、interrupt等</li><li>线程的状态</li><li>原理方面，线程的运行流程，栈，栈帧，上下文切换，程序计数器等知识</li><li>Thread两种创建线程的源码</li><li>使用interrupt来编写两阶段终止</li></ol><h2 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h2><h3 id="1-线程共享带来的问题"><a href="#1-线程共享带来的问题" class="headerlink" title="1.线程共享带来的问题"></a>1.线程共享带来的问题</h3><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;<br>               count++;<br>           &#125;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;<br>               count--;<br>           &#125;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       t1.join();<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;count的值是&#123;&#125;&quot;</span>,count);<br>   &#125;<br></code></pre></td></tr></table></figure><p>如上代码，当执行 count++ 或者 count– 操作的时候，从字节码分析，实际上是 4 步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">count++; <span class="hljs-comment">// 操作字节码如下：</span><br>getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>iadd <span class="hljs-comment">// 自增</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br><br>count--; <span class="hljs-comment">// 操作字节码如下：</span><br>getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>isub <span class="hljs-comment">// 自减</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure><p>当 CPU 时间片分给 t1 线程时，t1 线程去读取变量值为 0 并且执行 ++ 的操作，如上在字节码自增操作中，当 t1 执行完自增，还没来得急将修改后的值存入静态变量时，假如线程的时间片用完了，并且 CPU 将时间片分配给 t2 线程，t2 线程拿到时间片执行自减操作，并且将修改后的值存入静态变量，此时 count 的值为 -1，但是当 CPU 将时间片分给经历了上下文切换的 t1 线程时，t1 将修改后的值存入静态变量，此时 counter 的值为 1，覆盖了 t2 线程执行的结果，出现了丢失更新，这就是多线对共享资源读取的问题。</p><h4 id="1）临界区-Criteria-Section"><a href="#1）临界区-Criteria-Section" class="headerlink" title="1）临界区 Criteria Section"></a>1）临界区 Criteria Section</h4><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li></ul><p>例如，下面代码中的临界区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）竞态条件-Race-Condition"><a href="#2）竞态条件-Race-Condition" class="headerlink" title="2）竞态条件 Race Condition"></a>2）竞态条件 Race Condition</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件</p><h3 id="2-synchronized解决方案"><a href="#2-synchronized解决方案" class="headerlink" title="2.synchronized解决方案"></a>2.synchronized解决方案</h3><h4 id="1）解决手段"><a href="#1）解决手段" class="headerlink" title="1）解决手段"></a>1）解决手段</h4><p>为了避免临界区中的竟态条件发生，有多种手段可以达到</p><ul><li>阻塞式解决方案：synchronized，lock</li><li>非阻塞式解决方案：原子变量</li></ul><p>现在讨论使用<strong>synchronized</strong>来进行解决，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><p>注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码 同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p><h4 id="2）synchronized-语法"><a href="#2）synchronized-语法" class="headerlink" title="2）synchronized 语法"></a>2）synchronized 语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br><span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的实例程序使用synchronized后如下，计算出的结果是正确！Test13.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>             <span class="hljs-keyword">synchronized</span> (room) &#123;<br>             counter++;<br>        &#125;<br> &#125;<br> &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>     Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>             <span class="hljs-keyword">synchronized</span> (room) &#123;<br>             counter--;<br>         &#125;<br>     &#125;<br>     &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>     t1.start();<br>     t2.start();<br>     t1.join();<br>     t2.join();<br>     log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）synchronized原理"><a href="#3）synchronized原理" class="headerlink" title="3）synchronized原理"></a>3）synchronized原理</h4><p>synchronized实际上利用<strong>对象保证了临界区代码的原子性</strong>，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断</p><p><img src="https://gitee.com/gu_chun_bo/picture/raw/master/image/20200307170035-215697.png" alt="synchronized原理"></p><h4 id="4）synchronized加在方法上"><a href="#4）synchronized加在方法上" class="headerlink" title="4）synchronized加在方法上"></a>4）synchronized加在方法上</h4><ul><li>加在成员方法上，锁住的是this对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-comment">// 在方法上加上synchronized关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 锁住的是对象</span><br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加在静态方法上，锁住的是类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-comment">// 在静态方法上加上 synchronized 关键字</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">synchronized</span>(Test.class) &#123; <span class="hljs-comment">// 锁住的是类</span><br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）线程八锁案例分析"><a href="#5）线程八锁案例分析" class="headerlink" title="5）线程八锁案例分析"></a>5）线程八锁案例分析</h4><ul><li>考察synchronized锁住的是哪个对象，如果锁住的是同一对象，就不会出现线程安全问题</li></ul><h5 id="1-锁住同一对象都是this-e1对象-，结果为：1-2-2-1"><a href="#1-锁住同一对象都是this-e1对象-，结果为：1-2-2-1" class="headerlink" title="1.锁住同一对象都是this(e1对象)，结果为：1,2 || 2,1"></a>1.锁住同一对象都是this(e1对象)，结果为：1,2 || 2,1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//    public void a () &#123;</span><br><span class="hljs-comment">//        synchronized (this) &#123;</span><br><span class="hljs-comment">//            log.debug(&quot;1&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-锁住同一个对象都是this-e1对象-，结果为：1s后1-2-2-1s后1"><a href="#2-锁住同一个对象都是this-e1对象-，结果为：1s后1-2-2-1s后1" class="headerlink" title="2.锁住同一个对象都是this(e1对象)，结果为：1s后1,2 || 2,1s后1"></a>2.锁住同一个对象都是this(e1对象)，结果为：1s后1,2 || 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-a-b锁住同一个对象都是this-e1对象-，c没有上锁。结果为：3-1s后1-2-2-3-1s后1-3-2-1s后1"><a href="#3-a-b锁住同一个对象都是this-e1对象-，c没有上锁。结果为：3-1s后1-2-2-3-1s后1-3-2-1s后1" class="headerlink" title="3.a,b锁住同一个对象都是this(e1对象)，c没有上锁。结果为：3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1"></a>3.a,b锁住同一个对象都是this(e1对象)，c没有上锁。结果为：3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span><br><span class="hljs-comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span><br><span class="hljs-comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span><br><span class="hljs-comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span><br><span class="hljs-comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                e1.a();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.c()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-a锁住对象this-n1对象-，b锁住对象this（n2对象），不互斥。结果为：2-1s后1"><a href="#4-a锁住对象this-n1对象-，b锁住对象this（n2对象），不互斥。结果为：2-1s后1" class="headerlink" title="4.a锁住对象this(n1对象)，b锁住对象this（n2对象），不互斥。结果为：2,1s后1"></a>4.a锁住对象this(n1对象)，b锁住对象this（n2对象），不互斥。结果为：2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是e2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1"><a href="#5-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1" class="headerlink" title="5.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1"></a>5.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是e2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-a，b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2"><a href="#6-a，b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2" class="headerlink" title="6.a，b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2"></a>6.a，b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1 || 1s后1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1"><a href="#7-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1" class="headerlink" title="7.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1"></a>7.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是this,e2对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8、a-b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2"><a href="#8、a-b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2" class="headerlink" title="8、a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2"></a>8、a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1 || 1s后1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-变量的线程安全分析"><a href="#3-变量的线程安全分析" class="headerlink" title="3.变量的线程安全分析"></a>3.变量的线程安全分析</h3><h4 id="1）成员变量和静态变量的线程安全分析-重要"><a href="#1）成员变量和静态变量的线程安全分析-重要" class="headerlink" title="1）成员变量和静态变量的线程安全分析(重要)"></a>1）成员变量和静态变量的线程安全分析(<code>重要</code>)</h4><ul><li><code>如果变量没有在线程间共享，那么变量是安全的</code></li><li>如果变量在线程间共享<ul><li>如果只有<code>读操作</code>，则<code>线程安全</code></li><li>如果有<code>读写操作</code>，则这段代码是<code>临界区</code>，需要考虑线程安全</li></ul></li></ul><h4 id="2）局部变量线程安全分析-重要"><a href="#2）局部变量线程安全分析-重要" class="headerlink" title="2）局部变量线程安全分析(重要)"></a>2）局部变量线程安全分析(<code>重要</code>)</h4><ul><li>局部变量【局部变量被初始化为基本数据类型】是安全的</li><li>但局部变量引用的对象则未必（要看该对象是否被共享且被执行了读写操作）<ul><li>如果该对象没有逃离方法的作用范围；是线程安全的</li><li>如果该对象逃离方法的作用范围；需要考虑线程安全</li></ul></li></ul><h4 id="3）线程安全的情况-重要"><a href="#3）线程安全的情况-重要" class="headerlink" title="3）线程安全的情况(重要)"></a>3）线程安全的情况(<code>重要</code>)</h4><ul><li>局部变量表是存在于栈帧中，而虚拟机栈中又包括很多栈帧，虚拟机栈是线程私有的</li><li>局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>     i++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个线程调用test1()方法时局部变量i，会在每个线程的栈内存中被创建多份，因此不存在共享</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br> descriptor: ()V<br> flags: ACC_PUBLIC, ACC_STATIC<br> Code:<br> stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: bipush <span class="hljs-number">10</span><br> <span class="hljs-number">2</span>: istore_0<br> <span class="hljs-number">3</span>: iinc <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span><br> LineNumberTable:<br> line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br> line <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br> line <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br> LocalVariableTable:<br> Start Length Slot Name Signature<br> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> i I<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020121913434871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h4 id="4）线程不安全的情况"><a href="#4）线程不安全的情况" class="headerlink" title="4）线程不安全的情况"></a>4）线程不安全的情况</h4><ul><li><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全问题，代码示例如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">循环创建了<span class="hljs-number">100</span>个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了<span class="hljs-number">100</span>次method2,method3方法。方法<span class="hljs-number">2</span>,<span class="hljs-number">3</span>都使用到了成员变量<span class="hljs-built_in">array</span>List, 此时的问题就是: <span class="hljs-number">1</span>个线程它会循环调用<span class="hljs-number">100</span>次方法<span class="hljs-number">2</span>和<span class="hljs-number">3</span>, 一共有<span class="hljs-number">100</span>个线程, 此时<span class="hljs-number">100</span>个线程操作的共享资源就是<span class="hljs-built_in">array</span>List成员变量 , 而且还进行了读写操作. 必然会造成线程不安全的问题<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        UnsafeTest unsafeTest = <span class="hljs-keyword">new</span> UnsafeTest();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                unsafeTest.method1();<br>            &#125;,<span class="hljs-string">&quot;线程&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeTest</span></span>&#123;<br>    ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            method2();<br>            method3();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;线程1&quot;</span> Exception in thread <span class="hljs-string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="5）不安全原因分析"><a href="#5）不安全原因分析" class="headerlink" title="5）不安全原因分析"></a>5）不安全原因分析</h4><ul><li>无论哪个线程中的method2和method3引用的都是同一个对象中的list成员变量</li><li>一个ArrayList，在添加一个元素的时候，他可能会有两步来完成<ul><li>第一步：在arrayList[size]的位置存放此元素</li><li>第二部：size++</li></ul></li><li>在单线程运行的情况下，如果size=0，添加一个元素后，此元素在位置0，而且size=1；</li><li>在多线程情况下，比如有两个线程，<code>线程 A 先将元素存放在位置 0。但是此时 CPU 进行上下文切换 (线程A还没来得及size++)</code>，<strong>线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于0</strong>  （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，<code>都增加 size 的值</code>。</li><li>那好，现在我们来看看 <code>ArrayList</code> 的情况，<code>元素实际上只有一个，存放在位置 0</code>，而 <code>size 却等于 2</code>。这就是“线程不安全”了。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/589573a2de17a1bc7ca5728a20248ef5.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fbc6e2e0d0cc62e37fcf70984813091e.png"></p><h4 id="6-解决方法"><a href="#6-解决方法" class="headerlink" title="6.解决方法"></a>6.解决方法</h4><ul><li>可以将<code>list</code>修改成<code>局部变量</code>，然后将 list 作为引用传入方法中，局部变量存放在栈帧中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>因为method1方法, 将<code>arrayList</code>传给method2,method3方法, 此时他们三个方法<code>共享这同一个arrayList</code>, 此时<strong>不会被其他线程访问到</strong>, 所以不会出现<code>线程安全问题</code>, 因为<code>这三个方法使用的同一个线程</code>。</li></ul><ul><li>在外部, 创建了100个线程, 每个线程都会调用<code>method1</code>方法, 然后都会再从新创建一个新的<code>arrayList</code>对象, 这个新对象再传递给method2,method3方法.</li></ul><p><img src="https://img-blog.csdnimg.cn/20201219151354651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h4 id="7）思考private或final的重要性-重要"><a href="#7）思考private或final的重要性-重要" class="headerlink" title="7）思考private或final的重要性(重要)"></a>7）思考private或final的重要性(<code>重要</code>)</h4><p>提高线程的安全性</p><p>如果把method2和method3 的方法修改为<code>public</code> 会不会导致线程安全问题; 分情况:</p><h5 id="情况1：有其它线程调用-method2-和-method3"><a href="#情况1：有其它线程调用-method2-和-method3" class="headerlink" title="情况1：有其它线程调用 method2 和 method3"></a><strong>情况1：有其它线程调用 method2 和 method3</strong></h5><ul><li>只修改为public修饰,此时不会出现线程安全的问题, 即使线程2调用method2/3方法, 给2/3方法传过来的list对象也是线程2调用method1方法时,传递给method2/3的list对象, 不可能是线程1调用method1方法传的对象。 具体原因看上面: 4.2解决方法。</li></ul><h5 id="情况2：在情况1-的基础上，为ThreadSafe-类添加子类，子类覆盖method2-或-method3方法，即如下所示：-从这个例子可以看出-private-或-final-提供【安全】的意义所在，请体会开闭原则中的【闭】"><a href="#情况2：在情况1-的基础上，为ThreadSafe-类添加子类，子类覆盖method2-或-method3方法，即如下所示：-从这个例子可以看出-private-或-final-提供【安全】的意义所在，请体会开闭原则中的【闭】" class="headerlink" title="情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖method2 或 method3方法，即如下所示： 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】"></a>情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖<code>method2 或 method3</code>方法，即如下所示： 从这个例子可以看出 <code>private</code> 或 <code>final</code> 提供【安全】的意义所在，请体会<code>开闭原则中的【闭】</code></h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">- 如果改为<span class="hljs-keyword">public</span>, 此时子类可以重写父类的方法, 在子类中开线程来操作list对象, 此时就会出现线程安全问题: 子类和父类共享了list对象<br>- 如果改为<span class="hljs-keyword">private</span>, 子类就不能重写父类的私有方法, 也就不会出现线程安全问题; 所以所<span class="hljs-keyword">private</span>修饰符是可以避免线程安全问题.<br>- 所以如果不想子类, 重写父类的方法的时候, 我们可以将父类中的方法设置为<span class="hljs-keyword">private</span>, <span class="hljs-keyword">final</span>修饰的方法, 此时子类就无法影响父类中的方法了!<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8）常见线程安全类"><a href="#8）常见线程安全类" class="headerlink" title="8）常见线程安全类"></a>8）常见线程安全类</h4><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 JUC</li></ul><p><strong>重点:</strong></p><ul><li>这里<code>说它们是线程安全</code>的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong></li><li>它们的每个方法是原子的<code>（方法都被加上了synchronized）</code></li></ul><ul><li>但注意它们<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-comment">// put方法增加了synchronized</span><br> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure><h5 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h5><ul><li>但注意<code>它们多个方法的组合不是原子的</code>，见下面分析<ul><li>这里只能是get方法内部是线程安全的, put方法内部是线程安全的. 组合起来使用还是会受到<code>上下文切换</code>的影响</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br> table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3f38b860d4b0a73d3bc446598d38c867.png"></p><p>如上图所示，当使用方法组合时，出现了线程安全问题，当线程 1 执行完 get(“key”) ，这是一个原子操作没出问题，但是在 get(“key”) == null 比较时，如果线程的时间片用完了，线程 2 获取时间片执行了 get(“key”) == null 操作，然后进行 put(“key”, “v2”) 操作，结束后，线程 1 被分配 cpu 时间片继续执行，执行 put 操作就会出现线程安全问题。</p><h5 id="不可变类的线程安全"><a href="#不可变类的线程安全" class="headerlink" title="不可变类的线程安全"></a>不可变类的线程安全</h5><ul><li><code>String</code>和<code>Integer</code>类都是<code>不可变的类</code>，因为其类内部<code>状态是不可改变</code>的，因此<strong>它们的方法都是线程安全的</strong>, 都被<code>final</code>修饰, 不能被继承.</li><li>肯定有些人他们知道<code>String</code> 有 <code>replace</code>，<code>substring</code> 等方法【<code>可以】改变值啊</code>，<strong>其实调用这些方法返回的已经是一个新创建的对象了！</strong> <code>(在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(endIndex);<br>        &#125;<br>        <span class="hljs-keyword">int</span> subLen = endIndex - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span><br>                : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen); <span class="hljs-comment">// 新建一个对象，然后返回，没有修改等操作，是线程安全的。</span><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="9）示例分析-是否线程安全"><a href="#9）示例分析-是否线程安全" class="headerlink" title="9）示例分析-是否线程安全"></a>9）示例分析-是否线程安全</h4><h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h5><p>分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的。</p><ul><li><code>Servlet运行在Tomcat环境下并只有一个实例</code>，因此会被Tomcat的多个线程共享使用，因此存在成员变量的共享问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br> <span class="hljs-comment">// 是否安全？  否：HashMap不是线程安全的，HashTable是</span><br> Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> <span class="hljs-comment">// 是否安全？  是:String 为不可变类，线程安全</span><br> String S1 = <span class="hljs-string">&quot;...&quot;</span>;<br> <span class="hljs-comment">// 是否安全？ 是</span><br> <span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;<br> <span class="hljs-comment">// 是否安全？ 否：不是常见的线程安全类</span><br> Date D1 = <span class="hljs-keyword">new</span> Date();<br> <span class="hljs-comment">// 是否安全？  否：引用值D2不可变，但是日期里面的其它属性比如年月日可变。与字符串的最大区别是Date里面的属性可变。</span><br> <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response)</span> </span>&#123;<br>  <span class="hljs-comment">// 使用上述变量</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h5><ul><li><strong>MyAspect切面类只有一个实例，成员变量start 会被多个线程同时进行读写操作</strong></li><li><strong>Spring中的Bean都是单例的, 除非使用@Scope修改为多例。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全？不安全, 因为MyAspect是单例的</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>            start = System.nanoTime();<br>        &#125;<br><br>        <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>#####示例三</p><ul><li>此例是典型的三层模型调用，MyServlet UserServiceImpl UserDaoImpl类都只有一个实例，UserDaoImpl类中没有成员变量，update方法里的变量引用的对象不是线程共享的，所以是线程安全的；UserServiceImpl类中只有一个线程安全的UserDaoImpl类的实例，那么UserServiceImpl类也是线程安全的，同理 MyServlet也是线程安全的</li><li>Servlet调用Service, Service调用Dao这三个方法使用的是<code>同一个线程</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br> <span class="hljs-comment">// 是否安全    是：UserService不可变，虽然有一个成员变量,</span><br> <span class="hljs-comment">// 但是是私有的, 没有地方修改它</span><br> <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br> userService.update(...);<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br> <span class="hljs-comment">// 是否安全     是：Dao不可变, 其没有成员变量</span><br> <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br> <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br> userDao.update();<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123; <br> <span class="hljs-comment">// 是否安全   是：没有成员变量，无法修改其状态和属性</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br> String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br> <span class="hljs-comment">// 是否安全   是：不同线程创建的conn各不相同，都在各自的栈内存中</span><br> <span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<br> <span class="hljs-comment">// ...</span><br> &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br> <span class="hljs-comment">// ...</span><br> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h5><ul><li><code>UserDaoImpl</code>类中<code>有成员变量</code>，那么<strong>多个线程可以对成员变量</strong><code>conn</code> 同时进行操作，<code>故是不安全的</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>       userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全: 不安全; 当多个线程,共享conn, 一个线程拿到conn,刚创建一个连接赋值给conn, 此时另一个线程进来了, 直接将conn.close</span><br>    <span class="hljs-comment">//另一个线程恢复了, 拿到conn干事情, 此时conn都被关闭了, 出现了问题</span><br>    <span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h5><p><code>UserServiceImpl</code>类的<code>update方法中UserDao是作为局部变量存在</code>的，所以每个线程访问的时候都会新建有一个<code>UserDao</code>对象，新建的对象是线程独有的，所以<code>是线程安全的</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        userDao.update();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h5><ul><li>私有变量sdf被暴露出去了，发生了逃逸</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        foo(sdf);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Test().bar();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中<code>foo 的行为是不确定的</code>，可能<code>导致不安全的发生</code>，被称之为<strong>外星方法</strong>，<strong>因为foo方法可以被重写，导致线程不安全。</strong> 在String类中就考虑到了这一点，String类是<code>final</code>的，<strong>子类不能重写它的方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span> </span>&#123;<br>    String dateStr = <span class="hljs-string">&quot;1999-10-11 00:00:00&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sdf.parse(dateStr);<br>            &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10）习题分析"><a href="#10）习题分析" class="headerlink" title="10）习题分析"></a>10）习题分析</h4><h5 id="卖票练习"><a href="#卖票练习" class="headerlink" title="- 卖票练习"></a>- 卖票练习</h5><p>测试下面代码是否存在线程安全问题，并尝试改正</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.n4.exercise;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Vector;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseSell</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 模拟多人买票</span><br>        TicketWindow window = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 所有线程的集合（由于threadList在主线程中，不被共享，因此使用ArrayList不会出现线程安全问题）</span><br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 卖出的票数统计(Vector为线程安全类)</span><br>        List&lt;Integer&gt; amountList = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-comment">// 买票</span><br>                <span class="hljs-keyword">int</span> amount = window.sell(random(<span class="hljs-number">5</span>));<br>                <span class="hljs-comment">// 统计买票数</span><br>                amountList.add(amount);<br>            &#125;);<br>            threadList.add(thread);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            thread.join();<br>        &#125;<br><br>        <span class="hljs-comment">// 统计卖出的票数和剩余票数</span><br>        log.debug(<span class="hljs-string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());<br>        log.debug(<span class="hljs-string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i -&gt; i).sum());<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~5</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(amount) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 售票窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> </span>&#123;<br><span class="hljs-comment">// 票总数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取余票数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// 售票</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在售票方法中加上synchronized ，对this加锁保证线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">/ 售票<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="转账练习"><a href="#转账练习" class="headerlink" title="- 转账练习"></a>- 转账练习</h5><p>测试下面代码是否存在线程安全问题，并尝试改正</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.n4.exercise;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseTransfer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Account a = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Account b = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                a.transfer(b, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                b.transfer(a, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        <span class="hljs-comment">// 查看转账2000次后的总金额</span><br>        log.debug(<span class="hljs-string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~100</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 账户</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">// 转账</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Account target, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class) &#123;   <span class="hljs-comment">//锁住Account类，因为涉及到A.money和B.money。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt;= amount) &#123;<br>                <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 没问题, 最终的结果仍然是 2000元</span><br></code></pre></td></tr></table></figure><h3 id="4-Monitor概念"><a href="#4-Monitor概念" class="headerlink" title="4.Monitor概念"></a>4.Monitor概念</h3><h4 id="1）Java对象头"><a href="#1）Java对象头" class="headerlink" title="1）Java对象头"></a>1）Java对象头</h4><p>对象头包含两部分：<strong>运行时元数据（Mark Word）和类型指针（Klass Word）</strong></p><ol><li><strong>运行时元数据</strong><ol><li><code>哈希值（HashCode）</code>，可以看作是<strong>堆中对象的地址</strong></li><li><code>GC分代年龄（年龄计数器）</code> (用于新生代from/to区晋升老年代的标准, 阈值为15)</li><li><strong>锁状态标志</strong> (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li><li><strong>线程持有的锁</strong></li><li><strong>偏向线程ID</strong> (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li><li>偏向时间戳</li></ol></li><li>类型指针<ol><li>指向<code>类元数据InstanceKlass，确定该对象所属的类型</code>。指向的其实是<strong>方法区中存放的类元信息</strong></li></ol></li></ol><p>说明：如果对象是数组，还需要记录数组的长度</p><ul><li>以32位虚拟机为例，普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区对应的Class对象；</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ac7274e0d0dbe8c8b25f43f2aa1ed1d6.png"></p><ul><li>数组对象</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/52c45594819f30fb8a9d6087682be254.png"></p><ul><li>其中Mark Word结构为：<strong>无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0ffaeb7ddf7d71801bfd3eeb00754162.png"></p><ul><li>一个对象的结构如下：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png"></p><h4 id="2）Monitor原理"><a href="#2）Monitor原理" class="headerlink" title="2）Monitor原理"></a>2）Monitor原理</h4><p>Monitor 被翻译为监视器或者说管程</p><p>每个 java 对象都可以关联一个 Monitor ，如果使用 synchronized 给对象上锁（重量级），该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">多线程同时访问临界区: 使用重量级锁<br><br><span class="hljs-bullet">-</span> JDK6对Synchronized的优先状态：偏向锁–&gt;轻量级锁–&gt;重量级锁<br></code></pre></td></tr></table></figure><p>原理解释:</p><ul><li><p>当<code>Thread1</code>访问到<code>synchronized(obj)</code>中的<code>共享资源</code>的时候</p><ul><li>首先会将synchronized中的<code>锁对象</code>中<code>对象头</code>的<code>MarkWord</code>去尝试指向<code>操作系统</code>的<code>Monitor</code>对象。让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的<code>MarkWord</code>的<code>对象状态</code>从01改为10。</li><li>因为Monitor没有和其他的obj的MarkWord相关联, 所以<code>Thread1</code>就成为了该<code>Monitor</code>的Owner(所有者)。</li><li>又来了个Thread1执行synchronized(obj)代码, 它首先会看看能不能执行该临界区的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); Thread1也会和该Monitor关联, 该线程就会进入到它的EntryList(阻塞队列);</li><li>当<code>Thread2</code>执行完<code>临界区</code>代码后, Monitor的<code>Owner(所有者)</code>就空出来了. 此时就会<code>通知</code>Monitor中的EntryList阻塞队列中的线程, 这些线程通过<code>竞争</code>, 成为新的<code>所有者</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/98c3189e41fd654fe34ead273ec76eba.png"></p></li><li><p>刚开始时<code>Monitor</code>中的<code>Owner为null</code></p></li><li><p><strong>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</strong></p></li><li><p>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入<code>EntryList</code>中变成<code>BLOCKED状态</code></p></li><li><p><strong>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的 (仍然是抢占式)</strong></p></li><li><p><code>图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</code></p></li></ul><p>注意：</p><ul><li>synchronized 必须是进入同一个锁对象的monitor 才有上述的效果; —&gt; 也就要使用同一把锁</li><li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则<img src="https://img-blog.csdnimg.cn/20201219200615817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></li></ul><p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p><ul><li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗~</li></ul><h3 id="5-synchronized原理进阶"><a href="#5-synchronized原理进阶" class="headerlink" title="5.synchronized原理进阶"></a>5.synchronized原理进阶</h3><h4 id="1）synchronized原理"><a href="#1）synchronized原理" class="headerlink" title="1）synchronized原理"></a>1）synchronized原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>反编译后的部分字节码</li></ul><p><img src="https://img-blog.csdnimg.cn/20201219201521709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p>方法级别的synchronized不会在字节码指令中有所体现</p><h4 id="2）轻量级锁"><a href="#2）轻量级锁" class="headerlink" title="2）轻量级锁"></a>2）轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有线程可以竞争），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是synchronized，假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 A</span><br>         method2();<br>     &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 B</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以存储对象的Mark Word和对象引用reference</p><p><img src="https://img-blog.csdnimg.cn/20210130164759889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p></li><li><p>让锁记录中的Object reference指向对象，并且尝试用cas（compare and sweep）替换Object对象的Mark Word，将Mark Word的值存入锁记录中</p><p><img src="https://img-blog.csdnimg.cn/20210130164905217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p></li><li><p>如果cas替换成功，那么对象的对象头存储的就是锁记录的地址和状态 00表示轻量级锁，如下</p><p><img src="https://img-blog.csdnimg.cn/20210130165114847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p></li><li><p>如果cas失败，有两种情况</p><ol><li>如果是<code>其它线程</code>已经持有了<code>该Object的轻量级锁</code>，那么表示<strong>有竞争</strong>，将进入 <strong>锁膨胀阶段</strong> 。此时<code>对象Object</code>对象头中已经存储了别的线程的<code>锁记录地址 00</code>,指向了其他线程;</li><li>如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条Lock Record作为重入的计数</li></ol><p><img src="https://img-blog.csdnimg.cn/20210130165409613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p></li><li><p>当线程退出synchronized代码块的时候，如果获取的是取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="https://img-blog.csdnimg.cn/20210130165114847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为null，那么使用cas将Mark Word的值恢复给对象</p><ol><li>成功则解锁</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ol></li></ol><h4 id="3）锁膨胀"><a href="#3）锁膨胀" class="headerlink" title="3）锁膨胀"></a>3）锁膨胀</h4><p>如果在尝试<code>加轻量级锁</code>的过程中，<code>cas替换操作无法成功</code>，这是<strong>有一种情况就是其它线程已经为这个对象加上了轻量级锁</strong>，这是就要进行<code>锁膨胀(有竞争)</code>，<strong>将轻量级锁变成重量级锁。</strong></p><p>当Thread - 1进行轻量级加锁时，Thread - 0已经对该对象加了轻量级锁，此时发生锁膨胀</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png"></p><p>这时Thread-1加轻量级锁失败，<strong>进入锁膨胀流程</strong></p><ul><li><strong>因为Thread-1线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念</strong>, 所以此时就要<code>为对象申请Monitor锁(重量级锁)</code>，让<code>Object指向重量级锁地址 10</code>，然后<code>自己进入Monitor 的EntryList 变成BLOCKED状态</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p>当<code>Thread-0 线程</code>执行完<code>synchronized同步块</code>时，<strong>使用cas将Mark Word的值恢复给对象头</strong>, 肯定恢复失败,因为对象的对象头中存储的是<code>重量级锁的地址,状态变为10了</code>之前的是00, 肯定恢复失败。</p><p>那么会<code>进入重量级锁的解锁过程</code>，即按照<code>Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程</code></p><h4 id="4）自旋优化"><a href="#4）自旋优化" class="headerlink" title="4）自旋优化"></a>4）自旋优化</h4><p>当发生<code>重量级锁竞争的时候</code>，还可以使用<code>自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)</code>，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），<strong>那么当前线程就可以不用进行上下文切换**</strong>(持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程)** 就获得了<code>锁</code></p><ul><li>优化的点: 不用将<code>线程</code>加入到阻塞队列, 减少cpu切换</li></ul><ol><li><p>自旋重试成功的情况</p><p><img src="https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png"></p></li><li><p>自旋重试失败的情况，<strong>自旋了一定次数还是没有等到持锁的线程释放锁</strong>，线程2就会加入Monitor的阻塞队列（EntryList）</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png"></p><ul><li><strong>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</li><li><code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</li></ul><h4 id="5）偏向锁-用于优化轻量级锁重入"><a href="#5）偏向锁-用于优化轻量级锁重入" class="headerlink" title="5）偏向锁(用于优化轻量级锁重入)"></a>5）偏向锁(用于优化轻量级锁重入)</h4><p>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</p><ul><li><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭</p></li><li><p>将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</p></li><li><p>在<code>轻量级的锁</code>中，我们可以发现，如果同一个线程对同一个对象进行<code>重入锁</code>时，<strong>也需要执行CAS替换操作，这是有点耗时。</strong></p></li><li><p>那么java6开始引入了<code>偏向锁</code>，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</strong></p><ul><li><strong>升级为轻量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( <code>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</code>)</li><li><strong>升级为重量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( <code>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块A</span><br>            m2();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块B</span><br>            m3();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块C</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p></li></ul><p><strong>偏向状态</strong></p><p>对象头格式：</p><p><img src="https://img-blog.csdnimg.cn/20210130181306490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>一个对象的创建过程</p><ul><li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值.</p></li><li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p><p>-XX:BiasedLockingStartupDelay=0 来禁用延迟</p></li><li><p>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></li></ul><p><strong>撤销偏向</strong></p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li>调用了wait/notify方法（调用wait方法会导致锁膨胀而使用重量级锁）</li></ul><h4 id="6）批量重偏向"><a href="#6）批量重偏向" class="headerlink" title="6）批量重偏向"></a>6）批量重偏向</h4><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 t1 的对象仍有机会重新偏向 t2</li><li>重偏向会重置Thread ID</li><li>当撤销超过20次后（超过阈值），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h4 id="7）批量撤销"><a href="#7）批量撤销" class="headerlink" title="7）批量撤销"></a>7）批量撤销</h4><p>当撤销偏向锁的阈值超过 40 以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从JDK1.6开始，synchronized锁的实现发生了很大的变化；JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁，轻量级锁以及重量级锁，从而减少锁的竞争带来的用户态与内核态之间的切换；这种锁的优化实际上是通过java对象头中的一些标志位去实现的；对于锁的访问与改变，实际上都是与java对象头息息相关。对象实例在堆中会被划分为三个部分：对象头，实例数据与对其填充。对象头也是由三块内容来构成：</p><ol><li>Mark Word</li><li>指向类的指针</li><li>数组长度</li></ol><p>其中Mark Word（它记录了对象，锁及垃圾回收的相关信息，在64位的JVM中，其长度也是 64bit 的）的位信息包括如下组成部分：</p><ol><li>无锁标记（hashcode、分代年龄、偏向锁标志）</li><li>偏向锁标记 （偏向线程 id）</li><li>轻量级锁标记 （锁记录）</li><li>重量级锁标记 （Monitor）</li><li>GC标记</li></ol><p>对于 synchronized 锁来说，锁的升级主要是通过 Mark Word 中的锁标记位与是否是偏向锁标记为来达成的；synchronized 关键字所对象的锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后变成了重量级锁。</p><ol><li><p>偏向锁：针对一个线程来说的，主要作用是优化同一个线程多次获取一个锁的情况， 当一个线程执行了一个 synchronized 方法的时候，肯定能得到对象的 monitor ，这个方法所在的对象就会在 Mark Work 处设为偏向锁标记，还会有一个字段指向拥有锁的这个线程的线程 ID 。</p><p>当这个线程再次访问同一个 synchronized 方法的时候，如果按照通常的方法，这个线程还是要尝试获取这个对象的 monitor ，再执行这个 synchronized 方法。但是由于 Mark Word 的存在，当第二个线程再次来访问的时候，就会检查这个对象的 Mark Word 的偏向锁标记，再判断一下这个字段记录的线程 ID 是不是跟第二个线程的 ID 是否相同的。如果相同，就无需再获取 monitor 了，直接进入方法体中。</p></li></ol><p>如果是另一个线程访问这个 synchronized 方法，那么实际情况会如何呢？：偏向锁会被取消掉。</p><ol start="2"><li>轻量级锁：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程再争抢时，会发现该对象头中的 Mark Word 已经是偏向锁，但里面储存的线程 ID 并不是自己（是第一个线程），那么她会进行 CAS(Compare and Swap)，从而获取到锁，这里面存在两种情况：<ol><li>获取到锁成功（一共只有两个线程）：那么它会将 Mark Word 中的线程 ID 由第一个线程变成自己(偏向锁标记位保持不表)，这样该对象依然会保持偏向锁的状态</li><li>获取锁失败（一共不止两个线程）：则表示这时可能会有多个线程同时再尝试争抢该对象的锁，那么这是偏向锁就会进行升级，升级为轻量级锁</li><li>自旋锁，若自旋失败，那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到 moniter(即内核态)，自旋最大的特点是避免了线程从用户态进入到内核态。</li></ol></li></ol><h3 id="6-Wait-Notify"><a href="#6-Wait-Notify" class="headerlink" title="6.Wait/Notify"></a>6.Wait/Notify</h3><h4 id="1）原理"><a href="#1）原理" class="headerlink" title="1）原理"></a>1）原理</h4><p><img src="https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li><strong>当线程0获得到了锁, 成为Monitor的Owner, 但是此时它发现自己想要执行synchroized代码块的条件不满足; 此时它就调用obj.wait方法, 进入到Monitor中的WaitSet集合, 此时线程0的状态就变为WAITING</strong></li><li>处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为<code>阻塞状态</code>，CPU都不会分给他们时间片。但是有所区别：<ul><li><code>BLOCKED状态</code>的线程是在<code>竞争锁对象</code>时，<code>发现Monitor的Owner已经是别的线程了</code><strong>，此时就会进入EntryList中，并处于BLOCKED状态</strong></li><li><code>WAITING状态</code>的线程是<code>获得了对象的锁</code>，但是自身的原因无法执行<code>synchroized的临界区资源</code>需要进入<code>阻塞状态</code>时，<strong>锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</strong></li></ul></li><li><strong>处于BLOCKED状态的线程会在锁被释放的时候被唤醒</strong></li><li><strong>处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁</strong>(此时就将锁升级为<code>重量级锁</code>)</li></ul><h4 id="2）Wait与Sleep的区别"><a href="#2）Wait与Sleep的区别" class="headerlink" title="2）Wait与Sleep的区别"></a>2）Wait与Sleep的区别</h4><ul><li>Sleep 是 Thread 类的静态方法，Wait 是 Object 的方法，Object 又是所有类的父类，所以所有类都有Wait方法。</li></ul><ul><li>Sleep 在阻塞的时候不会释放锁，而 Wait 在阻塞的时候会释放锁，它们都会释放 CPU 资源。</li><li>Sleep 不需要与 synchronized 一起使用，而 Wait 需要与 synchronized 一起使用（对象被锁以后才能使用）</li></ul><ul><li>使用 wait 一般需要搭配 notify 或者 notifyAll 来使用，不然会让线程一直等待。</li></ul><h4 id="3）优雅地使用-wait-notify"><a href="#3）优雅地使用-wait-notify" class="headerlink" title="3）优雅地使用 wait/notify"></a>3）优雅地使用 wait/notify</h4><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用 wait 。这样会<strong>将对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用 sleep，<strong>会导致所有线程都进入阻塞</strong>，导致所有线程都没法运行，直到当前线程 sleep 结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有多个线程在运行时，对象调用了 wait 方法，此时这些线程都会进入 WaitSet 中等待。如果这时使用了 notify 方法，可能会<strong>造成虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用 notifyAll 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span><br>lock.wait();<br>&#125;<br><span class="hljs-comment">//满足条件后再运行</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-comment">//唤醒所有等待线程</span><br>lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）同步模式之保护性暂停"><a href="#4）同步模式之保护性暂停" class="headerlink" title="4）同步模式之保护性暂停"></a>4）同步模式之保护性暂停</h4><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果，要点：</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果<strong>有结果不断从一个线程到另一个线程</strong> 那么可以使用<code>消息队列</code>（见生产者/消费者）</li><li>JDK 中，<code>join 的实现、Future 的实现</code>，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到<code>同步模式</code></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e73412e2618ca103105cce41f4b228c9.png"></p><ul><li><code>一方等待另一方的执行结果</code>举例</li><li>举例, 线程1等待线程2下载的结果,并获取该结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 多线程同步模式 - 一个线程需要等待另一个线程的执行结果</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardeObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 线程1等待线程2的下载结果</span><br>        GuardeObject guardeObject = <span class="hljs-keyword">new</span> GuardeObject();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>            List&lt;String&gt; list = (List&lt;String&gt;) guardeObject.get();<br>            log.debug(<span class="hljs-string">&quot;结果大小:&#123;&#125;&quot;</span>, list.size());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行下载&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;String&gt; list = Downloader.download();<br>                guardeObject.complete(list);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObject</span> </span>&#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 防止虚假唤醒</span><br>            <span class="hljs-comment">// 没有结果</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>线程t1</code> 等待 <code>线程t2</code>的结果, 可以<code>设置超时时间</code>, 如果超过时间还没返回结果,此时就不等了.退出while循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardeObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 线程1等待线程2的下载结果</span><br>        GuardeObject guardeObject = <span class="hljs-keyword">new</span> GuardeObject();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Object obj = guardeObject.get(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, obj);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            <span class="hljs-comment">// Sleeper.sleep(1); // 在等待时间内</span><br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>            guardeObject.complete(<span class="hljs-keyword">new</span> Object());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObject</span> </span>&#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示等待多久. 这里假如是2s</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,</span><br>                    <span class="hljs-comment">// 进入while循环的时候response还是空,此时判断1s&lt;=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了</span><br>                    <span class="hljs-comment">// 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)</span><br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在等待时间内的情况</span><br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">41.627</span> guizy.GuardeObjectTest [t1] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">41.627</span> guizy.GuardeObjectTest [t2] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">42.633</span> guizy.GuardeObjectTest [t1] - 结果是:java.lang.Object@1e1d0168<br><br><span class="hljs-comment">// 超时的情况</span><br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">24.663</span> guizy.GuardeObjectTest [t2] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">24.663</span> guizy.GuardeObjectTest [t1] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">26.667</span> guizy.GuardeObjectTest [t1] - 结果是:<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><ul><li>关于超时的增强，在<code>join(long millis) 的源码</code>中得到了体现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> base = System.currentTimeMillis();<br>    <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// join一个指定的时间</span><br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多任务版GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。</li><li>不仅能够<code>解耦</code>【结果等待者】和【结果生产者】，还能够同时支持<code>多个任务的管理</code>。和生产者消费者模式的区别就是：<strong>这个产生结果的线程和使用结果的线程是一一对应的关系，但是生产者消费者模式并不是。</strong></li><li>rpc框架的调用中就使用到了这种模式。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/8af156fb943083720b551f6e52ddd03c.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 同步模式保护性暂停模式 (多任务版)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardedObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> People().start();<br>        &#125;<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br>            <span class="hljs-keyword">new</span> Postman(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.People&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 收信</span><br>        GuardedObject guardedObject = Mailboxes.createGuardedObject();<br>        log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>        Object mail = guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Postman&quot;)</span><br><span class="hljs-comment">// 邮寄员类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Postman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String mail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.mail = mail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>        guardedObject.complete(mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 信箱类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mailboxes</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">getGuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-comment">//根据id获取到box并删除对应的key和value,避免堆内存爆了</span><br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">createGuardedObject</span><span class="hljs-params">()</span> </span>&#123;<br>        GuardedObject go = <span class="hljs-keyword">new</span> GuardedObject(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 用来传递信息的作用, 当多个类使用GuardedObject,就很不方便,此时需要一个设计一个解耦的中间类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">// 标记GuardedObject</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示等待多久. 这里假如是2s</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,</span><br>                    <span class="hljs-comment">// 进入while循环的时候response还是空,此时判断1s&lt;=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了</span><br>                    <span class="hljs-comment">// 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)</span><br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）异步模式之生产者-消费者（重点）"><a href="#5）异步模式之生产者-消费者（重点）" class="headerlink" title="5）异步模式之生产者/消费者（重点）"></a>5）异步模式之生产者/消费者（重点）</h4><ul><li>与前面的<code>保护性暂停</code>中的 <code>GuardedObject</code> 不同，<strong>不需要</strong><code>产生结果</code>和<code>消费结果</code>的<code>线程一一对应 (一个生产一个消费)</code></li><li><strong>消费队列</strong> 可以用来<strong>平衡生产和消费的线程资源</strong></li><li><strong>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</strong></li><li><strong>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</strong></li></ul><ul><li>JDK 中各种 <a href="https://blog.csdn.net/yanpenglei/article/details/79556591">阻塞队列</a>，采用的就是这种模式</li></ul><p>异步模式中, 生产者产生消息之后消息没有被立刻消费<br>同步模式中, 消息在产生之后被立刻消费了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/82487e714da1c44453d46a61d6dcb27b.png"></p><ul><li>我们下面写的小例子是<code>线程间通信</code>的<code>消息队列</code>，要注意区别,像<code>RabbitMQ</code>等消息框架是<code>进程间通信</code>的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 异步模式之生产者/消费者</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 18:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;giuzy.ProductConsumerTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id, <span class="hljs-string">&quot;值&quot;</span> + id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Sleeper.sleep(<span class="hljs-number">1</span>);<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 消息队列类,在线程之间通信</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.MessageQueue&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span> (list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.440</span> guizy.MessageQueue [生产者<span class="hljs-number">1</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.443</span> guizy.MessageQueue [生产者<span class="hljs-number">0</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.444</span> guizy.MessageQueue [生产者<span class="hljs-number">2</span>] - 队列已满, 生产者线程等待<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.439</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.439</span> guizy.MessageQueue [生产者<span class="hljs-number">2</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">55.439</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">56.440</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">57.441</span> guizy.MessageQueue [消费者] - 队列为空, 消费者线程等待<br></code></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li>当调用 wait 时，首先需要确保调用了 wait 方法的线程已经持有了对象的锁(调用 wait 方法的代码片段需要放在 sychronized 块或者时 sychronized 方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁)</li><li>当调用 wait 时，该线程就会释放掉这个对象的锁，然后进入等待状态 (wait set)</li><li>当线程调用了 wait 后进入到等待状态时，它就可以等待其他线程调用相同对象的 notify 或者 notifyAll 方法使得自己被唤醒</li><li>一旦这个线程被其它线程唤醒之后，该线程就会与其它线程以同开始竞争这个对象的锁(公平竞争)；只有当该线程获取到对象的锁后，线程才会继续往下执行</li><li>当调用对象的 notify 方法时，他会随机唤醒对象等待集合 (wait set) 中的任意一个线程，当某个线程被唤醒后，它就会与其它线程一同竞争对象的锁</li><li>当调用对象的 notifyAll 方法时，它会唤醒该对象等待集合 (wait set) 中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁</li><li>在某一时刻，只有唯一的一个线程能拥有对象的锁</li></ol><h3 id="7-park-amp-unpark"><a href="#7-park-amp-unpark" class="headerlink" title="7.park &amp; unpark"></a>7.park &amp; unpark</h3><h4 id="1）-基本使用"><a href="#1）-基本使用" class="headerlink" title="1） 基本使用"></a>1） 基本使用</h4><p>park &amp; unpark是LockSupport线程通信工具类的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.park();<br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark;<br></code></pre></td></tr></table></figure><p>先调用unpark后，在调用park，此时park不会暂停线程</p><h4 id="2）park-amp-unpark原理"><a href="#2）park-amp-unpark原理" class="headerlink" title="2）park &amp; unpark原理"></a>2）park &amp; unpark原理</h4><p><code>每个线程</code>都有自己的一个 <code>Parker 对象</code>，由三部分组成 <strong>_counter， _cond和 _mutex</strong></p><ul><li>打个比喻线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 _ cond就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li><li><strong>调用 park 就是要看需不需要停下来歇息</strong><ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li><strong>调用 unpark，就好比令干粮充足</strong><ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进</li><li>因为背包空间有限，<strong>多次调用 unpark 仅会补充一份备用干粮</strong></li></ul></li></ul><h5 id="先调用park在调用unpark的过程"><a href="#先调用park在调用unpark的过程" class="headerlink" title="先调用park在调用unpark的过程"></a><strong>先调用park在调用unpark的过程</strong></h5><ul><li><strong>调用park</strong><ul><li>当前线程调用 <strong>Unsafe.park()</strong> 方法</li><li><strong>检查 _counter, 本情况为0,</strong> 这时, 获得<code>_mutex 互斥锁</code><strong>(mutex对象有个等待队列 _cond)</strong></li><li>线程进入 _cond 条件变量<code>阻塞</code></li><li>设置<code>_counter = 0</code> (没干粮了)</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/090e9cb2aed20d43c147ec0ea6470d5e.png"></p><ul><li>调用unpark<ul><li>调用<code>Unsafe.unpark(Thread_0)方法</code>，设置<code>_counter 为 1</code></li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 <code>恢复运行</code></li><li><strong>设置 _counter 为 0</strong></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/ca03643f837f34098def91bfadc54bd6.png"></p><h5 id="先调用unpark在调用park的过程"><a href="#先调用unpark在调用park的过程" class="headerlink" title="先调用unpark在调用park的过程"></a><strong>先调用unpark在调用park的过程</strong></h5><ul><li>调用<code>Unsafe.unpark(Thread_0)</code>方法，设置 <code>_counter 为 1</code></li><li>当前<code>线程</code>调用 <code>Unsafe.park()</code> 方法</li><li>检查 <code>_counter</code>，本情况为 <code>1</code>，这时线程 <strong>无需阻塞，继续运行</strong></li><li>设置 _counter 为 0</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d0d3270088a031c2066af2762e894413.png"></p><h3 id="8-线程状态转换"><a href="#8-线程状态转换" class="headerlink" title="8.线程状态转换"></a>8.线程状态转换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png"></p><p><img src="https://img-blog.csdnimg.cn/20201221214359753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li>1.<strong>NEW &lt;–&gt; RUNNABLE</strong><ul><li>t.start()方法时，NEW —&gt; RUNNABLE</li></ul></li><li>2.<strong>RUNNABLE &lt;-&gt;WAITING</strong><ul><li>线程用synchronized(obj)获取了对象锁后<ul><li>调用 <strong>obj.wait()方法时，t 线程进入waitSet</strong>中, 从<code>RUNNABLE --&gt; WAITING</code></li><li>调用 <strong>obj.notify()，obj.notifyAll()，t.interrupt()</strong> 时, 唤醒的线程都到<strong>entrySet</strong>阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列,和其他线程再进行 <strong>竞争锁</strong><ul><li><strong>竞争锁成功</strong>，t 线程从 <code>WAITING --&gt; RUNNABLE</code></li><li><strong>竞争锁失败</strong>，t 线程从 <code>WAITING --&gt; BLOCKED</code></li></ul></li></ul></li></ul></li><li>3.<strong>RUNNABLE &lt;–&gt; WAITING</strong><ul><li><strong>当前线程</strong>调用 <strong>t.join()</strong> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> ,注意是<strong>当前线程</strong>在t线程对象在<strong>waitSet</strong>上等待</li><li><strong>t 线程运行结束，或调用了当前线程的 interrupt() 时</strong>，<strong>当前线程</strong>从 <code>WAITING --&gt; RUNNABLE</code></li></ul></li><li>4.<strong>RUNNABLE &lt;–&gt; WAITING</strong><ul><li>当前线程调用 <strong>LockSupport.park()</strong> 方法会让<strong>当前线程</strong>从<code>RUNNABLE --&gt; WAITING</code></li><li>调用 <strong>LockSupport.unpark(目标线程)</strong> 或调用了线程 的 <strong>interrupt()</strong> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li></ul></li></ul><p><strong>Runnable 和 Timed-Waiting的相互转换</strong></p><ul><li>5.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING (带超时时间的wait)</strong><ul><li>t 线程用<code>synchronized(obj)</code> 获取了<code>对象锁</code>后<ul><li>调用 <strong>obj.wait(long n)</strong> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify() ， obj.notifyAll() ，t.interrupt()</code> 时; 唤醒的线程都到<strong>entrySet</strong>阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列,和其他线程再进行 <strong>竞争锁</strong><ul><li>竞争锁成功，t 线程从 <strong>TIMED_WAITING –&gt; RUNNABLE</strong></li><li>竞争锁失败，t 线程从 <strong>TIMED_WAITING –&gt; BLOCKED</strong></li></ul></li></ul></li></ul></li><li>6.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul><li>当前线程调用 <strong>t.join(long n)</strong> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code> 注意是当前线程在t 线程对象的<strong>waitSet</strong>等待</li><li>当前线程等待时间超过了 n 毫秒，<strong>或t 线程运行结束，或调用了当前线程的 interrupt() 时</strong>，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul></li><li>7.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul><li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒或调用了线程的 <strong>interrupt()</strong> ，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul></li><li>8.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>用<code>LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul></li><li>9.<strong>RUNNABLE &lt;–&gt; BLOCKED</strong><ul><li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li></ul></li><li>10.<strong>RUNNABLE &lt;–&gt; TERMINATED</strong><ul><li>当前线程所有代码运行完毕，进入 TERMINATED</li></ul></li></ul><h3 id="9-活跃性"><a href="#9-活跃性" class="headerlink" title="9.活跃性"></a>9.活跃性</h3><p><img src="https://img-blog.csdnimg.cn/20210202223351594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h4 id="1）多把锁"><a href="#1）多把锁" class="headerlink" title="1）多把锁"></a>1）多把锁</h4><p>将锁粒度细分</p><ul><li>好处，可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BigRoom bigRoom = <span class="hljs-keyword">new</span> BigRoom();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; bigRoom.sleep(), <span class="hljs-string">&quot;小南&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; bigRoom.study(), <span class="hljs-string">&quot;小女&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoom&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 相当于串行执行, 因为锁对象是整个屋子, 所以并发性很低</span><br><span class="hljs-number">12</span>:<span class="hljs-number">16</span>:<span class="hljs-number">15.952</span> guizy.BigRoom [小南] - sleeping <span class="hljs-number">2</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">16</span>:<span class="hljs-number">17.954</span> guizy.BigRoom [小女] - study <span class="hljs-number">1</span> 小时<br></code></pre></td></tr></table></figure><ul><li>改进让<code>小南, 小女</code>获取不同的锁即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BigRoom sleepRoom = <span class="hljs-keyword">new</span> BigRoom();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BigRoom studyRoom = <span class="hljs-keyword">new</span> BigRoom();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 不同对象调用</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; sleepRoom.sleep(), <span class="hljs-string">&quot;小南&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; studyRoom.study(), <span class="hljs-string">&quot;小女&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为使用的是不同的锁对象</span><br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">50.580</span> guizy.BigRoom [小女] - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">50.580</span> guizy.BigRoom [小南] - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure><h4 id="2）活跃性"><a href="#2）活跃性" class="headerlink" title="2）活跃性"></a>2）活跃性</h4><ul><li>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 <strong>活跃性</strong></li></ul><h5 id="1-死锁（重点）"><a href="#1-死锁（重点）" class="headerlink" title="1.死锁（重点）"></a>1.死锁（重点）</h5><ul><li>有这样的情况：一个线程需要 <strong>同时获取多把锁</strong>，这时就容易发生死锁</li></ul><p>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">2000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br><br>&#125;<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">synchronized</span> (B) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">synchronized</span> (A) &#123;<br><br>&#125;<br>&#125;<br>&#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2发生死锁的必要条件（重点）"><a href="#1-2发生死锁的必要条件（重点）" class="headerlink" title="1.2发生死锁的必要条件（重点）"></a>1.2发生死锁的必要条件（重点）</h5><ul><li>互斥条件<ul><li>在一段时间内，<code>一种资源只能被一个进程所使</code></li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h5 id="1-3定位死锁的方法"><a href="#1-3定位死锁的方法" class="headerlink" title="1.3定位死锁的方法"></a>1.3定位死锁的方法</h5><ol><li>JPS+JStack 进程ID</li><li>jconsole检测死锁</li></ol><h5 id="1-4死锁举例-哲学家就餐问题（重点）"><a href="#1-4死锁举例-哲学家就餐问题（重点）" class="headerlink" title="1.4死锁举例-哲学家就餐问题（重点）"></a>1.4死锁举例-哲学家就餐问题（重点）</h5><p><img src="https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><p>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用synchronized加锁, 导致哲学家就餐问题, 死锁: 核心原因是因为synchronized的锁是不可打断的, 进入阻塞队列</span><br><span class="hljs-comment"> *                  需要一直等待别的线程释放锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhilosopherEat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>        Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>        Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>        Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>        Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Chopstick left;<br>    <span class="hljs-keyword">final</span> Chopstick right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 尝试获取左手筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 尝试获取右手筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span></span>&#123;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 程序只执行了下面的打印, 没有停止, 没有打印</span><br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.346</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.346</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.850</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.850</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">56.351</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">56.852</span> guizy.Philosopher [亚里士多德] - eating...<br></code></pre></td></tr></table></figure><p>通过<code>jps, jstack 进程id</code>查看死锁原因<br><code>Found one Java-level deadlock:</code> 发现了一个Java级别的死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;阿基米德&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000001ae2a358</span> (object <span class="hljs-number">0x00000000d6ea7420</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;苏格拉底&quot;</span><br><span class="hljs-string">&quot;苏格拉底&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb3518</span> (object <span class="hljs-number">0x00000000d6ea7430</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;柏拉图&quot;</span><br><span class="hljs-string">&quot;柏???图&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb3468</span> (object <span class="hljs-number">0x00000000d6ea7440</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;亚里士多德&quot;</span><br><span class="hljs-string">&quot;亚里士多德&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb0bd8</span> (object <span class="hljs-number">0x00000000d6ea7450</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;赫拉克利特&quot;</span><br><span class="hljs-string">&quot;赫拉克利特&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb0c88</span> (object <span class="hljs-number">0x00000000d6ea7460</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;阿基米德&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;阿基米德&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7420</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7460</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;苏格拉底&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7430</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7420</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;柏拉图&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7440</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7430</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;亚里士多德&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7450</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7440</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;赫拉克利特&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7460</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7450</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><h5 id="1-5、避免死锁方法"><a href="#1-5、避免死锁方法" class="headerlink" title="1.5、避免死锁方法"></a>1.5、避免死锁方法</h5><ul><li>在线程使用锁对象时, 采用<strong>固定加锁的顺序</strong>, 可以使用Hash值的大小来确定加锁的先后</li><li>尽可能缩减加锁的范围，等到操作共享变量的时候才加锁</li><li>使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png"></p><h4 id="2-活锁"><a href="#2-活锁" class="headerlink" title="2.活锁"></a>2.活锁</h4><p><code>活锁</code>出现在两个线程 <strong>互相改变对方的结束条件</strong>，谁也无法结束</p><h5 id="2-1-避免活锁的方法"><a href="#2-1-避免活锁的方法" class="headerlink" title="2.1 避免活锁的方法"></a>2.1 避免活锁的方法</h5><ul><li>在线程执行时，中途给予 <strong>不同的间隔时间</strong>, 让某个线程先结束即可。</li></ul><h5 id="2-2死锁和活锁的区别"><a href="#2-2死锁和活锁的区别" class="headerlink" title="2.2死锁和活锁的区别"></a>2.2死锁和活锁的区别</h5><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li></ul><ul><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h4 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3.饥饿"></a>3.饥饿</h4><ul><li>某些线程因为优先度太低，导致一直无法获取资源的现象</li><li>在使用顺序加锁时，可能会出现饥饿现象</li></ul><h3 id="10-ReentrantLock"><a href="#10-ReentrantLock" class="headerlink" title="10.ReentrantLock"></a>10.ReentrantLock</h3><h4 id="1-支持锁重入"><a href="#1-支持锁重入" class="headerlink" title="1.支持锁重入"></a>1.支持锁重入</h4><ul><li>可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把<code>锁的拥有者</code>，因此 <strong>有权利再次获取这把锁</strong></li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry main...&quot;</span>);<br>            m1();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m1...&quot;</span>);<br>            m2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;entry m2....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.324</span> guizy.ReentrantTest [main] - entry main...<br><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.326</span> guizy.ReentrantTest [main] - entry m1...<br><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.326</span> guizy.ReentrantTest [main] - entry m2....<br></code></pre></td></tr></table></figure><h4 id="2-可中断（针对于lockInterruptibly-方法获得的中断锁）直接退出阻塞队列，获取锁失败"><a href="#2-可中断（针对于lockInterruptibly-方法获得的中断锁）直接退出阻塞队列，获取锁失败" class="headerlink" title="2.可中断（针对于lockInterruptibly()方法获得的中断锁）直接退出阻塞队列，获取锁失败"></a>2.可中断（针对于lockInterruptibly()方法获得的中断锁）直接退出阻塞队列，获取锁失败</h4><p><strong>synchronized</strong> 和 <strong>reentrantlock.lock()</strong> 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断</p><ul><li>可被中断的锁, 通过<code>lock.lockInterruptibly()</code>获取的锁对象, 可以通过调用<strong>阻塞线程的interrupt()方法</strong></li><li>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，<strong>获得锁失败</strong><ul><li>处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</li></ul></li><li>可中断的锁，在一定程度上可以被动的减少死锁的概率，之所以被动，是因为我们需要手动调用<code>阻塞线程的interrupt</code>方法;</li></ul><p>测试使用<code>lock.lockInterruptibly()</code>可以从阻塞队列中,打断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的可打断锁方法 lock.lockInterruptibly();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1线程启动...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>); <span class="hljs-comment">//没有获得锁就被打断跑出的异常</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程获得了锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 主线程获得锁(此锁不可打断)</span><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;main线程获得了锁&quot;</span>);<br>        <span class="hljs-comment">// 启动t1线程</span><br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            t1.interrupt();            <span class="hljs-comment">//打断t1线程</span><br>            log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">09.145</span> guizy.ReentrantTest [main] - main线程获得了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">09.148</span> guizy.ReentrantTest [t1] - t1线程启动...<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.149</span> guizy.ReentrantTest [main] - 执行打断<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.149</span> guizy.ReentrantTest [t1] - 等锁的过程中被打断<br>java.lang.InterruptedException<br>at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">898</span>)<br>at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">1222</span>)<br>at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>)<br>at com.guizy.reentrantlock.ReentrantTest.lambda$main$<span class="hljs-number">0</span>(ReentrantTest.java:<span class="hljs-number">25</span>)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure><p>测试使用<code>lock.lock()</code>不可以从阻塞队列中打断, 一直等待别的线程释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1线程启动...&quot;</span>);<br>                lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程获得了锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 主线程获得锁(此锁不可打断)</span><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;main线程获得了锁&quot;</span>);<br>        <span class="hljs-comment">// 启动t1线程</span><br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">4</span>);<br>            t1.interrupt();            <span class="hljs-comment">//打断t1线程</span><br>            log.debug(<span class="hljs-string">&quot;main线程执行打断&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>lock()锁不能被打断</strong>, 在主线程中调用t1.interrupt(), 没用, 当主线程释放锁之后, t1获得了锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">01.329</span> guizy.ReentrantTest [main] - main线程获得了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">01.331</span> guizy.ReentrantTest [t1] - t1线程启动...<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">05.333</span> guizy.ReentrantTest [main] - main线程执行打断<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">05.333</span> guizy.ReentrantTest [t1] - t1线程获得了锁<br></code></pre></td></tr></table></figure><h4 id="3-锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败"><a href="#3-锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败" class="headerlink" title="3.锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败"></a>3.锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败</h4><p><strong>防止无限制等待, 减少死锁</strong></p><ul><li>使用 <strong>lock.tryLock()</strong> 方法会<code>返回获取锁是否成功</code>。如果成功则返回true，反之则返回false。</li></ul><ul><li>并且<code>tryLock方法</code>可以设置<strong>指定等待时间</strong>，参数为：<strong>tryLock(long timeout, TimeUnit unit)</strong> , 其中timeout为最长等待时间，TimeUnit为时间单位</li></ul><p>获取锁的过程中, 如果<code>超过等待时间</code>, <code>或者被打断</code>, 就直接从<code>阻塞队列</code>移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)</p><ul><li><strong>不设置等待时间, 立即失败</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(), 获取锁立即失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);<br>            <span class="hljs-comment">// 此时肯定获取失败, 因为主线程已经获得了锁对象</span><br>            <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>                log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 主线程2s之后才释放锁</span><br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.726</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.728</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.728</span> guizy.WaitNotifyTest [t1] - 获取立刻失败，返回<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">21.728</span> guizy.WaitNotifyTest [main] - 释放了锁<br></code></pre></td></tr></table></figure><ul><li><strong>设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(long mills), 超过锁设置的等待时间,就从阻塞队列移除</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 设置等待时间, 超过等待时间 / 被打断, 都会获取锁失败; 退出阻塞队列</span><br>                <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取锁超时，返回&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.debug(<span class="hljs-string">&quot;被打断了, 获取锁失败, 返回&quot;</span>);<br>                e.printStackTrace();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>        t1.start();<br><span class="hljs-comment">//        t1.interrupt();</span><br>        <span class="hljs-comment">// 主线程2s之后才释放锁</span><br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;main线程释放了锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 超时的打印</span><br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">56.647</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">56.651</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">57.652</span> guizy.WaitNotifyTest [t1] - 获取锁超时，返回<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">58.652</span> guizy.WaitNotifyTest [main] - main线程释放了锁<br><br><span class="hljs-comment">// 中断的打印</span><br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.258</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.260</span> guizy.WaitNotifyTest [main] - main线程释放了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.261</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.261</span> guizy.WaitNotifyTest [t1] - 被打断了, 获取锁失败, 返回<br>java.lang.InterruptedException<br></code></pre></td></tr></table></figure><h4 id="通过lock-tryLock-来解决-哲学家就餐问题-重点"><a href="#通过lock-tryLock-来解决-哲学家就餐问题-重点" class="headerlink" title="通过lock.tryLock()来解决, 哲学家就餐问题 (重点)"></a>通过<code>lock.tryLock()</code>来解决, <code>哲学家就餐</code>问题 (<code>重点</code>)</h4><p><code>lock.tryLock(时间)</code> : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用了ReentrantLock锁, 该类中有一个tryLock()方法, 在指定时间内获取不到锁对象, 就从阻塞队列移除,不用一直等待。</span><br><span class="hljs-comment"> *              当获取了左手边的筷子之后, 尝试获取右手边的筷子, 如果该筷子被其他哲学家占用, 获取失败, 此时就先把自己左手边的筷子,</span><br><span class="hljs-comment"> *              给释放掉. 这样就避免了死锁问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhilosopherEat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>        Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>        Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>        Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>        Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Chopstick left;<br>    <span class="hljs-keyword">final</span> Chopstick right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 获得了左手边筷子 (针对五个哲学家, 它们刚开始肯定都可获得左筷子)</span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 此时发现它的right筷子被占用了, 使用tryLock(), </span><br>                <span class="hljs-comment">// 尝试获取失败, 此时它就会将自己左筷子也释放掉</span><br>                    <span class="hljs-comment">// 临界区代码</span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123; <span class="hljs-comment">//尝试获取右手边筷子, 如果获取失败, 则会释放左边的筷子</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            eat();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    left.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承ReentrantLock, 让筷子类称为锁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">01.793</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">01.795</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.293</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.295</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.794</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.796</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.294</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.296</span> guizy.Philosopher [柏拉图] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.795</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.797</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.295</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.297</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.796</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.798</span> guizy.Philosopher [阿基米德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">05.296</span> guizy.Philosopher [柏拉图] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">05.299</span> guizy.Philosopher [赫拉克利特] - eating...<br><br></code></pre></td></tr></table></figure><h4 id="4-公平锁new-ReentrantLock-true"><a href="#4-公平锁new-ReentrantLock-true" class="headerlink" title="4.公平锁new ReentrantLock(true)"></a>4.公平锁new ReentrantLock(true)</h4><ul><li><strong>ReentrantLock默认是非公平锁, 可以指定为公平锁。</strong></li><li>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。一般不设置<code>ReentrantLock</code>为公平的, 会降低<code>并发度</code></li><li><code>Synchronized</code>底层的<code>Monitor锁</code>就是不公平的, 和谁先进入<code>阻塞队列</code>是没有关系的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h5 id="4-1、什么是公平锁？什么是非公平锁"><a href="#4-1、什么是公平锁？什么是非公平锁" class="headerlink" title="4.1、什么是公平锁？什么是非公平锁"></a>4.1、什么是公平锁？什么是非公平锁</h5><h5 id="公平锁-new-ReentrantLock-true"><a href="#公平锁-new-ReentrantLock-true" class="headerlink" title="公平锁 (new ReentrantLock(true))"></a>公平锁 (new ReentrantLock(true))</h5><ul><li>公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上</li><li>只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁</li></ul><h5 id="非公平锁-synchronized-new-ReentrantLock"><a href="#非公平锁-synchronized-new-ReentrantLock" class="headerlink" title="非公平锁 (synchronized, new ReentrantLock())"></a>非公平锁 (synchronized, new ReentrantLock())</h5><ul><li>非公平锁, 当阻塞队列中已经有等待的线程A了, 此时后到的线程B, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程B就先获得到锁了</li></ul><p>所以公平和非公平的区别 : <strong>线程执行同步代码块时, 是否回去尝试获取锁</strong>, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的</p><ul><li>如果不进如队列呢? 线程一直尝试获取锁不就行了?<ul><li>一直尝试获取锁, 在synchronized轻量级锁升级为重量级锁时, 做的一个优化, 叫做<code>自旋锁</code>, 一般很消耗资源, cpu一直空转, 最后获取锁也失败, 所以不推荐使用。在jdk6对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等</li></ul></li></ul><h4 id="5-条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒"><a href="#5-条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒" class="headerlink" title="5.条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用await/signal方法, 等待/唤醒"></a>5.条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用<code>await/signal</code>方法, 等待/唤醒</h4><ul><li><strong>Synchronized</strong> 中也有<code>条件变量</code>，就是<code>Monitor监视器</code>中的 <code>waitSet等待集合</code>，当条件不满足时进入<code>waitSet 等待</code></li><li><strong>ReentrantLock</strong> 的条件变量比 synchronized 强大之处在于,它是 <strong>支持多个条件变量</strong></li><li>这就好比synchronized 是那些不满足条件的线程都在<code>一间休息室</code>等通知; <strong>(此时会造成虚假唤醒)</strong>, 而 ReentrantLock 支持<code>多间休息室</code>，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; <strong>(可以避免虚假唤醒)</strong></li></ul><p>使用要点</p><ul><li>await 前需要 <strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 <code>conditionObject</code> (条件变量)中等待</li><li>await 的线程被唤醒（或打断、或超时）去重新竞争 lock 锁<ul><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul></li><li>signal 方法用来唤醒<code>条件变量(等待室)</code>汇总的某一个等待的线程</li><li>signalAll方法, 唤醒<code>条件变量(休息室)</code>中的所有线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock可以设置多个条件变量(多个休息室), 相对于synchronized底层monitor锁中waitSet</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ConditionVariable&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionVariable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">// 等待烟的休息室</span><br>    <span class="hljs-keyword">static</span> Condition waitCigaretteSet = lock.newCondition();<br>    <span class="hljs-comment">// 等外卖的休息室</span><br>    <span class="hljs-keyword">static</span> Condition waitTakeoutSet = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小南进入到 等烟的休息室</span><br>                        waitCigaretteSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;烟来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小女进入到 等外卖的休息室</span><br>                        waitTakeoutSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送外卖的来咯~&quot;</span>);<br>                hasTakeout = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 唤醒等外卖的小女线程</span><br>                waitTakeoutSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送烟的来咯~&quot;</span>);<br>                hasCigarette = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 唤醒等烟的小南线程</span><br>                waitCigaretteSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:08:<span class="hljs-number">58.231</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="hljs-keyword">false</span>]<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.234</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.235</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="hljs-keyword">false</span>]<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.235</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！<br><span class="hljs-number">15</span>:08:<span class="hljs-number">59.232</span> guizy.WaitNotifyTest [送外卖的] - 送外卖的来咯~<br><span class="hljs-number">15</span>:08:<span class="hljs-number">59.233</span> guizy.WaitNotifyTest [小女] - 外卖来咯, 可以开始干活了<br><span class="hljs-number">15</span>:09:<span class="hljs-number">00.233</span> guizy.WaitNotifyTest [送烟的] - 送烟的来咯~<br><span class="hljs-number">15</span>:09:<span class="hljs-number">00.234</span> guizy.WaitNotifyTest [小南] - 烟来咯, 可以开始干活了<br></code></pre></td></tr></table></figure><h3 id="11-同步模式之顺序控制"><a href="#11-同步模式之顺序控制" class="headerlink" title="11.同步模式之顺序控制"></a>11.同步模式之顺序控制</h3><ul><li>假如两个线程，线程A打印1，线程B打印2</li><li>要求：程序先打印2，在打印1</li></ul><h4 id="1-Wait-Notify版本实现"><a href="#1-Wait-Notify版本实现" class="headerlink" title="1.Wait/Notify版本实现"></a>1.Wait/Notify版本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用wait/notify来实现顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2Runned = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 进入等待(waitset), 会释放锁</span><br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-keyword">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用ReentrantLock的await-signal"><a href="#2-使用ReentrantLock的await-signal" class="headerlink" title="2.使用ReentrantLock的await/signal"></a>2.使用ReentrantLock的await/signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用ReentrantLock的await/sinal 来实现顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Condition condition = lock.newCondition();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2Runned = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 临界区</span><br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        condition.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-keyword">true</span>;<br>                condition.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用LockSupport中的park-unpark"><a href="#3-使用LockSupport中的park-unpark" class="headerlink" title="3.使用LockSupport中的park/unpark"></a>3.使用LockSupport中的park/unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用LockSupport中的park,unpark来实现, 顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>需求：</p><ul><li><strong>线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcabc</strong></li></ul><h5 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a>wait/notify版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWaitNotify</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    WaitNotify waitNotify = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    &#125;,<span class="hljs-string">&quot;a线程&quot;</span>).start;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    &#125;,<span class="hljs-string">&quot;b线程&quot;</span>).start;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-string">&quot;c线程&quot;</span>).start;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.WaitNotify&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输出内容    等待标记    下一个标记</span><br><span class="hljs-comment">        a           1          2</span><br><span class="hljs-comment">        b           2          3</span><br><span class="hljs-comment">        c           3          1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (waitFlag != <span class="hljs-keyword">this</span>.flag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-keyword">this</span>.flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-await-signal版本"><a href="#2-await-signal版本" class="headerlink" title="2.await/signal版本"></a>2.await/signal版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用await/signal来实现三个线程交替打印abcabcabcabcabc</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 17:10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAwaitSignal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br>        Condition a_condition = awaitSignal.newCondition();<br>        Condition b_condition = awaitSignal.newCondition();<br>        Condition c_condition = awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a_condition, b_condition);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b_condition, c_condition);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c_condition, a_condition);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;==========开始=========&quot;</span>);<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            a_condition.signal();  <span class="hljs-comment">//首先唤醒a线程</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    condition.await();<br>                    <span class="hljs-comment">//System.out.print(&quot;i:===&quot;+i);</span><br>                    System.out.print(str);<br>                    next.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-LockSupport的park-unpark实现"><a href="#3-LockSupport的park-unpark实现" class="headerlink" title="3.LockSupport的park/unpark实现"></a>3.LockSupport的park/unpark实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用park/unpark来实现三个线程交替打印abcabcabcabcabc</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 17:12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParkUnpark</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread a;<br>    <span class="hljs-keyword">static</span> Thread b;<br>    <span class="hljs-keyword">static</span> Thread c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ParkUnpark parkUnpark = <span class="hljs-keyword">new</span> ParkUnpark(<span class="hljs-number">5</span>);<br><br>        a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;a&quot;</span>, b);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        b = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;b&quot;</span>, c);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>);<br><br>        c = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;c&quot;</span>, a);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>);<br><br>        a.start();<br>        b.start();<br>        c.start();<br><br>        LockSupport.unpark(a);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnpark</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnpark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread nextThread)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p><img src="https://img-blog.csdnimg.cn/20201223172500153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20201223172527523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程上篇 - (JMM,CAS原理,Volatile原理)</title>
    <link href="/2021/11/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A%E7%AF%87-JMM-CAS%E5%8E%9F%E7%90%86-Volatile%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A%E7%AF%87-JMM-CAS%E5%8E%9F%E7%90%86-Volatile%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h2><h3 id="1-Java内存模型（重点）"><a href="#1-Java内存模型（重点）" class="headerlink" title="1.Java内存模型（重点）"></a>1.Java内存模型（重点）</h3><ul><li>JMM即 <code>Java Memory Model</code>，它从Java层面定义了主存、工作内存 抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等。JMM体现在以下几个方面<ul><li>原子性 - 保证指令不会受<strong>线程上下文切换的影响</strong></li><li>可见性 - 保证指令不会受<strong>cpu缓存的影响</strong>（JIT对热点代码的缓存优化）</li><li>有序性 - 保证指令不会受<strong>cpu指令并行优化的影响</strong></li></ul></li></ul><h4 id="1-可见性（重点）"><a href="#1-可见性（重点）" class="headerlink" title="1.可见性（重点）"></a>1.可见性（重点）</h4><h5 id="1-1退不出的循环"><a href="#1-1退不出的循环" class="headerlink" title="1.1退不出的循环"></a>1.1退不出的循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(run) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;t1 Stop&quot;</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>为什么会出现对run变量的不可见性呢呢？分析一下</strong></p><ul><li>初始状态，t线程刚开始从主内存中读取值，因为主线程sleep1秒，这时候t线程循环了好多次run的值，超过了一定的阈值，JIT就会将主存中的run值读取到工作内存（相当于缓存了一份，不会从主存中读run的值了）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/55a9700c011a4188ffdb8993f88ded28.png"></p><ul><li>因为t线程频繁从主存中读取run值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中的run的访问以提高效率</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e81d86ac7eea71c6f94dab875af787c7.png"></p><ul><li>1秒之后，main线程修改了run的值，并同步至内存。而t线程是从自己工作内存中的高速缓存中读取这个变量的值，<strong>结果永远是旧值</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/62f824bbb5595133018b992b326c7913.png"></p><h5 id="1-2解决方法"><a href="#1-2解决方法" class="headerlink" title="1.2解决方法"></a>1.2<strong>解决方法</strong></h5><ul><li>使用volatile（易变关键字）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">// 增加t1线程, 对主线程更改run变量的可见性</span><br>    <span class="hljs-comment">// 一开始一直不结束, 是因为无限循环, run都是true, JIT及时编译器, 会对t1线程所执行的</span><br>    <span class="hljs-comment">// run变量,进行缓存, 缓存到本地工作内存. 不去访问主存中的run. 这样可以提高性能; 也可以说是JVM打到一定阈值之后</span><br>    <span class="hljs-comment">// while(true)变成了一个热点代码, 所以一直访问的都是缓存到本地工作内存(局部)中的run. 当主线程修改主存中的run变量的时候,</span><br>    <span class="hljs-comment">// t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了. 所以一直运行. 我们为主存(成员变量)进行volatile修饰, 增加</span><br>    <span class="hljs-comment">// 变量的可见性, 当主线程修改run为false, t1线程对run的值可见. 这样就可以退出循环</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">// 如果打印一句话</span><br>                <span class="hljs-comment">// 此时就可以结束, 因为println方法中, 使用到了synchronized</span><br>                <span class="hljs-comment">// synchronized可以保证原子性、可见性、有序性</span><br>                <span class="hljs-comment">// System.out.println(&quot;123&quot;);</span><br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>        System.out.println(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>synchronized</code>解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span><br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 当主线程获取到锁的时候, 就修改为false了</span><br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            run = <span class="hljs-keyword">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;false&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>使用<code>volatile</code>（表示易变关键字的意思），它可以用来修饰<code>成员变量</code>和<code>静态成员变量</code>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</li><li>volatile 可以认为是一个轻量级的锁，被 volatile 修饰的变量，汇编指令会存在于一个”lock”的前缀。在CPU层面与主内存层面，通过缓存一致性协议，<strong>加锁后能够保证写的值同步到主内存，使其他线程能够获得最新的值。</strong></li><li>使用<code>synchronized关键字</code>也有相同的效果, 在<code>Java内存模型</code>中，synchronized规定，线程在加锁时， <code>先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。</code></li></ul><h5 id="1-3-可见性-vs-原子性"><a href="#1-3-可见性-vs-原子性" class="headerlink" title="1.3 可见性 vs 原子性"></a>1.3 可见性 vs 原子性</h5><ul><li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对volatile变量的修改对另一个线程可见，而不能保证原子性。</strong>volatile用在一个写线程，多个读线程的情况，比较合适。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>putstatic run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run false </span><br></code></pre></td></tr></table></figure><ul><li>比较一下之前我们讲线程安全时举的例子：<strong>两个线程一个 i++ 一个 i– ，只能保证看到最新值(可见性)，不能解决指令交错(原子性)</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>getstatic i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>iconst_1 <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd <span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1 <span class="hljs-comment">// 线程2-准备常量1</span><br>isub <span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1 </span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">注意：：synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。<span class="hljs-strong">**但缺点是 synchronized 是属于重量级操作，性能相对更低。**</span>  如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，因为println方法里面有synchronized修饰。还有那个等烟的示例, 为啥没有出现可见性问题?和synchrozized是一个道理。<br></code></pre></td></tr></table></figure><h5 id="1-4模式之两阶段终止"><a href="#1-4模式之两阶段终止" class="headerlink" title="1.4模式之两阶段终止"></a>1.4模式之两阶段终止</h5><ul><li>当我们在执行线程一时，想要终止线程二、这就是需要使用interrupt方法来优雅的停止线程二。这是我们之前的做法</li><li>使用volatile关键字来实现两阶段终止模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_02_Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>Thread monitor;<br><span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 修改标记</span><br>stop = <span class="hljs-keyword">true</span>;<br><span class="hljs-comment">// 打断线程</span><br>monitor.interrupt();        <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-5模式之Balking（了解）"><a href="#1-5模式之Balking（了解）" class="headerlink" title="1.5模式之Balking（了解）"></a>1.5模式之Balking（了解）</h5><ul><li>定义： <code>balking（犹豫）模式</code>用在<code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code> 有点类似于单例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        monitor.start();<br>        monitor.start();<br>        Sleeper.sleep(<span class="hljs-number">3.5</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Monitor&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-comment">//已被启动，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//启动监视器，改变标记</span><br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//开始不停的监控</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;处理后续儿事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//线程休眠</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;被打断了...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        stop = <span class="hljs-keyword">true</span>;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-有序性（重点）"><a href="#2-有序性（重点）" class="headerlink" title="2.有序性（重点）"></a>2.有序性（重点）</h3><p>是JIT即时编译器的优化，可能会导致指令重排。为什么要优化？因为CPU支持多级指令流水线，例如支持同时执行<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器。效率快</p><ul><li>JVM会在不影响正确性的前提下，可以调整语句的执行顺序，是一种优化</li></ul><p><img src="https://img-blog.csdnimg.cn/20201224225308100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li>这种特性称为 <code>指令重排</code>，多线程下指令重排会影响正确性</li></ul><h4 id="1-多线程下指令重排问题"><a href="#1-多线程下指令重排问题" class="headerlink" title="1.多线程下指令重排问题"></a>1.多线程下指令重排问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>; <br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-keyword">if</span>(ready) &#123;<br> r.r1 = num + num;<br> &#125; <br> <span class="hljs-keyword">else</span> &#123;<br> r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程1执行actor1方法，线程2执行actor2方法</p><ul><li>I_Result是一个对象，有一个属性r1用来保存结果，可能有哪几种结果？<ul><li>情况1，线程1先执行，这时ready = false，所以进入else分支结果为1</li><li>情况2，线程2先执行num = 2，但没来得及执行ready = true，线程1执行，进入else分支，结果为1</li><li>情况3，线程2执行到ready = true，线程1执行，这回进入if分支，结果为4（因为num已经执行过了）</li><li>情况4，线程2先执行ready = true，切换到线程1，进入if分支，相加为0，再切回线程2执行num = 2，结果为0</li></ul></li><li>情况4的现象为指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用<code>jcstress工具</code>进行测试。上面仅是从代码层面体现出了<code>有序性</code>问题，下面在讲到 <code>double-checked locking (双重检查锁)</code>问题时还会从java字节码的层面了解有序性的问题。</li></ul><h5 id="1-2指令重排也需要遵守一定规则："><a href="#1-2指令重排也需要遵守一定规则：" class="headerlink" title="1.2指令重排也需要遵守一定规则："></a>1.2指令重排也需要遵守一定规则：</h5><ul><li>指令重排序规则不会对存在数据依赖关系的操作进行重排序。比如：a = 1；b = a；这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</li><li>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程下程序的执行结果不能被改变</strong> 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</li></ul><p><strong>指令重排序 在单线程模式下是一定会保证最终结果的正确性</strong>，但是在多线程环境下，问题就出来了</p><h5 id="1-3解决方法"><a href="#1-3解决方法" class="headerlink" title="1.3解决方法"></a>1.3解决方法</h5><p>用volatile修饰的变量，可以禁用指令重排</p><p>注意：</p><ul><li>使用<code>synchronized并不能解决有序性</code>问题，<strong>但是如果是该变量整个都在synchronized代码块的保护范围内</strong>，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！</li></ul><h4 id="2-volatile-原理-重点"><a href="#2-volatile-原理-重点" class="headerlink" title="2.volatile 原理(重点)"></a>2.volatile 原理(重点)</h4><ul><li>volatile的底层实现原理是内存屏障。Memory Barrier（Memory Fence）<ul><li>对volatile变量的<strong>写指令后</strong>会加入<strong>写屏障</strong>。（保证写屏障之前的写操作, 都能同步到主存中）</li><li>对volatile变量的<strong>读指令前</strong>会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, 都能读到主存的数据)</li></ul></li></ul><h5 id="2-1volatile是如何保证可见性的（重点）"><a href="#2-1volatile是如何保证可见性的（重点）" class="headerlink" title="2.1volatile是如何保证可见性的（重点）"></a>2.1volatile是如何保证可见性的（重点）</h5><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存之中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// ready是被volatile修饰的 ，赋值带写屏障</span><br>     <span class="hljs-comment">// 写屏障.(在ready=true写指令之后加的, </span><br>     <span class="hljs-comment">//在该屏障之前对共享变量的改动, 都同步到主存中. 包括num)</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<span class="hljs-comment">// ready, 读取的就是主存中的新值</span><br> r.r1 = num + num; <span class="hljs-comment">// num, 读取的也是主存中的新值</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br> r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b17feb2d8cc0907ddee8b08949a44d0d.png"></p><h5 id="2-2volatile是如何保证有序性（重点）"><a href="#2-2volatile是如何保证有序性（重点）" class="headerlink" title="2.2volatile是如何保证有序性（重点）"></a>2.2volatile是如何保证有序性（重点）</h5><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//  ready是被volatile修饰的 ， 赋值带写屏障</span><br> <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读屏障会保证指令重排序时，不会将读屏障之后的代码排在读排序之前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/98518f6441a448a9a6ef441ef2518c83.png"></p><p><strong>volatile不能解决指令交错（不能解决原子性）</strong></p><ul><li>写屏障仅仅是保障之后的读能够读到最新结果，但不能保证其它线程的读，跑到它前面去</li><li><strong>而有序性的保证也只是保证了本线程内相关代码不被重排序</strong></li></ul><p>下图t2线程, 就先读取了i=0, 此时还是会出现指令交错的现象, 可以使用<code>synchronized</code>来解决原子性</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1e8fff6923548db93e27ac4a947633e9.png"></p><h5 id="2-3-double-checked-locking-（双重检验锁）问题（重点）"><a href="#2-3-double-checked-locking-（双重检验锁）问题（重点）" class="headerlink" title="2.3 double-checked locking （双重检验锁）问题（重点）"></a>2.3 double-checked locking （双重检验锁）问题（重点）</h5><p>首先synchronized可以保证它的临界区的资源是 <code>原子性、可见性、有序性</code>的, 有序性的前提是，在synchronized代码块中的共享变量，不会在代码块外使用到，否则有序性不能被保证，只能使用volatile来保证有序性。</p><ul><li><p><strong>下面代码的第二个双重检查单例, 就出现了这个问题(在synchronized外使用到了INSTANCE), 此时synchronized就不能防止指令重排, 确保不了指令的有序性.</strong></p></li><li><p>以著名的<code>double-checked locking(双重检查锁) 单例模式</code>为例，这是volatile最常使用的地方。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最开始的单例模式是这样的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span><br><span class="hljs-comment">      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span><br><span class="hljs-comment">      防止多线程操作共享资源,造成的安全问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">首先上面代码的效率是有问题的, 因为当我们创建了一个单例对象后, 又来一个线程获取到锁了,还是会加锁, </span><br><span class="hljs-comment">严重影响性能,再次判断INSTANCE==null吗, 此时肯定不为null, 然后就返回刚才创建的INSTANCE;</span><br><span class="hljs-comment">这样导致了很多不必要的判断; </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所以要双重检查, 在第一次线程调用getInstance(), 直接在synchronized外,判断instance对象是否存在了,</span><br><span class="hljs-comment">如果不存在, 才会去获取锁,然后创建单例对象,并返回; 第二个线程调用getInstance(), 会进行</span><br><span class="hljs-comment">if(instance==null)的判断, 如果已经有单例对象, 此时就不会再去同步块中获取锁了. 提高效率</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，</span><br><span class="hljs-comment">// 不能享有synchronized保证的原子性、可见性、以及有序性。所以可能会导致 指令重排</span><br></code></pre></td></tr></table></figure><p>特点：</p><ul><li><p>懒惰实例化</p></li><li><p>首次使用getInstance() 才使用 synchronized 加锁，<strong>后续使用时无需加锁 (也就是上面的第二个单例)</strong></p></li><li><p>有隐含的: 但很关键的一点：<code>第一个 if 使用了 INSTANCE 变量，是在同步块之外</code>, 这样会导致<code>synchronized</code>无法保证指令的<code>有序性</code>, 此时可能会导致<code>指令重排</code>问题</p></li></ul><p>注意: 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span> <span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-comment">// ldc是获得类对象</span><br>6: ldc #3 // class cn/itcast/n5/Singleton<br><span class="hljs-comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span><br><span class="hljs-comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span><br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter<br>11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-comment">// 新建一个实例</span><br>17: new #3 // class cn/itcast/n5/Singleton<br><span class="hljs-comment">// 复制了一个实例的引用</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-comment">// 通过这个复制的引用调用它的构造方法</span><br>21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V<br><span class="hljs-comment">// 最开始的这个引用用来进行赋值操作</span><br>24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br>37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p><strong>其中</strong></p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li></ul><ul><li>20 表示复制一份对象引用 // 复制了引用地址, 解锁使用</li><li>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>可能jvm 会优化为：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。如果两个线程 t1，t2 按如下时间序列执行：</p><ul><li>通过上面的字节码发现, 这一步<code>INSTANCE = new Singleton();</code>操作不是一个<code>原子操作</code>, 它分为<code>21, 24两个指令</code>, 此时可能就会发生<code>指令重排</code>的问题</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/702a41b984561f85cab618621b824079.png"></p><ul><li>关键在于 <code>0: getstatic</code> 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值</li><li>这时 <code>t1 还未完全将构造方法</code>执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 <strong>对 INSTANCE 使用 volatile 修饰</strong>即可，可以<code>禁用指令重排。</code></li><li>注意在 JDK 5 以上的版本的 volatile 才会真正有效</li></ul><h5 id="2-4-double-checked-locking关于指令重排的解决"><a href="#2-4-double-checked-locking关于指令重排的解决" class="headerlink" title="2.4 double-checked locking关于指令重排的解决"></a>2.4 double-checked locking关于指令重排的解决</h5><ul><li>加volatile</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>字节码上看不出来volatile指令的效果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br>0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br>6: ldc #3 // class cn/itcast/n5/Singleton<br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br>11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br>17: new #3 // class cn/itcast/n5/Singleton<br><span class="hljs-number">20</span>: dup<br>21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V<br>24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br>37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><ul><li>如上面所注释的内容，读写volatile变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier）保证下面两点：<ol><li>可见性<ol><li>写屏障（sfence）保证该屏障之前的t1对共享变量的改动，都同步到主存中</li><li>读屏障（lfence）保证该屏障之后的t2对共享变量的读取，加载的是主存中最新数据</li></ol></li><li>有序性<ol><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会保证指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ol></li><li><strong>更底层是读写变量时使用lock指令来多核cpu之间的可见性与有序性</strong></li></ol></li></ul><p>加上volatile之后，保证了指令的有序性，不会发生指令重排，21就不会跑到24之后执行了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dd32cd4090a29b5dbd4c6a0bd8945187.png"></p><p><strong>小结</strong></p><ul><li>synchronized即能保证<strong>原子性、有序性、可见性</strong>，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作）。上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</li><li>对共享变量加<code>volatile</code>关键字可以保证<code>可见性</code>和<code>有序性</code>，但是<strong>不能保证原子性</strong>（即不能防止指令交错）。</li></ul><h4 id="3-happens-before-对共享变量的写操作-对其它线程的读操作可见"><a href="#3-happens-before-对共享变量的写操作-对其它线程的读操作可见" class="headerlink" title="3.happens-before (对共享变量的写操作,对其它线程的读操作可见)"></a>3.happens-before (<code>对共享变量的写操作,对其它线程的读操作可见</code>)</h4><p>下面说的变量都是指成员变量或静态成员变量</p><ol><li>线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对改变量的读可见<ul><li>synchronized锁，保证了可见性</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><ol start="2"><li>线程对volatile变量的写，对接下来其他线程对该变量的读可见<ul><li>volatile修饰的变量，通过写屏障，共享到主存中，其他线程通过读屏障，读取主存的数据</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ol start="3"><li>线程start前对变量的写，对该线程开始后对该变量的读可见</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ol start="4"><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure><ol start="5"><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>               <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                   System.out.println(x);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>       t2.start();<br>       <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           x = <span class="hljs-number">10</span>;<br>           t2.interrupt();<br>       &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>       <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>           Thread.yield();<br>       &#125;<br>       System.out.println(x);<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>​<ul><li>对<code>变量默认值（0，false，null）的写</code>，对其它线程对该变量的 读可见 (最基本)</li><li><code>具有传递性</code>，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，<strong>配合 volatile 的防指令重排，有下面的例子</strong></li><li>因为<code>x加了volatile</code>, 所以在volatile static int x 代码的上面添加了<code>读屏障</code>, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;  <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>y = <span class="hljs-number">10</span>;  <br>x = <span class="hljs-number">20</span>;  <br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br><span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见  </span><br>System.out.println(x);  <br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start(); <br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></li></ul><h3 id="3-习题"><a href="#3-习题" class="headerlink" title="3.习题"></a>3.习题</h3><h4 id="1-balking练习题"><a href="#1-balking练习题" class="headerlink" title="1.balking练习题"></a>1.balking练习题</h4><ul><li>希望doInit()方法仅被调用一次下面的实现是否有问题，为什么？</li><li>有问题: volatile无法保证原子性; 当多个线程同时调用init()方法时, 此时都进入到if判断, 因为都为false, 所以都调用<code>doInit()</code>方法, 此时就调用了多次<ul><li>解决方法: 对init()方法的方法体, 通过<code>synchronized</code>加锁, 防止多个线程访问共享资源导致的安全问题</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialized) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        doInit();<br>        initialized = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>修改后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            init();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            init();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">if</span> (initialized) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            doInit();<br>            initialized = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;init...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-线程安全单例模式（重点）"><a href="#2-线程安全单例模式（重点）" class="headerlink" title="2.线程安全单例模式（重点）"></a>2.线程安全单例模式（重点）</h4><ul><li>单例模式有很多实现方法，<code>饿汉、懒汉、静态内部类、枚举类</code>，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题<ul><li><code>饿汉式</code>：<strong>类加载就会导致该单实例对象被创建</strong></li><li><code>懒汉式</code>：<strong>类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</strong></li></ul></li></ul><p>实现1：饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final，防止子类继承后更改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span><br>    <span class="hljs-comment">//1.提供更好的封装性；2.提供范型的支持</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题1 : 加final为了防止有子类, 因为子类可以重写父类的方法</li><li>问题2 : 首先通过反序列化操作, 也是可以创建一个对象的, 破坏了单例, 可以使用readResolve方法并返回instance对象, 当反序列化的时候就会调用自己写的readResolve方法</li><li>问题3 : 私有化构造器, 防止外部通过构造器来创建对象; 但不能防止反射来创建对象</li><li>问题4 : 因为单例对象是static的, 静态成员变量的初始化操作是在类加载阶段完成, 由JVM保证其线程安全 (这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。)</li><li>问题5 : 通过向外提供公共方法, 体现了更好的封装性, 可以在方法内实现懒加载的单例; 可以提供泛型等</li></ul><p>补充 : 任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。</p><p>实现2：饿汉式: 因为枚举的变量, 底层是通过public static final来修饰的, 类加载就创建了,所以是饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例：不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 问题1 : 枚举类中, 只有一个INSTANCE, 就确保了它是单例的<br><span class="hljs-bullet">-</span> 问题2 : 没有并发问题, 是线程安全的, 因为枚举单例底层是一个静态成员变量, 它是通过类加载器的加载而创建的, 确保了线程安全<br><span class="hljs-bullet">-</span> 问题3 : 反射无法破坏枚举单例, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。<br><span class="hljs-bullet">  -</span> if ((this.clazz.getModifiers() &amp; 16384) != 0)<br><span class="hljs-code">    throw new IllegalArgumentException(“Cannot       reflectively create enum objects”);</span><br><span class="hljs-code">- 问题4 : 反序列化不能破坏, 枚举类默认也实习了序列号接口. 但枚举类考虑到了这个问题, 不会破坏单例. 通过反序列化得到的并不是同一个单例对象; 除此之外, 还可以写上readResolve方法,</span><br><span class="hljs-code">- 问题 5 : 属于饿汉式, 静态成员变量, 通过类加载器的时候就加载了。</span><br><span class="hljs-code">- 问题 6 : 加构造方法</span><br></code></pre></td></tr></table></figure><p>实现3：懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个懒汉式的单例, 代码存在性能问题: 当单例对象已经创建好了, 多个线程访问<code>getInstance()</code>方法, 仍然会获取锁, 同步操作, 性能很低, 此时出现<code>重复判断</code>, 因此要使用<code>双重检查</code></p><p>实现4：DCL 懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>问题1 : 因为在synchronized外部使用到了共享变量INSTANCE, 所以synchronized无法保证instance的有序性, 又因为instance = new Singleton()不是一个原子操作, 可分为多个指令. 此时通过指令重排, 可能会造成INSTANCE还未初始化, 就赋值的现象, 所以要给共享变量INSTANCE加上volatile,禁止指令重排</li><li>问题2 : 增加了双重判断, 如果存在了单例对象, 别的线程再进来就无需加锁判断, 大大提高性能</li><li>问题3 : 防止多线程并发导致不安全的问题:防止单例对象被重复创建. 当t1,t2线程都调用getInstance()方法, 它们都判断单例对象为空, 还没有创建;<ul><li>此时t1先获取到锁对象, 进入到synchronized中, 此时创建对象, 返回单例对象, 释放锁;</li><li>这时候t2获得了锁对象, 如果在代码块中没有if判断, 则线程2认为没有单例对象, 因为在代码块外判断的时候就没有, 所以t2就还是会创建单例对象. 此时就重复创建了</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章重点讲解了 JMM 中的</p><ul><li>可见性 - 由 JVM 缓存优化引起; <code>(JIT即时编译器, 通过对热点代码的优化)</code></li><li>有序性 - 由 JVM <code>指令重排序优化</code>引起; <code>(提高指令的执行效率, 类似流水线系统)</code></li></ul><ul><li>happens-before 规则; <code>(happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结。)</code></li></ul><p>原理方面</p><ul><li>volatile (读写屏障)</li></ul><p>模式方面</p><ul><li>两阶段终止模式的 volatile 改进</li><li>同步模式之 balking (犹豫模式)</li></ul><h2 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h2><ul><li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等 独占锁 就是 <strong>悲观锁</strong> 思想的实现</li></ul><ul><li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>就是使用了<code>乐观锁</code>的一种实现方式 <strong>CAS</strong> 实现的</li></ul><ul><li>管程即<code>monitor</code>是<code>阻塞式的悲观锁</code>实现<code>并发控制</code>，这章我们将通过<code>非阻塞式的乐观锁</code>的来实现<code>并发控制</code></li></ul><h3 id="1-问题提出"><a href="#1-问题提出" class="headerlink" title="1.问题提出"></a>1.问题提出</h3><ul><li>有如下需求，保证<code>account.withdraw取款方法</code>的线程安全, 下面使用<code>synchronized</code>保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用重量级锁synchronized来保证多线程访问共享资源发生的安全问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/27 16:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));<br>        Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Java8之后接口新特性, 可以添加默认方法</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        ts.forEach(thread -&gt; thread.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-解决思路-无锁"><a href="#2-解决思路-无锁" class="headerlink" title="2.解决思路-无锁"></a>2.解决思路-无锁</h3><ul><li>上面的代码中使用<code>synchronized加锁</code>操作来<code>保证线程安全</code>，但是 **synchronized加锁操作太耗费资源 (因为底层使用了操作系统mutex指令, 造成内核态和用户态的切换)**，这里我们使用 <strong>无锁</strong> 来解决此问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br><span class="hljs-comment">//使用原子整数: 底层使用CAS+重试的机制</span><br><span class="hljs-keyword">private</span> AtomicInteger balance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//得到原子整数的值</span><br><span class="hljs-keyword">return</span> balance.get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br><span class="hljs-comment">//获得修改前的值</span><br><span class="hljs-keyword">int</span> prev = balance.get();<br><span class="hljs-comment">//获得修改后的值</span><br><span class="hljs-keyword">int</span> next = prev - amount;<br><span class="hljs-comment">//比较并设置值</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,</span><br><span class="hljs-comment">就继续where(true),如果匹配上了, 将next值设置给共享变量.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-CAS与volatile（重点）"><a href="#3-CAS与volatile（重点）" class="headerlink" title="3. CAS与volatile（重点）"></a>3. CAS与volatile（重点）</h3><p>使用原子操作来保证线程访问共享资源的安全性，cas + 重试的机制来确保（乐观锁思想），相对于悲观锁的思想的synchronized，reentrantLock来说，cas的方式效率会更好</p><h4 id="3-1cas-重试的原理"><a href="#3-1cas-重试的原理" class="headerlink" title="3.1cas + 重试的原理"></a>3.1cas + 重试的原理</h4><ul><li>前面看到的Atomic Integer的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>        <span class="hljs-keyword">int</span> prev = balance.get();<br>        <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>        <span class="hljs-keyword">int</span> next = prev - amount;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         compareAndSet 保证操作共享变量安全性的操作:</span><br><span class="hljs-comment">         ① 线程A首先获取balance.get(),拿到当前的balance值prev</span><br><span class="hljs-comment">         ② 根据这个prev值 - amount值 = 修改后的值next</span><br><span class="hljs-comment">         ③ 调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的balance值相同;</span><br><span class="hljs-comment">         3.1、如果相同,表示其他线程没有修改balance的值, 此时就可以将next值</span><br><span class="hljs-comment">         设置给balance属性</span><br><span class="hljs-comment">         3.2、如果不相同,表示其他线程也修改了balance值, 此时就设置next值失败, </span><br><span class="hljs-comment">然后一直重试, 重新获取balance.get()的值,计算出next值,</span><br><span class="hljs-comment">并判断本次的prev和balnce的值是否相同...重复上面操作</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(prev,next))&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其中的关键是compareAndSwap（比较并设置值），它的简称就是CAS（也有Compare And Swap的说法），它必须是<code>原子操作</code></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/436a166f7e783537464879edf14ccc0c.png"></p><p><strong>流程</strong></p><ul><li>当一个线程要去修改<code>Account对象</code>中的值时，<code>先获取值prev(调用get方法)</code>，然后再将其设置为新的值<code>next</code>(调用cas方法)。在调用cas方法时，会将<code>prev</code>与<code>Account中的余额</code>进行比较<ul><li>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作</li><li>如果不相等，就不设置值，重新获取值prev(调用get方法)；然后再将其设置为新的值next(调用cas方法)，直到修改成功为止</li></ul></li></ul><p><strong>注意 :</strong></p><ul><li>其实CAS底层是<strong>lock cmpxchg指令</strong>（X86架构），在单核CPU和多核CPU下都能够保证<code>[比较 - 交换]的原子性</code></li><li>在多核状态下，某个核执行到带lock的指令时，<strong>CPU会让总线锁住，当这个核把此指令执行完，在开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20210202190842397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h4 id="3-2volatile的作用"><a href="#3-2volatile的作用" class="headerlink" title="3.2volatile的作用"></a>3.2volatile的作用</h4><ul><li>在上面的代码中的AtomicInteger类，<strong>保存值的value属性使用了volatile修饰</strong>。获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</li><li>volatile可以用来修饰 <strong>成员变量和静态成员变量</strong>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。<code>即一个线程对volatile变量的修改，对另一个线程可见</code></li></ul><p>注意：</p><p>volatile仅仅保证了共享变量的<strong>可见性</strong>，让其他线程能够看到最新值，但<strong>不能解决指令交错问题（不能保证原子性）</strong></p><ul><li>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</li></ul><h4 id="3-3为什么CAS-重试（无锁）效率高"><a href="#3-3为什么CAS-重试（无锁）效率高" class="headerlink" title="3.3为什么CAS+重试（无锁）效率高"></a>3.3为什么CAS+重试（无锁）效率高</h4><ul><li><strong>使用CAS+重试 — 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞</strong><ul><li>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li></ul></li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><h4 id="3-4CAS的特点（乐观锁和悲观锁的特点）"><a href="#3-4CAS的特点（乐观锁和悲观锁的特点）" class="headerlink" title="3.4CAS的特点（乐观锁和悲观锁的特点）"></a>3.4CAS的特点（乐观锁和悲观锁的特点）</h4><p>结合CAS和volatile可以实现无锁并发，适用于线程数小、多核CPU的场景下</p><ul><li>CAS是基于乐观锁的思想：<strong>最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</strong></li><li>synchronized是基于悲观锁的思想：<strong>最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</strong></li><li>CAS体现的是无锁并发、无阻塞并发<ul><li>因为没有使用synchronized，所以线程不会陷入阻塞，这时效率提升的因素之一</li><li>但如果竞争激烈（写操作多），可以想到重试必然频繁发生，<strong>反而效率会受影响</strong></li></ul></li></ul><p>###4.原子整数（内部通过CAS来实现-AtomicInteger）</p><ul><li>java.util.concurrent.atomic并发包提供了一些并发工具类，这里把它分成5类：</li><li>使用原子的方式（<strong>共享数据为基本数据类型原子类</strong>）<ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔原子类</li></ul></li><li>上面三个类提供的方法几乎相同，所以我们将以AtomicInteger为例子来介绍。先讨论原子整数类，以AtomicInteger为例讨论它的api接口：通过观察源码可以发现</li><li><strong>AtomicInteger内部都是通过cas的原理来实现的</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：updateAndGet的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br><br>    updateAndGet(i, <span class="hljs-keyword">new</span> IntUnaryOperator() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">applyAsInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operand)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> operand / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;);<br>    System.out.println(i.get()); <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> prev = i.get(); <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);<br>        <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ul><li>调用updateAndGet方法，将共享变量i，IntUnaryOperator传递过去</li><li>updateAndGet方法内部，传过来的operator对象，调用IntUnaryOperator中的applyAsInt方法，实际调用的就是传递过来的对象的方法，进行/操作</li></ul><p><img src="https://img-blog.csdnimg.cn/20201227190220505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><h3 id="5-原子引用（AtomicReference）"><a href="#5-原子引用（AtomicReference）" class="headerlink" title="5.原子引用（AtomicReference）"></a>5.原子引用（AtomicReference）</h3><p>原子引用的作用：保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）</p><ul><li>为什么需要原子引用类型？（引用数据类型原子类）<ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference（可以解决ABA问题）</li></ul></li></ul><p>为什么需要<code>原子引用类型</code>？<strong>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。</strong></p><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。 </p><ul><li><strong>AtomicReference</strong>：引用类型原子类</li><li><strong>AtomicStampedReference</strong>：原子更新带有<code>版本号</code>的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，<strong>可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</strong></li><li><strong>AtomicMarkableReference</strong> ：原子更新带有<code>标记</code>的引用类型。该类将 boolean 标记与引用关联起来</li></ul><p>例子：使用原子引用实现BigDecimal存取款的线程安全：</p><p>下面这个是不安全的实现过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    BigDecimal balance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountUnsafe</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        BigDecimal balance = <span class="hljs-keyword">this</span>.getBalance();<br>        <span class="hljs-keyword">this</span>.balance = balance.subtract(amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决代码如下：在<code>AtomicReference类</code>中，存在一个value类型的变量，保存对BigDecimal对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountCas(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><br>    <span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            BigDecimal prev = balance.get();<br>            BigDecimal next = prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ABA-问题及解决-重点"><a href="#ABA-问题及解决-重点" class="headerlink" title="ABA 问题及解决 (重点)"></a>ABA 问题及解决 (<code>重点</code>)</h4><ul><li>如下程序所示，虽然 <strong>在other方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值</strong>，<strong>main线程对修改过共享变量的过程是不可见的，这种操作这对业务代码并无影响。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.get();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//把ref中的A改为C</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-comment">// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS</span><br>        <span class="hljs-comment">// 可以修改成功, B</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-comment">// 同上, 修改为A</span><br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201227200916774.png"></p><ul><li>主线程仅能判断出<code>共享变量的值</code>与<code>最初值 A</code>是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：<strong>只要有其它线程【动过】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</strong></li></ul><h4 id="AtomicStampedReference-加版本号解决ABA问题"><a href="#AtomicStampedReference-加版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (加版本号解决ABA问题)"></a>AtomicStampedReference (加版本号解决ABA问题)</h4><ul><li>解决ABA问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.getReference();<br>            <span class="hljs-comment">//获得版本号</span><br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp(); <span class="hljs-comment">// 此时的版本号还是第一次获取的</span><br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201227201334161.png"></p><h4 id="AtomicMarkableReference-标记cas的共享变量是否被修改过"><a href="#AtomicMarkableReference-标记cas的共享变量是否被修改过" class="headerlink" title="AtomicMarkableReference (标记cas的共享变量是否被修改过)"></a>AtomicMarkableReference (标记cas的共享变量是否被修改过)</h4><ul><li><code>AtomicStampedReference</code> 可以给<code>原子引用</code>加上<code>版本号</code>，<strong>追踪原子引用整个的变化过程</strong>，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</li></ul><ul><li>但是有时候，<code>并不关心引用变量更改了几次，只是单纯的关心是否更改过</code>，所以就有了<code>AtomicMarkableReference</code></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/23026a8d2e27e7a4f474d15f0e3684bc.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestABAAtomicMarkableReference&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestABAAtomicMarkableReference</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br>        <br>        <span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程 start...&quot;</span>);<br>        <br>        GarbageBag prev = ref.getReference();<br>        log.debug(prev.toString());<br>        <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;打扫卫生的线程 start...&quot;</span>);<br>            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>)) &#123;<br>            &#125;<br>            log.debug(bag.toString());<br>        &#125;).start();<br>        <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程想换一只新垃圾袋？&quot;</span>);<br>        <br>        <span class="hljs-keyword">boolean</span> success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>        log.debug(ref.getReference().toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;<br>    String desc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.062</span> guizy.TestABAAtomicMarkableReference [main] - 主线程 start...<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.069</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 装满了垃圾<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.312</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="hljs-number">0</span>] - 打扫卫生的线程 start...<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.313</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="hljs-number">0</span>] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.313</span> guizy.TestABAAtomicMarkableReference [main] - 主线程想换一只新垃圾袋？<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - 换了么？<span class="hljs-keyword">false</span><br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋<br></code></pre></td></tr></table></figure><p><strong>举例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.getReference();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201227201642314.png"></p><h4 id="AtomicStampedReference和AtomicMarkableReference两者的区别"><a href="#AtomicStampedReference和AtomicMarkableReference两者的区别" class="headerlink" title="AtomicStampedReference和AtomicMarkableReference两者的区别"></a>AtomicStampedReference和AtomicMarkableReference两者的区别</h4><ul><li><strong>AtomicStampedReference</strong>需要我们传入<strong>整型变量</strong>作为版本号，来判断是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入布尔变量作为<code>标记</code>，来判断是否更改过</li></ul><h3 id="6-原子数组"><a href="#6-原子数组" class="headerlink" title="6.原子数组"></a>6.原子数组</h3><ul><li>保证数组内的元素的线程安全</li><li>使用原子的方式更新数组里的某个元素<ul><li><code>AtomicIntegerArray</code>：整形数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul></li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicArrayTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],<br>                array -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                array -&gt; System.out.println(Arrays.toString(array))<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     * 参数2，获取数组长度的方法</span><br><span class="hljs-comment">     * 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     * 参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-function"><span class="hljs-params">                                 BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;); <span class="hljs-comment">// 等所有线程结束</span><br><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">9870</span>, <span class="hljs-number">9862</span>, <span class="hljs-number">9774</span>, <span class="hljs-number">9697</span>, <span class="hljs-number">9683</span>, <span class="hljs-number">9678</span>, <span class="hljs-number">9679</span>, <span class="hljs-number">9668</span>, <span class="hljs-number">9680</span>, <span class="hljs-number">9698</span>]<br></code></pre></td></tr></table></figure><ul><li>使用<code>AtomicIntegerArray</code>来创建安全数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>        ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>        (array) -&gt; array.length(),<br>        (array, index) -&gt; array.getAndIncrement(index),<br>        array -&gt; System.out.println(array)<br>);<br><br>demo(<br>        ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>        AtomicIntegerArray::length,<br>        AtomicIntegerArray::getAndIncrement,<br>        System.out::println<br>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure><h3 id="7-字段更新器"><a href="#7-字段更新器" class="headerlink" title="7.字段更新器"></a>7.字段更新器</h3><p>保证<code>多线程</code>访问<code>同一个对象的成员变量</code>时, <code>成员变量的线程安全性</code>。</p><ul><li>AtomicReferenceFieldUpdater —引用类型的属性</li><li>AtomicIntegerFieldUpdater — 整形的属性</li><li>AtomicLongFieldUpdater — 长整型的属性</li></ul><p>注意：利用字段更新器，可以针对<code>对象的某个域（Field）进行原子操作</code>，只能<code>配合 volatile 修饰</code>的字段使用，否则会出现异常。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.AtomicFieldTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicFieldTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        <span class="hljs-comment">// 获得原子更新器</span><br>      <span class="hljs-comment">// 泛型</span><br>      <span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      <span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// 期望的为null, 如果name属性没有被别的线程更改过, 默认就为null, 此时匹配, 就可以设置name为张三</span><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        System.out.println(updater.compareAndSet(stu, stu.name, <span class="hljs-string">&quot;王五&quot;</span>));<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br>Student&#123;name=<span class="hljs-string">&#x27;王五&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-原子累加器（LongAddr）（重要）"><a href="#8-原子累加器（LongAddr）（重要）" class="headerlink" title="8.原子累加器（LongAddr）（重要）"></a>8.原子累加器（LongAddr）（重要）</h3><ul><li>LongAddr</li><li>LongAccumulator</li><li>DoubleAddr</li><li>DoubleAccumulator</li></ul><p><code>累加器性能比较 AtomicLong, LongAddr</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;----AtomicLong----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;----LongAdder----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), adder -&gt; adder.increment());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>        T adder = adderSupplier.get();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">----AtomicLong----<br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">646</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">707</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">689</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">713</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">657</span><br>----LongAdder----<br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">148</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">139</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">130</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">122</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">116</span><br></code></pre></td></tr></table></figure><p>LongAddr</p><ul><li><strong>性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</strong></li></ul><p>AtomicLong</p><ul><li><strong>之前AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS重试, 性能没有LongAdder高</strong></li></ul><h3 id="9-LongAdder原理（了解）"><a href="#9-LongAdder原理（了解）" class="headerlink" title="9.LongAdder原理（了解）"></a>9.LongAdder原理（了解）</h3><p><strong>原理之伪共享</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e1c53a0fb41d7d089e5ddcc71f1f2a0d.png"></p><ul><li>缓存行伪共享从<code>缓存</code>说起</li><li>缓存与内存的速度比较</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9d3df3ad5311a92ecf235ccf78584ca3.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b4d95b0315026ad343cda2dd2d2f3c2a.png"></p><ul><li>因为 <code>CPU 与 内存的速度差异很大</code>，需要靠<code>预读数据</code>至<strong>缓存</strong>来提升效率。而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<strong>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</strong></li><li>CPU 要保证数据的<strong>一致性</strong> (缓存一致性)，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/56de3a77bb6f96ba480f622083864c36.png"></p><ul><li>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul></li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><ul><li>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</li><li>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</li></ul><p><strong>累加主要调用以下方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>               !(uncontended = a.cas(v = a.value, v + x)))<br>               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>累加流程图</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ce399f7bd72da53a22f6fbaba896dcc1.png"></p><h3 id="10-Unsafe（重点）"><a href="#10-Unsafe（重点）" class="headerlink" title="10.Unsafe（重点）"></a>10.Unsafe（重点）</h3><ul><li>Unsafe对象提供了非常底层的，操作内存、线程的方法，Unsafe对象不能直接调用，只能通过<code>反射</code>获得</li><li>可以发现<code>AtomicInteger</code>以及其他的原子类、底层都使用的是Unsafe类</li></ul><p><img src="https://img-blog.csdnimg.cn/20201228125739963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p><ul><li>使用底层的<code>Unsafe</code>实现原子操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>        Class unsafeClass = Unsafe.class;<br>        <span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>        Constructor constructor = unsafeClass.getDeclaredConstructor();<br>        <span class="hljs-comment">// 设置为允许访问私有内容</span><br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 创建Unsafe对象</span><br>        Unsafe unsafe = (Unsafe) constructor.newInstance();<br><br>        <span class="hljs-comment">// 创建Person对象</span><br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        <span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>        <span class="hljs-keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br><br>        <span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>        unsafe.compareAndSwapObject(person, nameOffset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;guizy&quot;</span>);<br>        unsafe.compareAndSwapInt(person, ageOffset, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br>    <span class="hljs-keyword">volatile</span> String name;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本章重点讲解</p><ol><li>CAS 与 volatile</li><li>juc 包下 API<ol><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ol></li><li>Unsafe</li><li>原理方面<ol><li>LongAdder 源码</li><li>伪共享</li></ol></li></ol><h2 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h2><h3 id="一、日期转换的问题"><a href="#一、日期转换的问题" class="headerlink" title="一、日期转换的问题"></a>一、日期转换的问题</h3><p>问题提出，下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));<br>              &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>              &#125;<br>          &#125;).start();<br>      &#125;<br></code></pre></td></tr></table></figure><p><strong>思路-不可变对象</strong></p><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改</p><ul><li><code>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</code> </li></ul><p>不可变</p><ul><li>如果一个对象在<strong>不能够修改其内部状态（属性）</strong>，那么他就是<strong>线程安全</strong>的，<code>因为不存在并发修改</code></li></ul><p>例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            LocalDate date = dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::from);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201229214014754.png"></p><p>不可变对象，实际是另一种避免竞争的方式</p><h3 id="二、不可变类设计String"><a href="#二、不可变类设计String" class="headerlink" title="二、不可变类设计String"></a>二、不可变类设计String</h3><p>String类中不可变的体现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<span class="hljs-comment">// 在JDK9 使用了byte[] 数组</span><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-final的使用"><a href="#1-final的使用" class="headerlink" title="1.final的使用"></a>1.final的使用</h4><ul><li><strong>Integer、Double、String、DateTimeFormatter以及基本类型包装类，都是使用final来修饰的</strong></li><li>发现该类、类中所有属性都是final的，属性用final修饰保证了该属性是只读的，不能修改，<strong>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</strong></li></ul><h5 id="1-1保护性拷贝"><a href="#1-1保护性拷贝" class="headerlink" title="1.1保护性拷贝"></a>1.1保护性拷贝</h5><ul><li>使用字符串时，也有一些跟修改相关的方法，比如substring、replace等，以substring实现为例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(endIndex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> subLen = endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>    &#125;<br>    <span class="hljs-comment">// 上面是一些校验，下面才是真正的创建新的String对象</span><br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span><br>            : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发现其方法最后是调用String的构造方法创建了一个新字符串，<strong>在进入这个构造看，是否对final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的char[] value,对内容进行复制</strong></li><li>这种通过创建副本对象来避免共享的手段称为【保护性拷贝】</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>    &#125;<br>    <span class="hljs-comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span><br>    <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-final原理"><a href="#2-final原理" class="headerlink" title="2.final原理"></a>2.final原理</h4><ul><li>设置final变量的原理<ul><li>理解了volatile原理（读写屏障），在对比final的实现就比较简单了</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; <br> &#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0<br>1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">4</span>: aload_0<br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><br>7: putfield #2 // Field a:I<br> &lt;-- 写屏障<br><span class="hljs-number">10</span>: retu<br></code></pre></td></tr></table></figure><ul><li>发现final变量的赋值也会通过<strong>putfield</strong>指令来完成，同样在这条指令之后也会加入写屏障，<strong>保证在其他线程读到它的值时不会出现为0的情况。</strong></li></ul><h3 id="三、享元设计模式"><a href="#三、享元设计模式" class="headerlink" title="三、享元设计模式"></a>三、享元设计模式</h3><ul><li>简介定义英文名称：Flyweight pattern, <strong>重用数量有限的同一类对象</strong><ul><li>结构型模式</li></ul></li><li>享元模式的体现<ul><li>1.在JDK中<code>Boolean，Byte，Short，Integer，Long，Character</code>等包装类提供了<code>valueOf</code>方法，例如 Long 的<code>valueOf</code>会缓存<code>-128~127</code>之间的 Long 对象，<strong>在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Long(l);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>Byte, Short, Long 缓存的范围都是-128-127</li><li>Character 缓存的范围是 0-127</li><li>Boolean 缓存了 TRUE 和 FALSE</li><li>Integer的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 “-Djava.lang.Integer.IntegerCache.high “来改变</li><li>2、String串池</li><li>3、BigDecimal、BigInteger</li></ul><h4 id="1-实现一个简单的连接池"><a href="#1-实现一个简单的连接池" class="headerlink" title="1.实现一个简单的连接池"></a>1.实现一个简单的连接池</h4><ul><li>例如：<strong>一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 简易连接池</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/29 21:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*使用连接池*/</span><br>        Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                Connection conn = pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Pool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br><br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><br>    <span class="hljs-comment">// 3. 连接状态数组: 0 表示空闲, 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br>        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<span class="hljs-comment">//使用AtomicIntegerArray保证states的线程安全</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//使用compareAndSet保证线程安全</span><br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待, 如果不写这个synchronized,其他线程不会进行等待, </span><br>            <span class="hljs-comment">// 一直在上面while(true), 空转, 消耗cpu资源</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-keyword">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Connection 实现方法略</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">0</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.005</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">1</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.006</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">0</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.581</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.582</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.582</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.617</span> guizy.Pool [Thread-<span class="hljs-number">1</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.618</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.955</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">08.552</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201229220417401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记4</title>
    <link href="/2021/10/23/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <url>/2021/10/23/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h3 id="字节码技术"><a href="#字节码技术" class="headerlink" title="字节码技术"></a>字节码技术</h3><h4 id="一-字节码指令"><a href="#一-字节码指令" class="headerlink" title="一.字节码指令"></a>一.字节码指令</h4><h5 id="1-javap工具"><a href="#1-javap工具" class="headerlink" title="1.javap工具"></a>1.javap工具</h5><p>java中提供了javap工具来反编译class文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">javap -v D:<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Demo</span>.</span></span><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><h5 id="2-图解方法执行流程"><a href="#2-图解方法执行流程" class="headerlink" title="2.图解方法执行流程"></a>2.图解方法执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> c = a + b;<br>    System.out.println(c);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区</p><p><img src="https://img-blog.csdnimg.cn/20210210230332114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="常量池载入运行时常量池"></p><p><strong>方法字节码载入方法区</strong></p><p>（stack = 2， locals = 4）对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="https://img-blog.csdnimg.cn/20210210230419340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="方法字节码载入方法区"></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li>将一个byte压入操作数栈（其长度会补齐4个字节），类似指令还有<ul><li>sipush 将一个short压入操作数栈（其长度会补齐4个字节）</li><li>Idc 将一个int压入操作数栈</li><li>idc2_w将一个long压入操作数栈（<strong>分两次压入，因为long是8个字节</strong>）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过short范围的数字存入常量池</strong></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210210230611776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="执行引擎开始执行字节码 bipush 10"></p><p><strong>istore 1</strong></p><p>将操作数栈顶元素弹出，放入局部变量表的slot1中</p><p>对应代码中的a = 10；</p><p><img src="https://img-blog.csdnimg.cn/20210210230717611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="istore 1"></p><p><strong>Idc #3</strong></p><p>读取运行时常量池中的#3，即32768（超过short最大范围的数会被放到运行时常量池中），将其加载到操作数栈中</p><p>注意short.MAX_VALUE是32767，所以32768 = short.MAX_VALUE + 1实际是在编译期间计算好的</p><p><img src="https://img-blog.csdnimg.cn/20210210230918171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Idc #3"></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://img-blog.csdnimg.cn/20210210231005919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="istore 2"></p><p>**iload 1 iload2 **</p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中，因为只能在操作数栈中执行运算操作</p><p><img src="https://img-blog.csdnimg.cn/20210210231211695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="iload1 iload2"></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素弹出栈并相加，结果在压入操作数栈中</p><p><img src="https://img-blog.csdnimg.cn/20210210231236404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="iadd"></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://img-blog.csdnimg.cn/20210210231319967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="istore 3"></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象，在堆内存中找到该对象，并将其引用放入操作数栈中</p><p><img src="https://img-blog.csdnimg.cn/20210210231759663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210210231827339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="getstatic #4"></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://img-blog.csdnimg.cn/20210210232008706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="iload 3"></p><p><strong>invodevirtual #5</strong></p><p>找到常量池中的 #5项，定位到方法区java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配loads、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><img src="https://img-blog.csdnimg.cn/20210210232148931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="invodevirtual #5"></p><p>执行完毕，弹出栈桢</p><p>清楚main操作数栈内容</p><p><img src="https://img-blog.csdnimg.cn/20210210232228908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p><strong>return</strong></p><p>完成main方法调用，弹出main栈帧，程序结束</p><h5 id="3-通过字节码指令分析问题"><a href="#3-通过字节码指令分析问题" class="headerlink" title="3.通过字节码指令分析问题"></a>3.通过字节码指令分析问题</h5><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeTest</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">10</span>)&#123;<br>      x = x++;<br>      i++;<br>    &#125;<br>    System.out.println(x); <span class="hljs-comment">//0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么x结果为0？</p><p>通过分析字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-comment">// 操作数栈分配2个空间，局部变量表分配 3 个空间</span><br>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-comment">// 准备一个常数 0</span><br>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">// 将常数 0 放入局部变量表的 1 号槽位 i = 0</span><br>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-comment">// 准备一个常数 0</span><br>        <span class="hljs-number">3</span>: istore_2<span class="hljs-comment">// 将常数 0 放入局部变量的 2 号槽位 x = 0</span><br>        <span class="hljs-number">4</span>: iload_1<span class="hljs-comment">// 将局部变量表 1 号槽位的数放入操作数栈中</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">// 将数字 10 放入操作数栈中，此时操作数栈中有 2 个数</span><br>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-comment">// 比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到 21 。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span><br>       <span class="hljs-number">10</span>: iload_2<span class="hljs-comment">// 将局部变量 2 号槽位的数放入操作数栈中，放入的值是 0 </span><br>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">// 将局部变量 2 号槽位的数加 1 ，自增后，槽位中的值为 1 </span><br>       <span class="hljs-number">14</span>: istore_2<span class="hljs-comment">//将操作数栈中的数放入到局部变量表的 2 号槽位，2 号槽位的值又变为了0</span><br>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">// 1 号槽位的值自增 1 </span><br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">// 跳转到第4条指令</span><br>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>       <span class="hljs-number">24</span>: iload_2<br>       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V<br>       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h5 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4.构造方法"></a>4.构造方法</h5><p>cinit() V</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_12_CinitTest</span> </span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> &#123;<br>i = <span class="hljs-number">30</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(i); <span class="hljs-comment">// 30</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会按照从上至下的顺序，收集所有static静态代码块和静态成员赋值代码，合并为一个特殊的方法cinitV</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>         2: putstatic     #3                  // Field i:I<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>         7: putstatic     #3                  // Field i:I<br>        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span><br>        12: putstatic     #3                  // Field i:I<br>        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>init()V</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_13_InitTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">&quot;s1&quot;</span>;<br><br>    &#123;<br>        b = <span class="hljs-number">20</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br>    &#123;<br>        a = <span class="hljs-string">&quot;s2&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Code_13_InitTest</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Code_13_InitTest d = <span class="hljs-keyword">new</span> Code_13_InitTest(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">30</span>);<br>        System.out.println(d.a);<br>        System.out.println(d.b);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会从上至下的顺序，收集所有{}代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>        <span class="hljs-number">0</span>: aload_0<br>        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>        <span class="hljs-number">4</span>: aload_0<br>        5: ldc           #2                  // String s1<br>        7: putfield      #3                  // Field a:Ljava/lang/String;<br>       <span class="hljs-number">10</span>: aload_0<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       13: putfield      #4                  // Field b:I<br>       <span class="hljs-number">16</span>: aload_0<br>       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span><br>       19: putfield      #4                  // Field b:I<br>       <span class="hljs-number">22</span>: aload_0<br>       23: ldc           #5                  // String s2<br>       25: putfield      #3                  // Field a:Ljava/lang/String;<br>       <span class="hljs-comment">// 原始构造方法在最后执行</span><br>       <span class="hljs-number">28</span>: aload_0<br>       <span class="hljs-number">29</span>: aload_1<br>       30: putfield      #3                  // Field a:Ljava/lang/String;<br>       <span class="hljs-number">33</span>: aload_0<br>       <span class="hljs-number">34</span>: iload_2<br>       35: putfield      #4                  // Field b:I<br>       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><h5 id="5-方法调用"><a href="#5-方法调用" class="headerlink" title="5.方法调用"></a>5.方法调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_14_MethodTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Code_14_MethodTest</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Code_14_MethodTest obj = <span class="hljs-keyword">new</span> Code_14_MethodTest();<br>        obj.test1();<br>        obj.test2();<br>        obj.test3();<br>        Code_14_MethodTest.test4();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用invokespecial指令</li><li>普通成员方法在调用时，使用invokevirtual指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定。</li><li>静态方法在调用时使用invokestatic指令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         0: new           #2                  //<br>         <span class="hljs-number">3</span>: dup <span class="hljs-comment">// 复制一份对象地址压入操作数栈中</span><br>         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V<br>         <span class="hljs-number">7</span>: astore_1<br>         <span class="hljs-number">8</span>: aload_1<br>         9: invokespecial #4                  // Method test1:()V<br>        <span class="hljs-number">12</span>: aload_1<br>        13: invokespecial #5                  // Method test2:()V<br>        <span class="hljs-number">16</span>: aload_1<br>        17: invokevirtual #6                  // Method test3:()V<br>        20: invokestatic  #7                  // Method test4:()V<br>        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>new是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作栈</li><li>dup是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢？一个是要配合invokespecial调用该对象的构造方法“init:()V”（会消耗掉栈顶一个引用），另一个要配合astore_1赋值给局部变量</li><li>终方法(final),私有方法(private)，构造方法都是由invokespecial指令来调用，属于静态绑定</li><li>普通成员方法是由invokevirtual调用，属于动态绑定，即支持多态成员方法与静态方法调用的另一个区别，执行方法前是否需要【对象引用】</li></ul><h5 id="6-多态原理"><a href="#6-多态原理" class="headerlink" title="6.多态原理"></a>6.多态原理</h5><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令</p><p>在执行invokevirtual指令时，经历以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的class</li><li>Class结构中有vtable</li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h5 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h5><p><strong>try-catch</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_15_TryCatchTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>     <span class="hljs-comment">//多出来一个异常表</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>可以看到多出来一个Exception table结构，[from,to)是前必后开（也就是检查2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过type匹配异常类型，如果一致，进入target所指示行号</li><li>8行的字节码指令astore_2是将异常对象引入存入局部变量表的2号位置(为e)</li></ul><p><strong>多个single-catch</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_16_MultipleCatchTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">30</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span><br>        <span class="hljs-number">8</span>: astore_2<br>        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">11</span>: istore_1<br>       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span><br>       <span class="hljs-number">15</span>: astore_2<br>       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">18</span>: istore_1<br>       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><ul><li>因为异常出现时，只能进入Exception table 中一个分支，所以局部变量表slot2位置被共用</li></ul><p><strong>finally</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_17_FinallyTest</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            i = <span class="hljs-number">20</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i = <span class="hljs-number">30</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: iconst_0<br>        <span class="hljs-number">1</span>: istore_1<br>        <span class="hljs-comment">// try块</span><br>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">4</span>: istore_1<br>        <span class="hljs-comment">// try块执行完后，会执行finally    </span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-number">7</span>: istore_1<br>        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">// catch块     </span><br>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">// 异常信息放入局部变量表的2号槽位</span><br>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">14</span>: istore_1<br>       <span class="hljs-comment">// catch块执行完后，会执行finally        </span><br>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">17</span>: istore_1<br>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span><br>       <span class="hljs-comment">// 出现异常，但未被 Exception 捕获，会抛出其他异常，这时也需要执行 finally 块中的代码   </span><br>       <span class="hljs-number">21</span>: astore_3<br>       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span><br>       <span class="hljs-number">24</span>: istore_1<br>       <span class="hljs-number">25</span>: aload_3<br>       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">// 抛出异常</span><br>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception<br>            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any<br>           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any<br></code></pre></td></tr></table></figure><p>可以看到finally中的代码被复制了3份，分别放入try流程，catch流程以及catch剩余的异常类型流程</p><p>注意：虽然从字节码指令看出来，每个块中都有finally块，但是finally块中的代码只会被执行一次</p><p><strong>finally中的return</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_18_FinallyReturnTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = Code_18_FinallyReturnTest.test();<br>        <span class="hljs-comment">// 结果为 20</span><br>        System.out.println(i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">try</span> &#123;<br>            i = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i = <span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0<br>        <span class="hljs-number">3</span>: iload_0<br>        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">// 暂存返回值</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0<br>        <span class="hljs-number">8</span>: iload_0<br>        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">// ireturn 会返回操作数栈顶的整型值 20</span><br>       <span class="hljs-comment">// 如果出现异常，还是会执行finally 块中的内容，没有抛出异常</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: iload_0<br>       <span class="hljs-number">15</span>: ireturn<span class="hljs-comment">// 这里没有 athrow 了，也就是如果在 finally 块中如果有返回操作的话，且 try 块中出现异常，会吞掉异常！</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br><br></code></pre></td></tr></table></figure><ul><li>由于finally中的ireturn被插入了所有可能的流程，因此返回结果肯定以finally的为准</li><li>至于字节码中第2行，看下个例子</li><li>跟上例中finally相比，发现没有athrow了，这告诉我们：如果在finally中出现了return，会吞掉异常</li><li>不要在finally中进行返回操作</li></ul><p><strong>被吞掉的异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">try</span> &#123;<br>         i = <span class="hljs-number">10</span>;<br>         <span class="hljs-comment">//  这里应该会抛出异常</span><br>         i = i/<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         i = <span class="hljs-number">20</span>;<br>         <span class="hljs-keyword">return</span> i;<br>      &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><p><strong>finally不带return</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">// 赋值给i 10</span><br>        <span class="hljs-number">3</span>: iload_0<span class="hljs-comment">// 加载到操作数栈顶</span><br>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">// 加载到局部变量表的1号位置</span><br>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">// 赋值给i 20</span><br>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">// 加载局部变量表1号位置的数10到操作数栈</span><br>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">// 返回操作数栈顶元素 10</span><br>       <span class="hljs-number">10</span>: astore_2<br>       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>       <span class="hljs-number">13</span>: istore_0<br>       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">// 加载异常</span><br>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">// 抛出异常</span><br>     Exception table:<br>        from    to  target type<br>            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any<br></code></pre></td></tr></table></figure><h5 id="8-Synchronized"><a href="#8-Synchronized" class="headerlink" title="8.Synchronized"></a>8.Synchronized</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_19_SyncTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Object lock = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            System.out.println(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         0: new           #2                  // class java/lang/Object<br>         <span class="hljs-number">3</span>: dup <span class="hljs-comment">// 复制一份栈顶，然后压入栈中。用于函数消耗</span><br>         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         <span class="hljs-number">7</span>: astore_1 <span class="hljs-comment">// 将栈顶的对象地址方法 局部变量表中 1 中</span><br>         <span class="hljs-number">8</span>: aload_1 <span class="hljs-comment">// 加载到操作数栈</span><br>         <span class="hljs-number">9</span>: dup <span class="hljs-comment">// 复制一份，放到操作数栈，用于加锁时消耗</span><br>        <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">// 将操作数栈顶元素弹出，暂存到局部变量表的 2 号槽位。这时操作数栈中有一份对象的引用</span><br>        <span class="hljs-number">11</span>: monitorenter <span class="hljs-comment">// 加锁</span><br>        12: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>        15: ldc           #4                  // String ok<br>        17: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>        <span class="hljs-number">20</span>: aload_2 <span class="hljs-comment">// 加载对象到栈顶</span><br>        <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-number">22</span>: goto          <span class="hljs-number">30</span><br>        <span class="hljs-comment">// 异常情况的解决方案 释放锁！</span><br>        <span class="hljs-number">25</span>: astore_3                    <span class="hljs-comment">//any -&gt; slot 3</span><br>        <span class="hljs-number">26</span>: aload_2                      <span class="hljs-comment">//&lt; - slot 2(lock引用)</span><br>        <span class="hljs-number">27</span>: monitorexit                  <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-number">28</span>: aload_3<br>        <span class="hljs-number">29</span>: athrow<br>        <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 异常表！</span><br>      Exception table:<br>         from    to  target type<br>            <span class="hljs-number">12</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   any<br>            <span class="hljs-number">25</span>    <span class="hljs-number">28</span>    <span class="hljs-number">25</span>   any<br><br><br></code></pre></td></tr></table></figure><h4 id="二、编译器处理"><a href="#二、编译器处理" class="headerlink" title="二、编译器处理"></a>二、编译器处理</h4><p>所谓<strong>语法糖</strong>，其实就是指java编译器把.java源码编译为.class字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员负担</p><p><strong>注意</strong>，以下代码的分析，借助了javap工具，idea的反编译功能。idea插件jclasslib等工具。另外，编译器转换的结果直接<strong>就是class字节码</strong>，只是为了便于阅读，给出了几乎等价的java源码方式，并不是编译器还会转换出中间的java源码。</p><h5 id="1-默认构造器"><a href="#1-默认构造器" class="headerlink" title="1.默认构造器"></a>1.默认构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span></span>&#123;<br> <span class="hljs-comment">// 这个无参构造器是java编译器帮我们加上的</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br>    <span class="hljs-keyword">super</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-自动拆装箱"><a href="#2-自动拆装箱" class="headerlink" title="2.自动拆装箱"></a>2.自动拆装箱</h5><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK5以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Integer x = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> y = x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy2</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 基本类型赋值给包装类型，称为装箱</span><br>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 包装类型赋值给基本类型，称谓拆箱</span><br>      <span class="hljs-keyword">int</span> y = x.intValue();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-泛型集合取值"><a href="#3-泛型集合取值" class="headerlink" title="3.泛型集合取值"></a>3.泛型集合取值</h5><p>泛型也是在JDK5开始加入的特性，但java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当作了Object类型来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy3</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      list.add(<span class="hljs-number">10</span>);<br>      Integer x = list.get(<span class="hljs-number">0</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       0: new           #2                  // class java/util/ArrayList<br>       <span class="hljs-number">3</span>: dup<br>       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-comment">// 这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z<br><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">// 这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<br><span class="hljs-comment">// 这里进行了类型转换，将 Object 转换成了 Integer</span><br>      27: checkcast     #7                  // class java/lang/Integer<br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有自动拆箱的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer)list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></table></figure><p>使用反射可以得到，参数的类型以及泛型类型。泛型反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>    <span class="hljs-comment">// 1. 拿到方法</span><br>    Method method = Code_20_ReflectTest.class.getMethod(<span class="hljs-string">&quot;test&quot;</span>, List.class, Map.class);<br>    <span class="hljs-comment">// 2. 得到泛型参数的类型信息</span><br>    Type[] types = method.getGenericParameterTypes();<br>    <span class="hljs-keyword">for</span>(Type type : types) &#123;<br>        <span class="hljs-comment">// 3. 判断参数类型是否，带泛型的类型。</span><br>        <span class="hljs-keyword">if</span>(type <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            ParameterizedType parameterizedType = (ParameterizedType) type;<br><br>            <span class="hljs-comment">// 4. 得到原始类型</span><br>            System.out.println(<span class="hljs-string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());<br>            <span class="hljs-comment">// 5. 拿到泛型类型</span><br>            Type[] arguments = parameterizedType.getActualTypeArguments();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span></span><br>泛型参数[0] - class java.lang.String<br>原始类型 - <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Map</span></span><br>泛型参数[0] - class java.lang.Integer<br>泛型参数[<span class="hljs-number">1</span>] - <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">Object</span></span><br></code></pre></td></tr></table></figure><p>注意，如果调用的是foo(),即未传递参数时，等价代码未foo(new String[]{}),创建了一个空数组，而不是直接传递的null</p><h5 id="5-foreach循环"><a href="#5-foreach循环" class="headerlink" title="5.foreach循环"></a>5.foreach循环</h5><p>仍是JDK 5开始引入的语法糖，数组的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 数组赋初值的简化写法也是一种语法糖。</span><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy5</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br><span class="hljs-keyword">int</span> x = arr[i];<br>System.out.println(x);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果时集合使用foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-keyword">for</span> (Integer x : list) &#123;<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了Iterable接口，因为集合的遍历需要用到迭代器Iterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy5</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>      <span class="hljs-comment">// 获得该集合的迭代器</span><br>      Iterator&lt;Integer&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         Integer x = iterator.next();<br>         System.out.println(x);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-switch字符串"><a href="#6-switch字符串" class="headerlink" title="6.switch字符串"></a>6.switch字符串</h5><p>从JDK7开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cnady6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">switch</span> (str) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;world&quot;</span> :<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从编译器中执行的制作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy6</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy6</span><span class="hljs-params">()</span> </span>&#123;<br>      <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      String str = <span class="hljs-string">&quot;hello&quot;</span>;<br>      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 通过字符串的 hashCode + value 来判断是否匹配</span><br>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;<br>         <span class="hljs-comment">// hello 的 hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>            <span class="hljs-comment">// 再次比较，因为字符串的 hashCode 有可能相等</span><br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>)) &#123;<br>               x = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">// world 的 hashCode</span><br>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;world&quot;</span>)) &#123;<br>               x = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 用第二个 switch 在进行输出判断</span><br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;h&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h5 id="7-switch枚举"><a href="#7-switch枚举" class="headerlink" title="7.switch枚举"></a>7.switch枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy7</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) &#123;<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译器中执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy7</span> </span>&#123;<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;<br>      <span class="hljs-comment">// 数组大小即为枚举元素个数，里面存放了 case 用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-comment">// ordinal 即枚举元素对应所在的位置，MALE 为 0 ，FEMALE 为 1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">// 将对应位置枚举元素的值赋给 x ，用于 case 操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;man&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;woman&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-枚举类"><a href="#8-枚举类" class="headerlink" title="8.枚举类"></a>8.枚举类</h5><p>JDK7新增了枚举类，以前面的性别枚举为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>&#123;<br>   MALE, FEMALE;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;   <br>   <span class="hljs-comment">// 对应枚举类中的元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br>   <br>    <span class="hljs-keyword">static</span> &#123;       <br>    <span class="hljs-comment">// 调用构造函数，传入枚举元素的值及 ordinal</span><br>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;MALE&quot;</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">&quot;FEMALE&quot;</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; <br>   &#125;<br> <br>   <span class="hljs-comment">// 调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    &#125; <br>   <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-try-with-resources"><a href="#9-try-with-resources" class="headerlink" title="9.try-with-resources"></a>9.try-with-resources</h5><p>JDK7开始新增了对需要关闭的资源处理的特殊语法，‘try-with-resources’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量 = 创建资源对象) &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>() &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中资源对象需要实现AutoCloseable接口，列如InputStream，OutputStream，Connection，Statement，ResultSet等接口都实现了AutoCloseable，使用try-with-resources可以不用写finally语句块，编译器会帮助生成关闭资源代码例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>))&#123;<br>System.out.println(is); <br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; <br>e.printStackTrace(); <br>&#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>&#123; <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>        <span class="hljs-keyword">try</span> &#123;<br>            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;d:\\1.txt&quot;</span>);<br>            Throwable t = <span class="hljs-keyword">null</span>; <br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(is); <br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123; <br>                <span class="hljs-comment">// t 是我们代码出现的异常 </span><br>                t = e1; <br>                <span class="hljs-keyword">throw</span> e1; <br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 判断了资源不为空 </span><br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123; <br>                    <span class="hljs-comment">// 如果我们代码有异常</span><br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123; <br>                        <span class="hljs-keyword">try</span> &#123;<br>                            is.close(); <br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123; <br>                            <span class="hljs-comment">// 如果 close 出现异常，作为被压制异常添加</span><br>                            t.addSuppressed(e2); <br>                        &#125; <br>                    &#125; <span class="hljs-keyword">else</span> &#123; <br>                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e </span><br>                        is.close(); <br>                    &#125; <br>                &#125; <br>            &#125; <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace(); <br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要设置一个addSuppressed(Throwable e) (添加被压制异常)的方法呢？</p><p>是为了防止异常信息的丢失（想想try-with-resources生成的finally中如果抛出了异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br><span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) &#123; <br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>; <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123; <br>e.printStackTrace(); <br>&#125; <br>&#125; <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;close 异常&quot;</span>); <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero <br>at test.Test6.main(Test6.java:<span class="hljs-number">7</span>) <br>Suppressed: java.lang.Exception: close 异常 <br>at test.MyResource.close(Test6.java:<span class="hljs-number">18</span>) <br>at test.Test6.main(Test6.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><h5 id="10-方法重写时的桥接方法"><a href="#10-方法重写时的桥接方法" class="headerlink" title="10.方法重写时的桥接方法"></a>10.方法重写时的桥接方法</h5><p>我们都知道，方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（见下面例子）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125; <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; <br><span class="hljs-meta">@Override</span> <br><span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>对于子类，java编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>&#125;<br><span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123; <br><span class="hljs-comment">// 调用 public Integer m() </span><br><span class="hljs-keyword">return</span> m(); <br>&#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中桥接方法比较特殊，仅对java虚拟机可见，并且与原来的public Integer m()没有命名冲突，可以用反射代码证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(Method m : B.class.getDeclaredMethods()) &#123;<br>            System.out.println(m);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer cn.ali.jvm.test.B.m()<br><span class="hljs-keyword">public</span> java.lang.Number cn.ali.jvm.test.B.m()<br></code></pre></td></tr></table></figure><h5 id="11-匿名内部类"><a href="#11-匿名内部类" class="headerlink" title="11.匿名内部类"></a>11.匿名内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>         &#125;<br>      &#125;;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">// 用额外创建的类来创建匿名内部类对象</span><br>      Runnable runnable = <span class="hljs-keyword">new</span> Candy10$<span class="hljs-number">1</span>();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建了一个额外的类，实现了 Runnable 接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy10</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;running...&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引用局部变量的匿名内部类，源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123; <br>Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123; <br><span class="hljs-meta">@Override</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + x); <br>&#125; <br>&#125;; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类 </span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>#1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123; <br><span class="hljs-keyword">int</span> val$x; <br>Candy11$$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123; <br><span class="hljs-keyword">this</span>.val$x = x; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <br>System.out.println(<span class="hljs-string">&quot;ok:&quot;</span> + <span class="hljs-keyword">this</span>.val$x); <br>&#125; <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>&#123; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>&#123; <br>Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x); <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是final的；因为在创建Candy11#1对象时，将x的赋值给了Candy 11#1对象的值后，如果不是final声明的x值发生了改变，匿名内部类则值不一致。</p><h4 id="三、类加载阶段"><a href="#三、类加载阶段" class="headerlink" title="三、类加载阶段"></a>三、类加载阶段</h4><h5 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h5><ul><li>将类的字节码载入方法区（1.8后为元空间，在本地内存中），内部采用c++的instanceKlass描述java类，它的重要field有：<ul><li>_java_mirror 即java的类镜像，例如对String来说，它的镜像类就是String.Class,作用是把Klass暴露给java使用</li><li>_super即父类</li><li>_fields及成员变量</li><li>_methods即方法</li><li>_constants即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li></ul><p><img src="https://img-blog.csdnimg.cn/20210211160212124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><ul><li>instanceKlass保存在方法区。 JDK 8 以后，方法区位于元空间中，而元空间有位于本地内存中</li><li>_java_mirror则是保存在堆内存中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><p><strong>信息</strong></p><ul><li>instanceKlass这样的【元数据】是存储在方法区（1.8后的元空间内），但_java_mirror是存储在堆中</li><li>可以通过前面介绍的HSDB工具查看</li></ul><h5 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h5><p><strong>验证</strong></p><p>验证类是否符合JVM规范，安全性检查</p><p>用UE等支持二进制的编辑器修改Hello World.class的魔数，在控制台运行</p><p><strong>准备</strong></p><p>为static变量分配空间，设置默认值</p><ul><li>static变量在JDK 7 之前存储于instanceKlass 末尾，从JDK 7 开始，存储于_java_mirror末尾</li><li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果static变量是final的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static变量是final的，但属于引用类型的，那么赋值也会在初始化阶段将常量池中的符号引用解析为直接引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_22_AnalysisTest</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException </span>&#123;<br>        ClassLoader classLoader = Code_22_AnalysisTest.class.getClassLoader();<br>        Class&lt;?&gt; c = classLoader.loadClass(<span class="hljs-string">&quot;cn.ali.jvm.test.C&quot;</span>);<br><br>        <span class="hljs-comment">// new C();</span><br>        System.in.read();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    D d = <span class="hljs-keyword">new</span> D();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h5><p><strong><clinit>()v方法</strong></p><p>初始化即调用<clinit>()V,虚拟机会保证这个类的【构造方法】的线程安全</p><p><strong>发生的时机</strong></p><p>概括地说，类初始化是【懒惰的】</p><ul><li>main方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果是父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new会导致初始化</li></ul><p>不会导致初始化的情况</p><ul><li>访问类的static final静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class不会触发初始化</li><li>创建该类的数组不会触发初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main init&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">// 1. 静态常量（基本类型和字符串）不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(B.b);</span><br>        <span class="hljs-comment">// 2. 类对象.class 不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(B.class);</span><br>        <span class="hljs-comment">// 3. 创建该类的数组不会触发初始化</span><br><span class="hljs-comment">//         System.out.println(new B[0]);</span><br>        <span class="hljs-comment">// 4. 不会初始化类 B，但会加载 B、A</span><br><span class="hljs-comment">//         ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="hljs-comment">//         cl.loadClass(&quot;cn.ali.jvm.test.classload.B&quot;);</span><br>        <span class="hljs-comment">// 5. 不会初始化类 B，但会加载 B、A</span><br><span class="hljs-comment">//         ClassLoader c2 = Thread.currentThread().getContextClassLoader();</span><br><span class="hljs-comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;, false, c2);</span><br><br><br>        <span class="hljs-comment">// 1. 首次访问这个类的静态变量或静态方法时</span><br><span class="hljs-comment">//         System.out.println(A.a);</span><br>        <span class="hljs-comment">// 2. 子类初始化，如果父类还没初始化，会引发</span><br><span class="hljs-comment">//         System.out.println(B.c);</span><br>        <span class="hljs-comment">// 3. 子类访问父类静态变量，只触发父类初始化</span><br><span class="hljs-comment">//         System.out.println(B.a);</span><br>        <span class="hljs-comment">// 4. 会初始化类 B，并先初始化类 A</span><br><span class="hljs-comment">//         Class.forName(&quot;cn.ali.jvm.test.classload.B&quot;);</span><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a init&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;b init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h5><p>从字节码分析，使用a，b，c这三个常量是否会导致E初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(E.a);<br>        System.out.println(E.b);<br>        <span class="hljs-comment">// 会导致 E 类初始化，因为 Integer 是包装类</span><br>        System.out.println(E.c);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;E cinit&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>典型应用-完成懒惰初始化单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>    <span class="hljs-comment">// 内部类中保存单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123; <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton(); <br>    &#125;<br>    <span class="hljs-comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是</p><ul><li>懒惰实例化</li><li>初始化时的线程安全是有保障的 </li></ul><h5 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5.类加载器"></a>5.类加载器</h5><p>类加载器虽然只用于实现类的加载动作，但它在java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在java虚拟机中的唯一性，没一个类加载器，都拥有一个独立的类名称空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是同一个类加载器的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p>以jdk8为例</p><table><thead><tr><th align="center">名称</th><th align="center">加载的类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Bootstrap ClassLoader（启动类加载器）</td><td align="center">JAVA_HOME/jre/lib</td><td align="center">无法直接访问</td></tr><tr><td align="center">Extension ClassLoader(拓展类加载器)</td><td align="center">JAVA_HOME/jre/lib/ext</td><td align="center">上级为Bootstrap，显示为null</td></tr><tr><td align="center">Application ClassLoader(应用程序类加载器)</td><td align="center">classpath</td><td align="center">上级为Extension</td></tr><tr><td align="center">自定义类加载器</td><td align="center">自定义</td><td align="center">上级为Application</td></tr></tbody></table><p><strong>1.启动类的加载器</strong></p><p>可通过在控制台输入指令，使得类被启动类加载</p><p><strong>2.扩展类的加载器</strong></p><p>如果classpath和JAVA_HOME/jre/lib/ext下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会在加载。</p><p><strong>3.双亲委派模式</strong></p><p>双亲委派模式，即调用类加载器ClassLoader的loadClass方法，查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-comment">// 如果没有被加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 看是否被它的上级加载器加载过了 Extension 的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 看是否被启动类加载器加载过</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>                <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果还是没有找到，先让拓展类加载器调用 findClass 方法去找到该类，如果还是没找到，就抛出异常</span><br>                <span class="hljs-comment">// 然后让应用类加载器去找 classpath 下找该类</span><br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// 记录时间</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.自定义类加载器</strong></p><p><strong>使用场景</strong></p><ul><li>想加载非classpath随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器</li></ul><p><strong>步骤</strong></p><ul><li><p>继承ClassLoader父类</p></li><li><p>要遵从双亲委派机制，重写findClass方法</p><p>不是重写loadClass方法，否则不会走双亲委派机制</p></li><li><p>读取类文件的字节码</p></li><li><p>调用父类的defindeClass方法来加载类</p></li><li><p>使用者调用该类加载器的loadClass方法</p></li></ul><p><strong>破坏双亲委派模式</strong></p><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词“代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h5 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6.运行期优化"></a>6.运行期优化</h5><p><strong>1.即时编译</strong></p><p><strong>分层编译</strong></p><p>JVM将执行状态分为了5个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用C1即时编译器编译执行（不带profiling）</li><li>2层：使用C1即时编译器编译执行（带基本的profiling）</li><li>3层：使用C1即时编译器编译执行（完全带profiling）</li><li>4层：使用C2即时编译器编译执行</li></ul><p>profiling是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】、【循环的回边次数】等</p><p><strong>即时编译器（JIT）于解释器的区别</strong></p><ul><li>解释器<ul><li>将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的次数</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码编译为机器码，并存入Code Cache，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需消耗时间将其编译为机器码，而是采用解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上简单比较一下Interpreter&lt;C1&lt;C2，总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</p><p><strong>逃逸分析</strong></p><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot虚拟机可以分析新创建对象的使用范围，并决定是否在Java堆上分配内存的一项技术</p><p>逃逸分析的JVM参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p>全局逃逸（GlobalEscape）</p><p>一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p><ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul><p>参数逃逸（ArgEscape）</p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p>没有逃逸</p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong><br>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化</p><p><em>1.锁消除</em><br>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁<br>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作<br>锁消除的 JVM 参数如下：</p><p>开启锁消除：-XX:+EliminateLocks<br>关闭锁消除：-XX:-EliminateLocks<br>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><em>2.标量替换</em><br>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象<br>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能<br>标量替换的 JVM 参数如下：</p><p>开启标量替换：-XX:+EliminateAllocations<br>关闭标量替换：-XX:-EliminateAllocations<br>显示标量替换详情：-XX:+PrintEliminateAllocations<br>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><em>3.栈上分配</em><br>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><p>4.<em>方法内联</em></p><p><strong>内联函数</strong></p><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><p><strong>JVM内联函数</strong></p><p>C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，只能够向编译器提出请求：关键字final修饰 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// to do something  </span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当作内联函数，只有声明了final后，编译器才会考虑是不是要把函数变为内联函数</p><p>JVM内建有许多运行时的优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。。</p><p>第二个原因则更重要：方法内联</p><p>如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <br><span class="hljs-comment">//这里调用了add2方法</span><br>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> x1 + x2;  <br>    &#125;<br><br></code></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>    &#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.反射优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;foo...&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>      Method foo = Demo3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;<br>         foo.invoke(<span class="hljs-keyword">null</span>);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo.invoke前面0~15次调用使用的是MethodAccessor的NativeMethodAccessorImpl实现</p><p>invoke方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="hljs-function">       InvocationTargetException</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;<br>        ma = acquireMethodAccessor();<br>    &#125;<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210211225135924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>会由DelegatingMethodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) &#123;<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    &#125;<br><br><span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) &#123;<br>            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());<br>            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactoryThreshold的值16时，就会本地方法访问器替换为一个运动时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为正常调用，即直接调用Reflect1.foo()</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210211225248176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p>阿里开源工具：arthas-boot</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记3</title>
    <link href="/2021/10/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2021/10/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h3 id="一、垃圾回收器"><a href="#一、垃圾回收器" class="headerlink" title="一、垃圾回收器"></a>一、垃圾回收器</h3><p><img src="https://img2020.cnblogs.com/other/1218593/202006/1218593-20200617151346008-1339974706.webp" alt="垃圾收集器"></p><p><strong>相关概念</strong></p><ul><li>并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</li><li>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上</li><li>吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）），也就是例如：虚拟机共运行100min，垃圾收集器花掉1min，那么吞吐量为99%。</li></ul><h4 id="1-串行"><a href="#1-串行" class="headerlink" title="1.串行"></a>1.串行</h4><ul><li>单线程</li><li>堆内存较小，适合个人电脑</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210092812153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="并行"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseSerialGC=serial + serialOld<br></code></pre></td></tr></table></figure><p><strong>安全点</strong>： 让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。并且该线程执行回收工作时，其他线程进入阻塞状态。</p><p><strong>serial收集器</strong>： </p><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点</strong>：单线程、简单高效（与其他收集器相的单线程相比），采用复制算法。对于限定单个CPU环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（STW）。</p><p><strong>ParNew收集器</strong></p><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在STW问题。</p><p><strong>Serial Old收集器</strong></p><p>serial old是serial收集器的老年代版本</p><p><strong>特点</strong>： 同样是单线程收集器，采用标记-整理算法。</p><h4 id="2-吞吐量优先"><a href="#2-吞吐量优先" class="headerlink" title="2.吞吐量优先"></a>2.吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核cpu</li><li>让单位时间内，STW的时间最短0.2 0.2 = 0.4</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210094915306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="吞吐量优先"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX：+UseParallelGC ~ -XX：+UsePrallerOldGC<br>-XX：+UseAdaptiveSizePolicy<br>-XX：GCTimeRatio=ratio <span class="hljs-comment">/*  1/（1+radio）*/</span><br>-XX：MaxGCPauseMillis=ms<span class="hljs-comment">// 200ms</span><br>-XX：ParallelGCThreads=n<br></code></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器</strong></p><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>： 属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）</p><p>GC自适应调节策略：</p><p>Parallel Scavenge收集器可设置 -XX：+UseAdptiveSizePocily参数</p><p>当开关打开时不需要手动设置新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRation）</p><p>晋升老年代的对象年龄（-XX：PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为 GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量</p><ul><li>XX：MaxGCPauseMillis=ms控制最大的垃圾收集停顿时间（默认200ms）</li><li>XX：GCTimeRatio= ratio直接设置吞吐量大小</li></ul><p><strong>Parallel Old收集器</strong></p><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>： 多线程，采用标记-整理算法（老年代没有幸存区）</p><h4 id="3-响应时间优先"><a href="#3-响应时间优先" class="headerlink" title="3.响应时间优先"></a>3.响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让STW的单词时间最短0.1 0.1 0.1 0.1 0.1 = 0.5</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210104030390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="响应时间优先"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX：+UseConcMarkSweepGC ~ -XX：+UseParNewGC ~ SerialOld<br>-XX：ParallelGCThreads=n ~ -XX：ConcGCThreads=threads<br>-XX：CMSInitiatingOccupancyFraction=percent<br>-XX：+CMSScavengeBeforeRemark<br></code></pre></td></tr></table></figure><p><strong>CMS收集器</strong></p><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的<strong>老年代收集器</strong></p><p><strong>特点</strong>：基于标记-清理算法实现。并发收集、低停顿、但是会产生内存碎片</p><p><strong>应用场景</strong>： 适用于注重服务的相应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下，如web程序，b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步</strong><br><strong>初始标记</strong>： 标记GC Roots能直接到的对象，速度很快但是仍存在STP问题</p><p><strong>并发标记</strong>： 进行GC Roots Tracing的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>： 为了修改并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在STP问题</p><p>并发清理：对标记的对象进行清理回收，清除过程中，可能仍然会产生新的垃圾，这些垃圾称为浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为serial old收集器，将老年代的垃圾进行标记-整理，这也很消耗时间</p><p>CMS收集器的内存回收过程是与用户线程一起并发执行的，可以搭配ParNew收集器（多线程、新生代、复制算法）与Serial Old收集器（单线程、老年代、标记-整理算法）使用</p><h4 id="4-G1收集器"><a href="#4-G1收集器" class="headerlink" title="4.G1收集器"></a>4.G1收集器</h4><p><strong>定义</strong>： Garbage First</p><p><strong>使用场景</strong>： </p><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li>整体上是标记-整理算法，两个区域之间是复制算法</li></ul><p><strong>相关参数</strong></p><p>JDK8并不是默认开启的，所需要参数开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseG1GC<br>-XX:G1HeapRegionSize=size<br>-XX:MaxGCPauseMillis=time<br></code></pre></td></tr></table></figure><p><strong>G1垃圾回收阶段</strong></p><p><img src="https://img-blog.csdnimg.cn/20210210114932887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="G1垃圾回收阶段"></p><p>Young Collection：对新生代垃圾收集</p><p>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记</p><p>Mixed Collection：会对新生代+老年代+幸存区等进行混合收集，然后收集结束，会重新进入新生代收集</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>新生代存在STW</strong>：</p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制回收多少个小区间，方便控制GC产生的停顿时间</p><p>E：eden  S：幸存区  O：老年代</p><p>新生代收集会产生STW</p><p><img src="https://img-blog.csdnimg.cn/20210210122339138.gif" alt="Young Collection"></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>在Young GC时会进行GC Root的初始化标记</p><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），有下面的JVM参数决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:InitiatingHeapOccupancyPercent = percent  <span class="hljs-comment">//(默认45%)</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210210122601873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Young Collection + CM"></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O进行<strong>全面的回收</strong></p><ul><li>最终标记会STW</li><li>拷贝存活会STW</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MaxGCPauseMills = xxms  <span class="hljs-comment">//用于指定最长的停顿时间</span><br></code></pre></td></tr></table></figure><p>Q:为什么有的老年代被拷贝了，有的没有？</p><p>A:因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多的内存）</p><p><img src="https://img-blog.csdnimg.cn/20210210144216170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Mixed Collection"></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><ul><li>Serial GC<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足发生的垃圾收集 - full GC</li></ul></li><li>Parallel GC<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足发生的垃圾收集 - full GC</li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足时（老年代所占内存超过阈值）<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，然后退化成serial Old收集器串行的收集，就会导致停顿的时候长。</li></ul></li></ul></li><li>G1<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存不足时（老年代所占内存超过阈值）<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC，然后退化成serial Old收集器串行的收集，就会导致停顿的时候长</li></ul></li></ul></li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210154730275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="Young Collection跨代引用"></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域为512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post -write barried + dirty card queue</li><li>concurrent  refinement threads 更新 Remembered Set</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210154940579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="跨代引用"></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><ul><li>黑色：已被处理的，需要保留的</li><li>灰色：正在处理中的</li><li>白色：还未处理的</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210161204728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="三色标记法"></p><p>但是在并发标记中，有可能A被处理了以后未引用C，但该处理还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为处理中状态</li><li>在并发标记阶段结束后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用他，就会处理它，用灰色变为黑色</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210161559793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210210161527103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70"></p><h5 id="JDK-8u20字符串去重"><a href="#JDK-8u20字符串去重" class="headerlink" title="JDK 8u20字符串去重"></a>JDK 8u20字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们引用同一个字符串对象</li><li>注意，其与String.intern()的区别<ul><li>String.intern()关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微占用CPU</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UserStringDeduplication<br></code></pre></td></tr></table></figure><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60回收巨型对象"><a href="#JDK-8u60回收巨型对象" class="headerlink" title="JDK 8u60回收巨型对象"></a>JDK 8u60回收巨型对象</h5><ul><li>一个对象大于region的一半时，就成为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时被处理掉</li></ul><p><img src="https://img-blog.csdnimg.cn/20210210165555732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="回收巨型对象"></p><h5 id="JDK9并发标记起始时间的调整"><a href="#JDK9并发标记起始时间的调整" class="headerlink" title="JDK9并发标记起始时间的调整"></a>JDK9并发标记起始时间的调整</h5><ul><li>并发标记必须在堆空间占满前完成，否则退化为FullGC</li><li>JDK9之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK9可以动态调整<ul><li>-XX:InitiatingHeapOccupancyPercent用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h4 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h4><p>查看虚拟机参数命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\JavaJDK<span class="hljs-number">1</span>.<span class="hljs-number">8</span>\bin\java -XX:+PrintFlagFinal -version | findstr <span class="hljs-string">&quot;GC&quot;</span><br></code></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h5 id="1-调优领域"><a href="#1-调优领域" class="headerlink" title="1.调优领域"></a>1.调优领域</h5><ul><li>内存</li><li>锁竞争</li><li>cpu占用</li><li>io</li><li>gc</li></ul><h5 id="2-确定目标"><a href="#2-确定目标" class="headerlink" title="2.确定目标"></a>2.确定目标</h5><p>低延迟/高吞吐量？选择合适的GC</p><ul><li>CMS G1 ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h5 id="3-最快的GC"><a href="#3-最快的GC" class="headerlink" title="3.最快的GC"></a>3.最快的GC</h5><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑一下问题<ul><li>数据是不是太多？<ul><li>resultSet = statment executeQuery(select * from 大表 limit n)</li></ul></li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小 16 Integer 24  int 4</li></ul></li><li>是否存在内存泄露<ul><li>static Map map = …</li><li>软引用</li><li>弱引用</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h5 id="4-新生代调优"><a href="#4-新生代调优" class="headerlink" title="4 新生代调优"></a>4 新生代调优</h5><ul><li>新生代特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB thread-local allocation buffer</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>Minor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小： 频繁出发Minor GC ，会STW，会使得吞吐量下降</li><li>新生代内存太大： 老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为能容纳所有【并发量*（请求-相应）】的数据为宜</li></ul></li><li>幸存区需要能够保存当前活动对象+需要晋升的对象</li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:MaxTenuringThreshold=threshold<br>-XX:+PrintTenuringDistrubution<br></code></pre></td></tr></table></figure><h5 id="5-老年代调优"><a href="#5-老年代调优" class="headerlink" title="5.老年代调优"></a>5.老年代调优</h5><p>以CMS为例：</p><ul><li>CMS的老年代内存越大越好</li><li>先尝试不做调优，如果没有Full GC那么已经很好了，否则先尝试调优新生代</li><li>观察发现Full GC 时老年代内存占用，将老年代内存预设调大1/4~1/3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:CMSInitiatingOccupancyFraction=percent<br></code></pre></td></tr></table></figure><h5 id="6-案例"><a href="#6-案例" class="headerlink" title="6.案例"></a>6.案例</h5><p>案例1：<strong>Full GC和Minor GC频繁</strong> —- 通过调整新生代内存空间，将新生代空间适当调大。</p><p>案例2： <strong>请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong> —- 在重新标记阶段前对新生代的对象进行一次垃圾清理，存活对象少了，重新标记阶段的对象就少得多。</p><p>案例3：<strong>老年代充裕情况下，发生Full GC（jdk 1.7）</strong>  —-  在jdk1.8之前采用的是永久代作为方法区的实现，jdk1.8之后采用的是元空间作为方法区的实现。永久代的空间不足也会导致Full GC的发生。元空间的默认空间采用的是操作系统的空间，空间较大。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法54[力扣33]-搜索旋转排序数组</title>
    <link href="/2021/09/24/%E7%AE%97%E6%B3%9554-%E5%8A%9B%E6%89%A333-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/09/24/%E7%AE%97%E6%B3%9554-%E5%8A%9B%E6%89%A333-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span><br>输出：-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><strong>提示</strong>：</p><ul><li>1 &lt;= nums.length &lt;= 5000`</li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了 target</span><br>        <span class="hljs-keyword">while</span>( left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置数字 nums[mid] 等于目标值 target，那么说明找到了</span><br>            <span class="hljs-comment">// 返回当前的下标 mid</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br><br>            <span class="hljs-comment">// 否则的话需要先确定 mid 的左边还是右边为有序区间</span><br><br>            <span class="hljs-comment">// 如果当前区间最左端的值 nums[left] 小于等于 nums[mid]</span><br>            <span class="hljs-comment">// 说明从 left 到 mid 这段区间是递增的，为有序区间</span><br>            <span class="hljs-comment">// 即 mid 的左侧为有序区间，右侧为无序区间</span><br>            <span class="hljs-keyword">if</span>(nums[left] &lt;= nums[mid])&#123;<br><br>                <span class="hljs-comment">// 先去判断 target 是否在左侧有序区间内</span><br>                <span class="hljs-comment">// 如果目标值 target 大于这段有序区间的最小值 nums[left] 同时小于这段有序区间的最大值 nums[mid]</span><br>                <span class="hljs-comment">// 那么说明需要在这段有序区间去寻找 target </span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid])&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                    right = mid - <span class="hljs-number">1</span>;<br><br>                    <span class="hljs-comment">// 否则说明需要在 mid 的右侧无序区间搜索</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br><br>            <span class="hljs-comment">// 否则说明当前区间最左端的值 nums[left] 大于 nums[mid]</span><br>            <span class="hljs-comment">// 说明从 left 到 mid 这段区间是无序区间</span><br>            <span class="hljs-comment">// 即 mid 的左侧为无序区间，右侧为有序区间 </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 先去判断 target 是否在右侧有序区间内</span><br>                <span class="hljs-comment">// 如果目标值 target 大于这段有序区间的最小值 nums[mid] 同时小于这段有序区间的最大值 nums[right]</span><br>                <span class="hljs-comment">// 那么说明需要在这段有序区间去寻找 target </span><br>                <span class="hljs-keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right])&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                    left = mid + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 否则说明需要在 mid 的左侧无序区间搜索</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                    <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                    right = mid - <span class="hljs-number">1</span>;<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 目标值不存在，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法53[力扣34]-在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="/2021/09/24/%E7%AE%97%E6%B3%9553-%E5%8A%9B%E6%89%A334-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/09/24/%E7%AE%97%E6%B3%9553-%E5%8A%9B%E6%89%A334-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;= nums.length &lt;= 105</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>nums 是一个非递减数组</li><li>-109 &lt;= target &lt;= 109</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">// 寻找目标值在数组中的开始位置</span><br>        <span class="hljs-keyword">int</span> firstIdx = findBeginPostion(nums,target);<br><br>        <span class="hljs-comment">// 寻找目标值在数组中的结束位置</span><br>        <span class="hljs-keyword">int</span> lastIdx = findEndPostion(nums,target);<br><br>        <span class="hljs-comment">// 返回寻找的结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;firstIdx,lastIdx&#125;;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 寻找目标值在数组中的开始位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findBeginPostion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">int</span> target)</span></span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了起始位置</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值等于目标值 target</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br><br>                <span class="hljs-comment">// 并且中间位置 mid 的左边没有元素，即中间位置 mid 为当前区间的起始位置</span><br>                <span class="hljs-comment">// 或者中间位置 mid 的前一个元素小于目标值 target</span><br>                <span class="hljs-comment">// 说明 mid 指向了 target 的起始位置</span><br>                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">0</span> || nums[mid - <span class="hljs-number">1</span>] &lt; target)&#123;<br>                    <span class="hljs-comment">// mid 指向了 target 的起始位置，返回这个结果</span><br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，说明 mid 的左边依然有元素值等于 target</span><br>                <span class="hljs-comment">// 那么 mid 就不是 target 的起始位置，需要在 mid 的左边进行查找</span><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值大于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的左边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums[mid] &gt; target)&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值小于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的右边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 寻找目标值在数组中的结束位置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findEndPostion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums , <span class="hljs-keyword">int</span> target)</span></span>&#123;<br><br>        <span class="hljs-comment">// left 指向当前区间的最左边位置，所以初始化为 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right 指向当前区间的最右边位置，所以初始化为 nums.length - 1</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 循环进行二分查找，直到左端点位置超过了右端点</span><br>        <span class="hljs-comment">// 或者在循环过程中找到了结束位置    </span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 计算当前区间的中间位置，向下取整</span><br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值等于目标值 target</span><br>            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>                <span class="hljs-comment">// 并且中间位置 mid 的右边没有元素，即中间位置 mid 为当前区间的结束位置</span><br>                <span class="hljs-comment">// 或者中间位置 mid 的后一个元素大于目标值 target</span><br>                <span class="hljs-comment">// 说明 mid 指向了 target 的结束位置</span><br>                <span class="hljs-keyword">if</span>(mid == nums.length - <span class="hljs-number">1</span> || nums[mid + <span class="hljs-number">1</span>] &gt; target)&#123;<br>                    <span class="hljs-comment">// mid 指向了 target 的结束位置，返回这个结果</span><br>                    <span class="hljs-keyword">return</span> mid;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，说明 mid 的右边依然有元素值等于 target</span><br>                <span class="hljs-comment">// 那么 mid 就不是 target 的结束位置，需要在 mid 的右边进行查找</span><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1 ，右侧为 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值大于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的左边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( nums[mid] &gt; target)&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 left 到 mid - 1</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left，右侧 right = mid - 1</span><br>                right = mid - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果中间位置的元素值小于目标值 target</span><br>            <span class="hljs-comment">// 说明需要在 mid 的右边进行查找</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 所以缩小范围为 mid + 1 到 right</span><br>                <span class="hljs-comment">// 当前区间的左侧为 left = mid + 1，右侧 right </span><br>                left = mid + <span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果循环结束后还没有返回，说明找不到目标值 target，返回 -1</span><br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;    <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法52[力扣1]-两数之和</title>
    <link href="/2021/09/20/%E7%AE%97%E6%B3%9552-%E5%8A%9B%E6%89%A31-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2021/09/20/%E7%AE%97%E6%B3%9552-%E5%8A%9B%E6%89%A31-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 <strong>和为目标值</strong> <em>target</em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>        <span class="hljs-comment">// 首先构建一个哈希表，用来存放数组的元素值以及索引值</span><br>        <span class="hljs-comment">// 其中 key 是数组中的元素值</span><br>        <span class="hljs-comment">// value 为数组中元素值的索引</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 接下来，遍历整个数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br><br>            <span class="hljs-comment">// 目标值为 target，将 target 与 nums[i] 求差</span><br>            <span class="hljs-comment">// 获取与 nums[i] 配对的那个数 anotherNum</span><br>            <span class="hljs-keyword">int</span> anotherNum = target - nums[i];<br><br>            <span class="hljs-comment">// 判断哈希表中是否存在那个与 nums[i] 配对的数 anotherNum</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(anotherNum)) &#123;<br><br>                <span class="hljs-comment">// 由于哈希表中所有 key 都是来自于数组中，</span><br>                <span class="hljs-comment">// 所以，如果发现哈希表存在那个与 nums[i] 配对的数 anotherNum</span><br>                <span class="hljs-comment">// 也就说明数组中存在一个数，可以和 nums[i] 相加为 target</span><br>                <span class="hljs-comment">// 此时， anotherNum 这个 key 对应的 value 为这个数在数组中的索引</span><br>                <span class="hljs-comment">// 所以，返回 map.get(anotherNum) 和 i 就是这两个值的下标</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;map.get(anotherNum), i&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 如果发现哈希表中目前不存在那个与 nums[i] 配对的数 anotherNum</span><br>               <span class="hljs-comment">// 那么就把此时观察的数 nums[i] 和它的索引存放到哈希表中</span><br>               <span class="hljs-comment">// 等待后面的数能和它配对为 target</span><br>               map.put(nums[i], i);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 如果遍历完整个数组都找不到和为 target 的两个数，返回 0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法51[力扣51]-N皇后</title>
    <link href="/2021/09/20/%E7%AE%97%E6%B3%9551-%E5%8A%9B%E6%89%A351-N%E7%9A%87%E5%90%8E/"/>
    <url>/2021/09/20/%E7%AE%97%E6%B3%9551-%E5%8A%9B%E6%89%A351-N%E7%9A%87%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],<br>[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">// 保存所有符合要求的解</span><br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br><br>      <span class="hljs-comment">// attack 用来表示皇后的攻击范围</span><br>      <span class="hljs-keyword">int</span>[][] attack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>      <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>      <span class="hljs-keyword">char</span>[][] queen = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br><br>      <span class="hljs-comment">// 初始化二维数组 queen 中所有的元素为 &#x27;.&#x27;</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>[] c : queen) &#123;<br>         Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 初始化二维数组 attack 中所有的元素为 0</span><br>      <span class="hljs-comment">// 0 代表没有皇后能攻击得到</span><br>      <span class="hljs-comment">// 1 代表出于任意一个皇后的攻击范围内</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] c : attack) &#123;<br>          Arrays.fill(c, <span class="hljs-number">0</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 从棋盘的第 0 行第 0 列处理 n 皇后的情况</span><br>      backtrack(<span class="hljs-number">0</span>,n,queen,attack);<br><br>      <span class="hljs-comment">// 最后，返回所有符合要求的解</span><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 很显然，每一行只能放置一个皇后，所以我们每一行每一行的来放置皇后</span><br>    <span class="hljs-comment">// k 表示当前处理的行</span><br>    <span class="hljs-comment">// n 表示需要放置多少个皇后，同时也代表棋盘的大小为 n * n</span><br>    <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>    <span class="hljs-comment">// attack 用来表示皇后的攻击范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k ,<span class="hljs-keyword">int</span> n , <span class="hljs-keyword">char</span>[][] queen,<span class="hljs-keyword">int</span>[][] attack)</span></span>&#123;<br><br>        <span class="hljs-comment">// 如果发现在棋盘的最后一行放置好了皇后，那么就说明找到了一组符合要求的解</span><br>        <span class="hljs-keyword">if</span>(k == n)&#123;<br>            <span class="hljs-comment">// 由于 queen 为二维字符数组，所以需要转换为字符串数组</span><br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 遍历二维数组 queen</span><br>            <span class="hljs-comment">// 取出 queen 的每一行字符数组 c</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] c : queen) &#123;<br>                <span class="hljs-comment">// 把字符数组 c 中的所有字符转换为字符串的形式进行拼凑</span><br>                <span class="hljs-comment">// 比如 [&#x27;.&#x27;,&#x27;Q&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,]</span><br>                <span class="hljs-comment">// 转换为 &#x27;.Q..&#x27;</span><br>                <span class="hljs-comment">// 把这个字符串加入到 list 中</span><br>                list.add(String.copyValueOf(c));<br>            &#125;<br><br>            <span class="hljs-comment">// list 即为一组符合要求的解，把它加入到结果数组中</span><br>            res.add(list);<br>            <span class="hljs-comment">// 由于遍历完了所有的行，无需再遍历下去，所以返回</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 每一行只能放置一个皇后</span><br>        <span class="hljs-comment">// 并且每一列也只能放置一个皇后</span><br>        <span class="hljs-comment">// 所以在 k 行中，从 0 列到 n - 1 列，判断皇后应该放置到哪个位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>            <span class="hljs-comment">// 如果发现 attack[k][i] == 0</span><br>            <span class="hljs-comment">// 说明这个位置不在任何一个皇后的攻击范围内</span><br>            <span class="hljs-comment">// 所以可以考虑放置皇后</span><br>            <span class="hljs-keyword">if</span>(attack[k][i] == <span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-comment">// 如果在 ( k , i ) 位置放置了皇后，那么就需要考虑在 k + 1 行应该怎么放置其它的皇后了</span><br>                <span class="hljs-comment">// 由于有可能在( k , i )  位置放置了皇后之后，在后续的其它行会无法再放置其它的皇后</span><br>                <span class="hljs-comment">// 那么就需要回到 ( k , i )  的状态，考虑能不能在 ( k , i + 1 )的位置放置</span><br>                <span class="hljs-comment">// 为了能够回到 ( k , i )  的状态，所以需要先记录此时的 attack</span><br>                <span class="hljs-comment">// 使用一个临时的二维数组，深度拷贝 attack</span><br>                <span class="hljs-comment">// 如果不使用深度拷贝，而是直接使用 int[][] temp = c</span><br>                <span class="hljs-comment">// 会导致 attack 发生改变是 temp 也会发生改变</span><br>                <span class="hljs-comment">// 这样也就无法保存之前的状态了</span><br>                <span class="hljs-keyword">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br><br>                <span class="hljs-comment">// 通过两个 for 循环，把 attack 中的所有元素深度拷贝到 temp</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span> ; l &lt; n ; l++)&#123;<br>                    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span> ; m &lt; n ; m++)&#123;<br>                        temp[l][m] = attack[l][m];<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// queen 用来记录皇后的位置</span><br>                <span class="hljs-comment">// 那么 ( k , i )  的位置 queen[k][i] = &#x27;Q&#x27;</span><br>                queen[k][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>                <span class="hljs-comment">// 由于新放置了一个皇后，所以攻击范围又更多了</span><br>                <span class="hljs-comment">// 所以需要更新 attack 数组</span><br>                <span class="hljs-comment">// 新放置皇后的坐标为 ( k , i ) ，同样的需要更新它的八个方向</span><br>                checkQueenAttack(k,i,attack);<br><br>                <span class="hljs-comment">// 如果在 ( k , i )  位置放置了皇后，那么就需要考虑在 k + 1 行应该怎么放置其它的皇后</span><br>                <span class="hljs-comment">// 递归的调用 backtrack 在 k + 1 行放置皇后</span><br>                backtrack(k + <span class="hljs-number">1</span>,n,queen,attack);<br><br>                <span class="hljs-comment">// 递归结束后，拿走皇后，恢复 attack 的状态，考虑能不能在 ( k ,i + 1 )的位置放置</span><br>                attack = temp;<br><br>                <span class="hljs-comment">// 恢复 queen 的状态，说明此时皇后不放置在( k , i )  位置</span><br>                queen[k][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// 坐标 ( x , y) 为皇后所处的位置</span><br>    <span class="hljs-comment">// 更新 attack</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkQueenAttack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x ,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span>[][] attack)</span></span>&#123;<br><br>        <span class="hljs-comment">// 对于每一个坐标 (x,y) 来说，都有上、下、左、右、左上、左下、右上、右下 八个方向</span><br>        <span class="hljs-comment">//【左上】的坐标为 (x - 1, y - 1)</span><br>        <span class="hljs-comment">//【上】的坐标为 (x - 1, y )</span><br>        <span class="hljs-comment">//【右上】的坐标为 (x + 1, y + 1)</span><br>        <span class="hljs-comment">//【左】的坐标为 (x, y + 1)</span><br>        <span class="hljs-comment">//【右】的坐标为 (x , y - 1)</span><br>        <span class="hljs-comment">//【左下】的坐标为 (x + 1, y - 1)</span><br>        <span class="hljs-comment">//【下】的坐标为 (x + 1, y)</span><br>        <span class="hljs-comment">//【右下】的坐标为 (x + 1, y + 1)</span><br>        <span class="hljs-comment">// 通过两个一维数组可以表示这八个方向</span><br>        <span class="hljs-comment">// dx 表示 x 的方向</span><br>        <span class="hljs-keyword">int</span> dx[] = &#123; -<span class="hljs-number">1</span> , -<span class="hljs-number">1</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span>  ,  <span class="hljs-number">0</span> ,  <span class="hljs-number">1</span>  , <span class="hljs-number">1</span> , <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-comment">// dy 表示 y 的方向</span><br>        <span class="hljs-keyword">int</span> dy[] = &#123; -<span class="hljs-number">1</span> , <span class="hljs-number">0</span>  , <span class="hljs-number">1</span> , -<span class="hljs-number">1</span> ,  <span class="hljs-number">1</span> ,  -<span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span> &#125;;<br><br>        <span class="hljs-comment">// 皇后所处的坐标肯定是皇后能攻击的位置，设置为 1</span><br>        attack[x][y] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 以坐标 ( x , y) 为中心，去更新它八个方向的坐标</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">8</span>; j++)&#123;<br>            <span class="hljs-comment">// 由内向外的进行更新</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; attack.length ; i++)&#123;<br>                <span class="hljs-comment">// 新的位置的坐标行为 x + i * dx[j]</span><br>                <span class="hljs-keyword">int</span> nx = x + i * dx[j];<br>                <span class="hljs-comment">// 新的位置的坐标列为 y + i * dy[j]</span><br>                <span class="hljs-keyword">int</span> ny = y + i * dy[j];<br><br>                <span class="hljs-comment">// 如果新位置的坐标在 n * n 的棋盘范围内</span><br>                <span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; attack.length &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; attack.length)&#123;<br>                    <span class="hljs-comment">// 那么这些位置就是在坐标为 （x，y）的皇后的攻击范围内，更新为 1</span><br>                    attack[nx][ny] = <span class="hljs-number">1</span>;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法50[力扣55]-跳跃游戏</title>
    <link href="/2021/09/15/%E7%AE%97%E6%B3%9550-%E5%8A%9B%E6%89%A355-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/09/15/%E7%AE%97%E6%B3%9550-%E5%8A%9B%E6%89%A355-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置数组，保存每个位置如果在当前位置出发，一次性可以到达的最远位置</span><br>        <span class="hljs-comment">// 比如 nums 为 [ 2 , 4 , 5 , 3 , 1 , 0 , 6]</span><br>        <span class="hljs-comment">// 那么对于 2 来说，可以跳到最远的位置是 5 那个位置，即索引为 2 的那个位置</span><br>        <span class="hljs-comment">// 对于 4 来说，可以跳到最远的位置是 0 那个位置，即索引为 5 的那个位置</span><br>        <span class="hljs-comment">// 对于 5 来说，可以跳到最远的位置超过了数组的范围</span><br>        <span class="hljs-keyword">int</span>[] jump = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 初始化 jump</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-comment">// jump[i] 就是当前的索引值 i 加上该位置可以跳跃的最大长度 nums[i]</span><br>            jump[i] = i + nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 从数组下标为 0 的位置开始起跳，索引为 0</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置变量 maxJump，用来记录可以到达的最远位置</span><br>        <span class="hljs-comment">// 从数组下标为 0 的位置开始起跳，此时记录的最远距离为 jump[0]</span><br>        <span class="hljs-keyword">int</span> maxJump = jump[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 开始起跳</span><br>        <span class="hljs-comment">// 直到 index 到达数组尾部，index &gt;= nums.length</span><br>        <span class="hljs-comment">// 或者 index 超过 maxJump</span><br>        <span class="hljs-keyword">while</span>(index &lt; nums.length &amp;&amp; index &lt;= maxJump)&#123;<br><br>            <span class="hljs-comment">// 如果发现可以跳到的最远距离 maxJump 小于 jump[index]</span><br>            <span class="hljs-keyword">if</span>(maxJump &lt; jump[index])&#123;<br>                <span class="hljs-comment">// 那么需要更新 maxJump</span><br>                maxJump = jump[index];<br>            &#125;<br><br>            <span class="hljs-comment">// index 向前移动</span><br>            index++;<br>        &#125;<br><br>        <span class="hljs-comment">// 循环结束后，如果发现 index 的位置在数组 nums 的最后一个位置</span><br>        <span class="hljs-keyword">if</span>(index == nums.length)&#123;<br>            <span class="hljs-comment">// 说明可以到达最后一个下标</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 否则说明无法到达最后一个下标</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法49[力扣402]-移掉k位数字</title>
    <link href="/2021/09/15/%E7%AE%97%E6%B3%9549-%E5%8A%9B%E6%89%A3402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2021/09/15/%E7%AE%97%E6%B3%9549-%E5%8A%9B%E6%89%A3402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeKdigits</span><span class="hljs-params">(String num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 初始化栈，用来存储需要保留的数字</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-comment">// 初始化字符串，用来保留最后的结果</span><br>        StringBuilder result = <span class="hljs-keyword">new</span> StringBuilder();<br><br>        <span class="hljs-comment">// 从左到右遍历字符串 num</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; num.length();i++)&#123;<br><br>            <span class="hljs-comment">// 获取此时遍历的字符</span><br>            <span class="hljs-keyword">char</span> digit = num.charAt(i);<br><br>            <span class="hljs-comment">// 如果此时</span><br>            <span class="hljs-comment">// 1、栈不为空</span><br>            <span class="hljs-comment">// 2、栈顶元素大于此时遍历的字符</span><br>            <span class="hljs-comment">// 3、还没有删除足够多的数字，即 k &gt; 0</span><br>            <span class="hljs-comment">// 那么这个时候需要把栈顶元素弹出</span><br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; digit &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 把栈顶元素弹出</span><br>                stack.pop();<br>                <span class="hljs-comment">// 记录删除的个数减 1</span><br>                k--;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果发现此时遍历的字符为 0 并且栈为空</span><br>            <span class="hljs-comment">// 那么就不要把 0 放入到栈中，否则最终的结果会以 0 开头</span><br>            <span class="hljs-keyword">if</span>(digit == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; stack.isEmpty())&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 把符合要求的字符放入到栈中</span><br>            stack.push(digit);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历完所有的字符后，如果发现还没有删除足够多的元素，那么需要继续删除</span><br>        <span class="hljs-comment">// 什么数字会出现这种情况呢？</span><br>        <span class="hljs-comment">// 比如数字为 123456789 ，删除的数字 k 为 1</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; k &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 不断的弹出栈顶元素</span><br>            stack.pop();<br>            <span class="hljs-comment">// 直到 k 为 0 位置</span><br>            k--;<br>        &#125;<br><br>        <span class="hljs-comment">// 操作完毕之后，如果发现栈为空，按上面逻辑我们会返回字符 &quot;&quot; ，</span><br>        <span class="hljs-comment">// 但根据题目的示例 3，num = &quot;10&quot;， k = 2 时，从原数字移除所有的数字，剩余为空就是 0 </span><br>        <span class="hljs-comment">// 需要返回 &quot;0&quot;</span><br>        <span class="hljs-keyword">if</span> (stack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-comment">// 如果栈中还有元素</span><br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-comment">// 那么从栈顶到栈底把字符添加到 result 上</span><br>            result.append(stack.peek());<br>            <span class="hljs-comment">// 同时不断的弹出栈顶元素</span><br>            stack.pop();<br>        &#125;<br><br>        <span class="hljs-comment">// 由于 stack 中的栈底是数字的最高位，栈顶是最低位</span><br>        <span class="hljs-comment">// 所以此时 result 保存的顺序是最低位到最高位</span><br>        <span class="hljs-comment">// 需要执行一次翻转操作</span><br>        <span class="hljs-keyword">return</span> result.reverse().toString();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法48[力扣860]-柠檬水找零</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9548-%E5%8A%9B%E6%89%A3860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9548-%E5%8A%9B%E6%89%A3860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。</p><p>你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] bills)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 用来记录 5 元钞票的数量</span><br>        <span class="hljs-keyword">int</span> five = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 用来记录 10 元钞票的数量</span><br>        <span class="hljs-keyword">int</span> ten = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 顾客开始按顺序购买，并找零</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; bills.length ; i++)&#123;<br>            <span class="hljs-comment">// 1、如果发现是 5 元面额</span><br>            <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-comment">// 那么可以直接收钱，不需要找零</span><br>                <span class="hljs-comment">// 并且 5 元钞票的数量加 1</span><br>                five++;<br><br>                <span class="hljs-comment">// 2、如果发现是 10 元面额</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bills[i] == <span class="hljs-number">10</span>)&#123;<br><br>                <span class="hljs-comment">// 如果手中有 5 元钞票，则找零 5 元</span><br>                <span class="hljs-keyword">if</span>(five &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 5 元钞票的数量减 1</span><br>                    five--;<br>                    <span class="hljs-comment">// 10 元钞票的数量加 1</span><br>                    ten++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果手中没有 5 元钞票，说明找零失败</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 3、如果发现是 20 元面额</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 如果手中有 10 元 和 5 元钞票，则找零 1 张 10 元和 1 张 5 元的钞票</span><br>                <span class="hljs-keyword">if</span>(ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 5 元钞票的数量减 1</span><br>                    five--;<br>                    <span class="hljs-comment">// 10 元钞票的数量减 1</span><br>                    ten--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果手中只有 5 元的，并且数量超过或者等于 3 张</span><br>                    <span class="hljs-comment">// 那么找零 3 张 5 元的钞票</span><br>                    <span class="hljs-keyword">if</span>(five &gt;= <span class="hljs-number">3</span>)&#123;<br>                        <span class="hljs-comment">// 5 元钞票的数量减 3</span><br>                        five -= <span class="hljs-number">3</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">// 说明这个时候顾客付 20 元的时候</span><br>                        <span class="hljs-comment">// 1、手中没有 1 张 10 元的和 1 张 5 元的</span><br>                        <span class="hljs-comment">// 2、手中没有 3 张 5 元的</span><br>                        <span class="hljs-comment">// 说明找零失败</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有顾客都找零了，成功</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法47[力扣455]-分发饼干</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9547-%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9547-%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。<strong>如果</strong> <strong>s[j] &gt;= g[i]<strong>，我们可以将这个饼干</strong>j</strong> 分配给孩子<strong>i</strong>，这个孩子会得到满足。</p><p>你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] g, <span class="hljs-keyword">int</span>[] s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、将孩子们的胃口值按照从小到大的顺序排列</span><br>        <span class="hljs-comment">// 优先满足胃口小的孩子</span><br>        Arrays.sort(g);<br><br>        <span class="hljs-comment">// 2、将饼干按照从小到大的顺序排列</span><br>        Arrays.sort(s);<br><br>        <span class="hljs-comment">// child 代表 g 的下标，即表示有多少孩子的胃口得到满足</span><br>        <span class="hljs-keyword">int</span> child = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// child 代表 s 的下标，即表示目前有多少饼干被使用了</span><br>        <span class="hljs-keyword">int</span> cookie = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历所有的饼干</span><br>        <span class="hljs-comment">// 遍历过后，饼干只有两种状态</span><br>        <span class="hljs-comment">// 1、要么找到了需要这个饼干的孩子</span><br>        <span class="hljs-comment">// 2、要么剩下的孩子中，胃口值最低的孩子都大于这个饼干的值，那么这个饼干没人要</span><br>        <span class="hljs-keyword">while</span>(cookie &lt; s.length &amp;&amp; child &lt; g.length)&#123;<br><br>            <span class="hljs-comment">// 孩子的胃口得到了满足</span><br>            <span class="hljs-keyword">if</span>(s[cookie] &gt;= g[child])&#123;<br>                <span class="hljs-comment">// 得到满足的孩子数量加 1</span><br>                child++;<br>            &#125;<br><br>            <span class="hljs-comment">// 查看下一个饼干能否找到需要的孩子</span><br>            cookie++;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回孩子数量</span><br>        <span class="hljs-keyword">return</span> child;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法46[力扣416]-分割等和子集</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9546-%E5%8A%9B%E6%89%A3416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9546-%E5%8A%9B%E6%89%A3416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 使用 sum 来保存数组中全部元素的和</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历 nums 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.length ; i++)&#123;<br>            <span class="hljs-comment">// 把 nums 数组上的所有元素值累加到 sum 上</span><br>            sum += nums[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 如果发现 sum 为奇数，那么必然无法拆分为两个相等的整数</span><br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 所以无法将这个数组分割成两个子集，返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 获取数组中全部元素之后的一半</span><br>        <span class="hljs-comment">// 接下来需要在数组 nums 中寻找一些数字去拼凑为 target</span><br>        <span class="hljs-comment">// 如果能找到一些数字之和为 target，那么剩下的数字之和也是 target</span><br>        <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>        <span class="hljs-comment">// dp[0][0] 表示 nums 的前 0 个元素能否可以组成和为 0 的结果</span><br>        <span class="hljs-comment">// dp[2][6] 表示 nums 的前 2 个元素能否可以组成和为 6 的结果</span><br>        <span class="hljs-comment">// dp[n - 1][target ] 表示 nums 的前 n - 1 个元素能否可以组成和为 target 的结果</span><br>        <span class="hljs-comment">// i 的值从 0 到 n - 1</span><br>        <span class="hljs-comment">// j 的值从 0 到 target</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][target + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 先初始化  dp[0][nums[0]]</span><br>        <span class="hljs-comment">// 如果 nums 的第 0 个元素 nums[0] 小于 target</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt;= target) &#123;<br>            <span class="hljs-comment">// 那么 nums 的前 0 个元素能否可以组成和为 nums[0] 的结果是 true</span><br>            <span class="hljs-comment">// 因为 nums 的前 0 个元素就是 nums[0]</span><br>            dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 接下来开始往 dp 数组中填充结果</span><br>        <span class="hljs-comment">// i 的值从 1 到 n - 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// j 的值从 0 到 target</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;<br>                <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>                <span class="hljs-comment">// dp[i - 1][j] 表示 nums 的前 i - 1 个元素能否可以组成和为 j 的结果</span><br>                <span class="hljs-comment">// 对于 dp[i][j] 来说，如果 dp[i - 1][j] 为 true，那么 dp[i][j] 必然也为 true</span><br>                <span class="hljs-comment">// 所以，先初始化 dp[i][j] 的值为 dp[i - 1][j] 的值</span><br>                <span class="hljs-comment">// 再通过后面的代码修改 dp[i][j] 中还为 false 的值 </span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><br>                <span class="hljs-comment">// 如果此时 nums[i] 恰巧为 j</span><br>                <span class="hljs-comment">// 那么对于 dp[i][j] 来说，nums 的前 i 个元素可以组成和为 j 的结果</span><br>                <span class="hljs-keyword">if</span> (nums[i] == j) &#123;<br>                    <span class="hljs-comment">// 所以 dp[i][j] 为 true</span><br>                    dp[i][j] = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-comment">// 同时继续</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果发现 nums[i] 小于 j</span><br>                <span class="hljs-keyword">if</span> (nums[i] &lt; j) &#123;<br>                    <span class="hljs-comment">// dp[i][j] 表示 nums 的前 i 个元素能否可以组成和为 j 的结果</span><br>                    <span class="hljs-comment">// dp[i - 1][j] 表示 nums 的前 i - 1 个元素能否可以组成和为 j 的结果</span><br>                    <span class="hljs-comment">// dp[i - 1][j - nums[i]] 表示 nums 的前 i - 1 个元素能否可以组成和为 j - nums[i] 的结果</span><br>                    <span class="hljs-comment">// 那么 dp[i][j] 的结果要为 true</span><br>                    <span class="hljs-comment">// 1、nums 的前 i - 1 个元素可以组成和为 j </span><br>                    <span class="hljs-comment">// 2、nums 的前 i - 1 个元素可以组成和为 j - nums[i]</span><br>                    <span class="hljs-comment">// 对于 1 来说，不用使用 nums[i] 就组成了 j</span><br>                    <span class="hljs-comment">// 对于 2 来说，前 i - 1 个元素可以组成和为 j - nums[i]，那么加上此时的值 nums[i]，也组成了 j</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i]];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[n - 1][target ] 表示 nums 的前 n - 1 个元素能否可以组成和为 target 的结果</span><br>        <span class="hljs-comment">// 返回这个结果</span><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][target];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法45[力扣279]-完全平方数</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9545-%E5%8A%9B%E6%89%A3279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9545-%E5%8A%9B%E6%89%A3279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 <strong>最少数量</strong></p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 设置一个数组，用来存储小于 n 的那些完全平方数</span><br>        List&lt;Integer&gt; square = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 通过一个下标来计算</span><br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 直到 idx * idx 超过了 n 为止</span><br>        <span class="hljs-keyword">while</span> (idx * idx &lt;= n) &#123;<br>            <span class="hljs-comment">// square 存储小于 n 的那些完全平方数</span><br>            square.add(idx * idx);<br><br>            <span class="hljs-comment">// idx 累加</span><br>            idx++;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[0] 表示数字 0  需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// dp[1] 表示数字 0  需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// dp[i] 表示数字 i  需要完全平方数的最少数量</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">1</span> ];<br><br>        <span class="hljs-comment">// 先让 dp 初始化为 -1，代表 dp[i] 还没有计算</span><br>        Arrays.fill(dp,-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// dp[0] 表示数字 0  需要完全平方数的最少数量</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 开始填充 dp[]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ;i++)&#123;<br><br>            <span class="hljs-comment">// 在每次填充的过程中，都去遍历 square 数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ;j &lt; square.size();j++)&#123;<br>                <span class="hljs-comment">// 如果发现此时 square 的元素值大于了 i</span><br>                <span class="hljs-comment">// 那么 square 后面的那些元素没有必要参与进来计算 i 了</span><br>                <span class="hljs-comment">// 直接退出当前的 j 的循环判断，让 i++</span><br>                <span class="hljs-keyword">if</span>(square.get(j) &gt; i)&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 否则，如果 dp[i] 还没有找到数字 i 需要完全平方数的最少数量</span><br>                <span class="hljs-comment">// 或者此时计算的新值更小，那么更新 dp[i]</span><br>                <span class="hljs-keyword">if</span>(dp[i] == -<span class="hljs-number">1</span> || dp[i] &gt; dp[i-square.get(j)] + <span class="hljs-number">1</span>)&#123;<br><br>                    <span class="hljs-comment">// 更新 dp[i]</span><br>                    <span class="hljs-comment">// dp[i] 表示数字 i  需要完全平方数的最少数量</span><br>                    <span class="hljs-comment">// 这个时候 dp[i] 为获取数字为 square.get(j) 的那 1 个完全平方数</span><br>                    <span class="hljs-comment">// 加上获取数字为 i-square.get(j) 最少需要 dp[i-square.get(j)] 个数</span><br>                    dp[i] = dp[i-square.get(j)] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[n] 表示数字 n 需要完全平方数的最少数量</span><br>        <span class="hljs-comment">// 返回这个结果就行</span><br>        <span class="hljs-keyword">return</span> dp[n];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法44[力扣300]-最长递增子序列</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9544-%E5%8A%9B%E6%89%A3300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9544-%E5%8A%9B%E6%89%A3300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置数组 dp，用来存储 nums 中以每个元素结尾的最长递增序列的程度</span><br>        <span class="hljs-comment">// dp[0] 表示以 nums[0] 结尾的最长递增序列的长度</span><br>        <span class="hljs-comment">// dp[1] 表示以 nums[1] 结尾的最长递增序列的长度</span><br>        <span class="hljs-comment">// dp[i] 表示以 nums[i] 结尾的最长递增序列的长度</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 首先将数组 dp 里面的值都初始化为 1</span><br>        <span class="hljs-comment">// 1 表示以当前元素结尾的最长递增序列的长度为 1</span><br>        <span class="hljs-comment">// 即最长递增序列就是当前元素本身</span><br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个变量用来存储最长递增序列的结果</span><br>        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从 1 开始，直到 dp.length ，往 dp 里面填充结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; dp.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 对于 dp[i] 来说，在 nums 中从 0 到 i - 1 都是在 i 的前面的</span><br>            <span class="hljs-comment">// 比如 nums 为 [1,5,2,5,3,7,2]</span><br>            <span class="hljs-comment">// 此时 i 为 3，那么 1,5,2 这些数字都在索引位置为 3 的前面</span><br>            <span class="hljs-comment">// 从 0 遍历到 i - 1，就可以从这些数字中选出小于 i 的数字</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i ;j++)&#123;<br><br>                <span class="hljs-comment">// 索引      0  1  2  3  4  5  6</span><br>                <span class="hljs-comment">// nums 为 [ 1, 5, 2, 5, 3, 7, 2 ]</span><br>                <span class="hljs-comment">// 此时 i 为 3，那么 1,5,2 这些数字都在索引位置为 3 的前面</span><br>                <span class="hljs-comment">// 1、从这些数字中选出小于 nums[i] 的数字</span><br>                <span class="hljs-comment">// 2、小于 nums[i] 的那些数字是 1 , 2 ，在之前都已经计算过以 1 或者 2 结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 并且这个结果存放在 dp[j] 中</span><br>                <span class="hljs-comment">// 如果数字为 1，那么此时 j 为 0，dp[0] 存放了以 1  结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 如果数字为 2，那么此时 j 为 2，dp[2] 存放了以 2  结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 3、如果发现此时 dp[i] 小于了 dp[j] + 1</span><br>                <span class="hljs-comment">// 4、说明此时 dp[i] 中的值就不是以 nums[i] 结尾的最长递增序列的长度</span><br>                <span class="hljs-comment">// 需要更新 dp[i]</span><br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 4、更新 dp[i]</span><br>                    dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 在更新 dp[i] 的过程中，发现了一个更长的子序列</span><br>            <span class="hljs-keyword">if</span>(maxLength &lt; dp[i])&#123;<br>                <span class="hljs-comment">// 那么把更长的子序列的长度赋值给 maxLength</span><br>                maxLength = dp[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 maxLength 就行</span><br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法43[力扣322]-零钱兑换</title>
    <link href="/2021/09/14/%E7%AE%97%E6%B3%9543-%E5%8A%9B%E6%89%A3322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <url>/2021/09/14/%E7%AE%97%E6%B3%9543-%E5%8A%9B%E6%89%A3322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 初始化数组 dp，长度为 amount + 1，因为在 dp 数组中还会存储金额为 0 的情况</span><br>        <span class="hljs-comment">// dp[i] 表示想要凑齐 i 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[0] 表示想要凑齐 0 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[1] 表示想要凑齐 1 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// dp[14] 表示想要凑齐 14 元需要的最少硬币个数</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 首先将数组 dp 里面的值都初始化为 -1</span><br>        <span class="hljs-comment">// -1 表示当前的金额还没有找到需要的最少硬币个数</span><br>        Arrays.fill(dp, -<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 想要凑齐 0 元的最少硬币个数是 0 个</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 依次计算想要凑齐 1 元到 amount 的最少硬币个数是多少</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= amount ; i++)&#123;<br><br>            <span class="hljs-comment">// 对于每个金额 i 来说，coins 中的每个面值小于 i 的硬币都可以尝试去拼凑 i</span><br>            <span class="hljs-comment">// 比如 i = 8 ，coins 为 [1,2,5,7,10]</span><br>            <span class="hljs-comment">// 其中 1，2，5，7 都小于 8</span><br>            <span class="hljs-comment">// 1 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 2 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 5 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 7 可以尝试去拼凑 8</span><br>            <span class="hljs-comment">// 所以，设置一个变量 j ，遍历数组 coins</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; coins.length;j++)&#123;<br><br>                <span class="hljs-comment">// 1、如果当前的硬币面值 coins[j] 小于了 i，表示这枚硬币有可能可以拼凑到 i</span><br>                <span class="hljs-comment">// 2、那么 i - coins[j] 表示面值 coins[j] 的硬币想要拼凑 i 需要那些面值的硬币金额</span><br>                <span class="hljs-comment">// 3、而 dp[i-coins[j]] 表示想要凑齐 i - coins[j] 元需要的最少硬币个数</span><br>                <span class="hljs-comment">// 4、如果 dp[i-coins[j]] != -1 ，表示想要凑齐 i - coins[j] 元需要的最少硬币个数有结果</span><br>                <span class="hljs-keyword">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != -<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">// 这个时候，对于金额 i 来说</span><br>                    <span class="hljs-comment">// 1、如果它之前还没有找到凑齐 i 元需要的最少硬币个数</span><br>                    <span class="hljs-comment">// 2、如果此时计算的最少硬币个数比之前保存的结果 dp[i] 更小</span><br>                    <span class="hljs-comment">// 那么更新 dp[i]</span><br>                    <span class="hljs-keyword">if</span>(dp[i] == -<span class="hljs-number">1</span> || dp[i-coins[j]] + <span class="hljs-number">1</span> &lt; dp[i])&#123;<br>                        <span class="hljs-comment">// 更新 dp[i]</span><br>                        <span class="hljs-comment">// dp[i] 表示想要凑齐 i 元需要的最少硬币个数</span><br>                        <span class="hljs-comment">// 这个时候 dp[i] 为获取面值为 j 的那 1 个硬币</span><br>                        <span class="hljs-comment">// 加上获取面值为 i - coins[j] 最少需要 dp[i - coins[j]] 个硬币</span><br>                        dp[i] = dp[i - coins[j]] + <span class="hljs-number">1</span>;<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[amount] 表示想要凑齐 amount 元需要的最少硬币个数</span><br>        <span class="hljs-comment">// 返回这个结果就行</span><br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法42[力扣72]-编辑距离</title>
    <link href="/2021/09/13/%E7%AE%97%E6%B3%9542-%E5%8A%9B%E6%89%A372-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2021/09/13/%E7%AE%97%E6%B3%9542-%E5%8A%9B%E6%89%A372-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>1、插入一个字符</li><li>2、删除一个字符</li><li>3、替换一个字符</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 获取字符串 word1 的长度</span><br>        <span class="hljs-keyword">int</span> L1 = word1.length();<br><br>        <span class="hljs-comment">// 获取字符串 word2 的长度</span><br>        <span class="hljs-keyword">int</span> L2 = word2.length();<br><br>        <span class="hljs-comment">// 设置二维数组 dp 用来储存 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][0] 表示 word1 的前 0 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][j] 表示 word1 的前 0 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][0] 表示 word1 的前 i 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[L1][L2] 表示 word1 的前 L1 个字符转换为 word2 的前 L2 个字符最少操作数</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[L1 + <span class="hljs-number">1</span>][L2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// dp[i][0] 表示 word1 的前 i 个字符转换为 word2 的前 0 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[i][0] 相当于给二维数组 dp 的第一列进行赋值操作</span><br>        <span class="hljs-comment">// 只需要每次执行删除操作，就可以把 word1 的字符删除到 0 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;= L1 ; i++)&#123;<br>            <span class="hljs-comment">// dp[1][0] 表示需要删除 1 次才能删除到 0 个字符</span><br>            <span class="hljs-comment">// dp[2][0] 表示需要删除 2 次才能删除到 2 个字符</span><br>            <span class="hljs-comment">// dp[i][0] 表示需要删除 i 次才能删除到 2 个字符</span><br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[0][j] 表示 word1 的前 0 个字符转换为 word2 的前 j 个字符最少操作数</span><br>        <span class="hljs-comment">// dp[0][j] 相当于给二维数组 dp 的第一行进行赋值操作</span><br>        <span class="hljs-comment">// 只需要每次执行插入操作，就可以把 word1 的字符转行为 j 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ;j &lt;= L2 ; j++)&#123;<br>            <span class="hljs-comment">// dp[0][1] 表示需要插入 1 次才能得到 1 个字符</span><br>            <span class="hljs-comment">// dp[0][2] 表示需要插入 2 次才能得到 2 个字符</span><br>            <span class="hljs-comment">// dp[0][j] 表示需要插入 j 次才能得到 j 个字符</span><br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 通过两个 for 循环，设置二维数组 dp 中的所有元素的值</span><br>        <span class="hljs-comment">// i 从 word1 的第 1 个字符一直到 L1 个字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= L1 ; i++)&#123;<br><br>            <span class="hljs-comment">// j 从 word2 的第 1 个字符一直到 L2 个字符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt;= L2 ; j++)&#123;<br><br>                <span class="hljs-comment">// 二维数组 dp 的下标是从 (0,0) 开始的</span><br>                <span class="hljs-comment">// 所以 dp[i][j] 表示的是 word1 中前 i 个字符即位置为 i - 1 的字符</span><br>                <span class="hljs-comment">// 转换为 word2 中前 j 个字符即位置为 j - 1 的字符所需要的最少操作数</span><br>                <span class="hljs-comment">// 如果此时 word1 中第 i - 1 个位置的字符（即当前遍历 i 时的字符）</span><br>                <span class="hljs-comment">// 与 word2 中第 j - 1 个位置的字符【相等】（即当前遍历 j 时的字符）</span><br>                <span class="hljs-comment">// 说明 word1 的前 i - 1 个字符转换为 word2 中前 j - 1 个字符成功后，</span><br>                <span class="hljs-comment">// word1 的前 i 个字符也就成功转换为 word2 的前 j 个字符了</span><br>                <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br><br>                    <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字符转换为 word2 的前 j 个字符最少操作数</span><br>                    <span class="hljs-comment">// dp[i - 1][j - 1] 表示 word1 的前 i - 1 个字符转换为 word2 的前 j -1 个字符最少操作数</span><br>                    <span class="hljs-comment">// 比如 word1 为 abcd，word2 为 efgd</span><br>                    <span class="hljs-comment">// 此时 i = 4，j = 4</span><br>                    <span class="hljs-comment">// 由于 word1.charAt(4 - 1) = d</span><br>                    <span class="hljs-comment">// word2.charAt(4 - 1) = d</span><br>                    <span class="hljs-comment">// 所以如果知道了 abc 转换为 efg 的最少操作数，那么结果也就出来了</span><br>                    <span class="hljs-comment">// d --&gt; d 不需要执行任何操作</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><br>                    <span class="hljs-comment">// 否则，说明 word1 中第 i - 1 个位置的字符（即当前遍历 i 时的字符）</span><br>                    <span class="hljs-comment">// 与 word2 中第 j - 1 个位置的字符【不相等】（即当前遍历 j 时的字符）</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 那么 dp[i][j]  可以从以下三种状态转换过来</span><br>                    <span class="hljs-comment">// 1、word1(L1-1) ——&gt; word2(L2-1)</span><br>                    <span class="hljs-comment">// 2、word1(L1-1) ——&gt; word2(L2)</span><br>                    <span class="hljs-comment">// 3、word1(L1) ——&gt; word2(L2-1)</span><br>                    <span class="hljs-comment">// word1(L1-1) ——&gt; word2(L2-1) 的最少操作数是 dp[i - 1][j - 1]</span><br>                    <span class="hljs-comment">// word1(L1-1) ——&gt; word2(L2) 的最少操作数是 dp[i - 1][j]</span><br>                    <span class="hljs-comment">// word1(L1) ——&gt; word2(L2-1) 的最少操作数是 dp[i][j - 1])</span><br>                    <span class="hljs-comment">// 选这三种状态的较小值后，</span><br>                    <span class="hljs-comment">// 1、如果是 word1(L1-1) ——&gt; word2(L2-1) 过来的，再执行 1 次替换操作</span><br>                    <span class="hljs-comment">// 2、如果是 word1(L1-1) ——&gt; word2(L2)   过来的，再执行 1 次删除操作</span><br>                    <span class="hljs-comment">// 3、如果是 word1(L1) ——&gt; word2(L2-1)   过来的，再执行 1 次插入操作</span><br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>],Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// dp[L1][L2] 表示 word1 的前 L1 个字符转换为 word2 的前 L2 个字符最少操作数</span><br>        <span class="hljs-comment">// 把这个结果进行返回</span><br>        <span class="hljs-keyword">return</span> dp[L1][L2];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法41[力扣64]-最小路径和</title>
    <link href="/2021/09/13/%E7%AE%97%E6%B3%9541-%E5%8A%9B%E6%89%A364-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/09/13/%E7%AE%97%E6%B3%9541-%E5%8A%9B%E6%89%A364-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br><br>        <span class="hljs-comment">// m 表示有多少行</span><br>        <span class="hljs-keyword">int</span> m = grid.length;<br><br>        <span class="hljs-comment">// n 表示每一行有多少个元素，即 n 表示有多少列</span><br>        <span class="hljs-keyword">int</span> n = grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">// 设置二维数组 dp 用来储存每个位置的最优解</span><br>        <span class="hljs-comment">// dp[0][0] 表示第 0 行第 0 列的最优解</span><br>        <span class="hljs-comment">// dp[0][i] 表示第 0 行第 i 列的最优解</span><br>        <span class="hljs-comment">// dp[j][0] 表示第 j 行第 0 列的最优解</span><br>        <span class="hljs-comment">// dp[i][j] 表示第 i 行第 j 列的最优解</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-comment">// 初始化 dp[0][0]，由于只有一个元素</span><br>        <span class="hljs-comment">// 所以 dp[0][0] 的最优解就是 grid[0][0] 这个元素</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// i 从 1 遍历到 n - 1 </span><br>        <span class="hljs-comment">// 获取第 0 行中第 i 列的最优解</span><br>        <span class="hljs-comment">// 比如 grid[0] 为 [1,3,2...]</span><br>        <span class="hljs-comment">// 由于每次只能向下或者向右移动一步，此时只能向右移动一步</span><br>        <span class="hljs-comment">// 那么 dp[0][i] 依次为 [1,4,6...]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n ; i++)&#123;<br>            <span class="hljs-comment">// 所以对于只有一行的情况，当前位置的最优解等于前一列的最优解加上该列的值</span><br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];<br>        &#125;<br><br>        <span class="hljs-comment">// i 从 1 遍历到 n - 1 </span><br>        <span class="hljs-comment">// 获取第 i 行中第 0 列的最优解</span><br>        <span class="hljs-comment">// 比如 grid 为 </span><br>        <span class="hljs-comment">// [1,1,2.......]</span><br>        <span class="hljs-comment">// [5,2,2.......]</span><br>        <span class="hljs-comment">// [2,3,4.......]</span><br>        <span class="hljs-comment">// [..,..,..,...]</span><br>        <span class="hljs-comment">// 由于每次只能向下或者向右移动一步，此时只能向下移动一步</span><br>        <span class="hljs-comment">// 那么 dp[i][0] 就是</span><br>        <span class="hljs-comment">// [1,..........]</span><br>        <span class="hljs-comment">// [6,..........]</span><br>        <span class="hljs-comment">// [7,..........]</span><br>        <span class="hljs-comment">// [............]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m ;i++)&#123;<br>            <span class="hljs-comment">// 所以对于只有一列的情况，当前位置的最优解等于前一行的最优解加上该行的值</span><br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 接下来从第 1 行到第 m - 1 行</span><br>        <span class="hljs-comment">// 从第 1 列到底 n - 1 列</span><br>        <span class="hljs-comment">// 填充二维数组 dp 里面的值</span><br>        <span class="hljs-comment">// dp[i][j] 表示第 i 行第 j 列的最优解</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>                <span class="hljs-comment">// 由于每次只能向下或者向右移动一步</span><br>                <span class="hljs-comment">// 位置 (i,j) 的最优解</span><br>                <span class="hljs-comment">// 等于当前位置上方位置(i-1,j)的最优解和左侧位置(i,j-1)的最优解的较小值</span><br>                <span class="hljs-comment">// 再加上当前位置的值</span><br>                dp[i][j] =  Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j] ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// dp[m-1][n-1] 表示第 m - 1 行第 n - 1 列的最优解</span><br>        <span class="hljs-comment">// 返回这个结果即可</span><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法40[力扣120]-三角形最小路径和</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9540-%E5%8A%9B%E6%89%A3120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9540-%E5%8A%9B%E6%89%A3120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标</strong> <strong>+ 1</strong> 的两个结点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;<br><br>        <span class="hljs-comment">// triangle 是个二维数组</span><br>        <span class="hljs-comment">// 先获取 triangle 的层数，即一维数组的个数</span><br>        <span class="hljs-keyword">int</span> n  = triangle.size();<br><br>        <span class="hljs-comment">// 设置一个一维数组，动态的更新每一层中当前节点对应的最短路径</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">1</span> ];<br><br>        <span class="hljs-comment">// 从最后一层开始计算节点的最短路径，直到顶层 0 层为止</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i-- )&#123;<br>            <span class="hljs-comment">// dp 中存储的是前 i 个位置存储的是到达第 i 层各个节点的最小路径和</span><br>            <span class="hljs-comment">// 从每一层的第 0 个位置开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt;= i ; j++)&#123;<br>                <span class="hljs-comment">// dp[j] 表示第 i 层中第 j 个节点的最小路径和</span><br>                dp[j] = triangle.get(i).get(j) + Math.min(dp[j],dp[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法39[力扣198]-打家劫舍</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9539-%E5%8A%9B%E6%89%A3198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9539-%E5%8A%9B%E6%89%A3198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一</strong>晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 先获取全部房间的总数</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 如果数组为空，表示没有房间，那么自然偷不到东西，直接返回 0</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 如果数组只有 1 个元素，表示只有 1 个房间，那么只能偷这个房间的东西，直接返回这个房间的金额</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 设置一个数组 value 用来存放前 n 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[0] 表示前 0 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[1] 表示前 1 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// value[i] 表示前 i 个房间可以偷取的最大金额</span><br>        <span class="hljs-keyword">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// value[0] 表示前 0 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// 0 个房间自然偷不到东西，所以存放结果为 0</span><br>        value[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// value[1] 表示前 1 个房间可以偷取的最大金额</span><br>        <span class="hljs-comment">// 只有 1 个房间，那么只能偷这个房间的东西，所以存放结果为这个房间的金额</span><br>        value[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 从 i = 2 直到 i = n，value 中存放的结果由前 i - 2 和 i - 1 共同决定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i++)&#123;<br><br>            <span class="hljs-comment">// 转移方程：value[i] 等于 value[ i - 1 ]  和 value[ i - 2 ] + num[ i - 1] 中的较大值</span><br>            value[i] = Math.max(value[i - <span class="hljs-number">1</span>] ,value[i - <span class="hljs-number">2</span>] + nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 value 的最后一个值</span><br>        <span class="hljs-keyword">return</span> value[n];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法38[力扣53]-最大子序数和</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9538-%E5%8A%9B%E6%89%A353-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E6%95%B0%E5%92%8C/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9538-%E5%8A%9B%E6%89%A353-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E6%95%B0%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 因为后面会使用到 nums 的长度</span><br>        <span class="hljs-comment">// 所以先进行判空操作</span><br>        <span class="hljs-comment">// 如果数组 nums 为空，返回 0</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br><br>        <span class="hljs-comment">// 设置一个数组 dp，长度和数组 nums 长度一致</span><br>        <span class="hljs-comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// dp[1] 表示以第 1 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// dp[i] 表示以第 i 个元素结尾的最大子数组的和</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>        <span class="hljs-comment">// dp[0] 表示以第 0 个元素结尾的最大子数组的和</span><br>        <span class="hljs-comment">// 初始化 dp[0]</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 变量 maxNum 表示数组 dp 中最大的那个值</span><br>        <span class="hljs-comment">// 即 maxNum 表示最大的连续字段和</span><br>        <span class="hljs-keyword">int</span> maxNum = dp[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 从 1 开始遍历数组 nums</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ;i++)&#123;<br><br>            <span class="hljs-comment">// 在遍历的过程中，去获取以第 i 个元素结尾的最大子数组的和</span><br>            <span class="hljs-comment">// 如果以 nums[i-1]结尾的最大字段和为正数</span><br>            <span class="hljs-comment">// 那么以第 i 个元素结尾的最大子数组的和就是自己本身加上以 nums[i-1]结尾的最大字段和</span><br>            <span class="hljs-keyword">if</span>(dp[i-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// dp[i-1] 是正数</span><br>                <span class="hljs-comment">// 所以 dp[i] 的值为 nums[i] 加上 dp[i-1]</span><br>                <span class="hljs-comment">// 因为 正数 + 变量 &gt; 变量</span><br>                <span class="hljs-comment">// dp[i -1] + nums[i] &gt; nums[i]</span><br>                dp[i] = dp[i -<span class="hljs-number">1</span>] + nums[i];<br><br>                <span class="hljs-comment">// 否则 dp[i-1] 不是正数，为负数或者 0</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 那么 dp[i] 的值为 nums[i]</span><br>                <span class="hljs-comment">// 因为 负数 + 变量 &lt; 变量</span><br>                <span class="hljs-comment">// dp[i -1] + nums[i] &lt; nums[i]</span><br>                dp[i] = nums[i];<br>            &#125;<br><br>            <span class="hljs-comment">// 在更新 dp[i] 的过程中，更新 maxNum 的值</span><br>            <span class="hljs-comment">// 如果此时 dp[i] 的值大于了 maxNum</span><br>            <span class="hljs-keyword">if</span>(maxNum &lt; dp[i])&#123;<br>                <span class="hljs-comment">// 那么 maxNum 更新为 dp[i]</span><br>                maxNum = dp[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 maxNum</span><br>        <span class="hljs-keyword">return</span> maxNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法37[力扣70]-爬楼梯</title>
    <link href="/2021/09/07/%E7%AE%97%E6%B3%9537-%E5%8A%9B%E6%89%A370-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2021/09/07/%E7%AE%97%E6%B3%9537-%E5%8A%9B%E6%89%A370-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 使用数组 dp 存储每一级台阶的爬法数量</span><br>        <span class="hljs-comment">// 由于后面初始化 dp[1] 和 dp[2] </span><br>        <span class="hljs-comment">// 为了让当 n = 0 时不越界，保证 dp[1] 和 dp[2] 都有值</span><br>        <span class="hljs-comment">// 所以 dp 的长度为 n + 2</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ n + <span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 初始化 dp[1] 和 dp[2] </span><br>        <span class="hljs-comment">// 一级台阶只有一种爬法</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 二级台阶有两种爬法</span><br>        <span class="hljs-comment">// 一种爬法是先爬 1 个台阶，再爬 1 个台阶</span><br>        <span class="hljs-comment">// 一种爬法是爬 2 个台阶</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 从 3 开始循环至 n，计算 dp[3] 至 dp[n]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 第 i 级台阶的结果 dp[i] 等于第 i-1 和 i-2 的结果之和</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 n 级台阶的结果</span><br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法36[力扣450]-删除二叉搜索树中的节点</title>
    <link href="/2021/09/04/%E7%AE%97%E6%B3%9536-%E5%8A%9B%E6%89%A3450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2021/09/04/%E7%AE%97%E6%B3%9536-%E5%8A%9B%E6%89%A3450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>1、首先找到需要删除的节点；</p><p>2、如果找到了，删除它。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、如果 root 为空，那么直接返回空</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果 root 的节点值等于需要删除的值，那么需要根据以下几种情况进行处理</span><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br><br>            <span class="hljs-comment">// 情况 1：当前节点的左子树为空，那么当前节点 root 由 root 的右子树占位就行</span><br>            <span class="hljs-comment">// 比如 key 为 8</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     7</span><br>            <span class="hljs-comment">//           \</span><br>            <span class="hljs-comment">//            8</span><br>            <span class="hljs-comment">// 直接将以 8 作为根节点的二叉树挪到 7 的位置</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     8</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br><br>            <span class="hljs-comment">// 情况 2：当前节点的右子树为空，那么当前节点 root 由 root 的左子树占位就行</span><br>            <span class="hljs-comment">// 比如 key 为 2</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    2     7</span><br>            <span class="hljs-comment">//   /        </span><br>            <span class="hljs-comment">//  1          </span><br>            <span class="hljs-comment">// 直接将以 1 作为根节点的二叉树挪到 2 的位置</span><br>            <span class="hljs-comment">//       6</span><br>            <span class="hljs-comment">//     /   \</span><br>            <span class="hljs-comment">//    1     7</span><br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br><br>            <span class="hljs-comment">// 情况 3：被删除节点既有左子树，又有右子树</span><br>            <span class="hljs-comment">// 比如 key 为 7</span><br>            <span class="hljs-comment">//          5</span><br>            <span class="hljs-comment">//       /     \</span><br>            <span class="hljs-comment">//      2       6</span><br>            <span class="hljs-comment">//    /   \       \</span><br>            <span class="hljs-comment">//   1     4       7</span><br>            <span class="hljs-comment">//        /</span><br>            <span class="hljs-comment">//       3</span><br>            <span class="hljs-comment">// 需要找到右子树最小的值，或者左子树中最大的值</span><br>            <span class="hljs-comment">// 这里我们去找右子树最小的值，为 3</span><br>            TreeNode minNodeOfRight = findMinNode(root.right);<br><br>            <span class="hljs-comment">// 找到右子树最小的值之后，修改当前节点 root 的值为右子树最小的值</span><br>            root.val = minNodeOfRight.val;<br><br>            <span class="hljs-comment">// 同时，记得删除掉 root 的右子树最小的值之</span><br>            <span class="hljs-comment">// 删除操作就是以 root 作为根节点，key 为右子树最小的值进行删除</span><br>            root.right = deleteNode(root.right, minNodeOfRight.val);<br><br>          <span class="hljs-comment">// 3、如果 root 的节点值小于需要删除的值，那么就在 root 的右子树中去查找</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>            <span class="hljs-comment">// 在 root 的右子树中去查找并删除 key </span><br>            root.right = deleteNode(root.right, key);<br><br>          <span class="hljs-comment">// 4、如果 root 的节点值大于需要删除的值，那么就在 root 的左子树中去查找</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>            <span class="hljs-comment">// 在 root 的左子树中去查找并删除 key </span><br>            root.left = deleteNode(root.left, key);<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回需要已经删除了 key 的二叉树的根节点</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过 findMinNode ，可以找到二叉搜索树中最小的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">findMinNode</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 由于二叉搜索树，左子树所有元素的值都小于根节点的值</span><br>        <span class="hljs-comment">// 所以可以不断的查找，直到为叶子节点，那么就找到了</span><br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 不断的去查找当前节点的左子树</span><br>            node = node.left;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回当前二叉搜索树中最小的元素</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法35[力扣236]-二叉树的最近公共祖先</title>
    <link href="/2021/09/04/%E7%AE%97%E6%B3%9535-%E5%8A%9B%E6%89%A3236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2021/09/04/%E7%AE%97%E6%B3%9535-%E5%8A%9B%E6%89%A3236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><strong>最近公共祖先</strong>的定义为：“对于有根树 T 的两个节点 <strong>p</strong>、<strong>q</strong>，最近公共祖先表示为一个节点 x，满足 x 是 <strong>p</strong>、<strong>q</strong> 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、如果此时访问的节点 root 为 null，那么直接返回 null</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果此时访问的节点 root 为指定节点 p，那么返回 p 这个节点</span><br>        <span class="hljs-keyword">if</span>(root == p)  <span class="hljs-keyword">return</span> p;<br><br>        <span class="hljs-comment">// 3、如果此时访问的节点 root 为指定节点 q，那么返回 q 这个节点</span><br>        <span class="hljs-keyword">if</span>(root == q) <span class="hljs-keyword">return</span> q;<br><br>        <span class="hljs-comment">// 4、经过上面 1、2、3 的判断之后，root 这个节点必然不是 p、q、null 这三种情况的节点</span><br>        <span class="hljs-comment">// 接下来，去递归的判断当前节点 root 的左右子树是否包含 p 、q 这两个指定节点</span><br><br><br>        <span class="hljs-comment">// 5、递归的去查找 root 的左子树，判断是否包含p 、q 这两个指定节点</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中包含 p，那么 left 的值就是 p</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中包含 q，那么 left 的值就是 q</span><br>        <span class="hljs-comment">// 如果 root 的左子树节点和它的左子树所有节点中既不包含 p，也不包含 q，那么 left 的值就是 null</span><br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br><br><br>        <span class="hljs-comment">// 6、递归的去查找 root 的右子树，判断是否包含p 、q 这两个指定节点</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中包含 p，那么 right 的值就是 p</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中包含 q，那么 right 的值就是 q</span><br>        <span class="hljs-comment">// 如果 root 的右子树节点和它的右子树所有节点中既不包含 p，也不包含 q，那么 right 的值就是 null</span><br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br><br><br>        <span class="hljs-comment">// 7、判断完当前节点 root 、 root 的左子树 left、root 的右子树 right 的情况后</span><br>        <span class="hljs-comment">// 开始向父节点传递信息</span><br><br>        <span class="hljs-comment">// 8、如果 root 节点的左子树 left 和右子树 right 都没有找到指定节点 p、q</span><br>        <span class="hljs-comment">// 并且 root 自己本身也不是指定节点 p、q</span><br>        <span class="hljs-comment">// 那么它给父节点传递的信息就是以 root 为根节点的那颗二叉树没有指定节点 p、q </span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 null，告诉 root 的父节点，这里没找到指定节点 p、q</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 9、如果在 root 节点的左子树 left 中没有找到指定节点 p、q </span><br>        <span class="hljs-comment">// 那么以 root 为根节点的那颗二叉树能不能找到指定节点 p、q  完全取决于 right 了</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 right ，告诉 root 的父节点，能不能找到指定节点 p、q  完全取决于 right </span><br>            <span class="hljs-keyword">return</span> right;<br><br>        <span class="hljs-comment">// 10、如果在 root 节点的右子树 right 中没有找到指定节点 p、q </span><br>        <span class="hljs-comment">// 那么以 root 为根节点的那颗二叉树能不能找到指定节点 p、q  完全取决于 left 了</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 返回 left ，告诉 root 的父节点，能不能找到指定节点 p、q  完全取决于 left </span><br>            <span class="hljs-keyword">return</span> left;<br><br>        <span class="hljs-comment">// 11、此时，left != null 并且 right != null</span><br>        <span class="hljs-comment">// 这说明在以 root 节点为根节点的那棵二叉树中找到了指定节点 p ，也找到了指定节点 q </span><br>        <span class="hljs-comment">// 那么就告诉父节点，root 就是 p、q 的最近公共祖先</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-comment">// 返回 root ，告诉 root 的父节点，root 就是 p、q 的最近公共祖先</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法34[力扣114]-二叉树展开为链表</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9534-%E5%8A%9B%E6%89%A3114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9534-%E5%8A%9B%E6%89%A3114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>1、展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</p><p>2、展开后的单链表应该与二叉树<strong>先序遍历</strong>顺序相同。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        backtrack(root);<br>    &#125;<br><br>    <span class="hljs-comment">// 传入二叉树的节点，把它转换为链表的形式，返回二叉树的尾节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br><br>        <span class="hljs-comment">// 1、如果 node 为空，返回 null</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 2、如果 node 为叶子节点，返回 node</span><br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> node;<br><br>        <span class="hljs-comment">// 下面开始设置几个指针</span><br><br>        <span class="hljs-comment">// 3、left 为当前节点 node 的左子树</span><br>        TreeNode left = node.left;<br><br>        <span class="hljs-comment">// 4、right 为当前节点 node 的右子树</span><br>        TreeNode right = node.right;<br><br>        <span class="hljs-comment">// 5、leftTail 指向当前节点左子树 left 转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode leftTail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 6、rightTail 指向当前节点右子树 right 转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode rightTail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 7、tail 指向以当前节点 node 为根节点转换为链表之后的尾节点，一开始默认为 null</span><br>        TreeNode tail = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 8、先将 node 的左子树指针置空</span><br>        <span class="hljs-comment">// 将 node 的左子树转换为链表之后，node 的右指针指向那个链表</span><br>        node.left = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 9、如果当前节点存在左子树的时候，那么把左子树转换为链表的形式</span><br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 backtrack 函数递归的把当前节点的左子树转换为链表</span><br>            <span class="hljs-comment">// backtrack 函数指向完之后，left 已经是链表</span><br>            <span class="hljs-comment">// 根据第 5 点的代码，leftTail 指向左子树最后一个节点</span><br>            leftTail = backtrack(left);<br><br>            <span class="hljs-comment">// 此时，node 的左子树 left 已经是链表的形式</span><br>            <span class="hljs-comment">// 那么将当前节点 node 的 right 指针指向 left，完成了当前节点和左子树链表的拼接</span><br>            node.right = left;<br><br>            <span class="hljs-comment">// 根据第 7 ，tail 指向左子树最后一个节点</span><br>            tail = leftTail;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 10、如果当前节点存在右子树的时候，那么把左子树转换为链表的形式</span><br>        <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 backtrack 函数递归的把当前节点的右子树转换为链表</span><br>            <span class="hljs-comment">// backtrack 函数指向完之后，right 已经是链表</span><br>            <span class="hljs-comment">// 根据第 6 点的代码，rightTail 指向右子树最后一个节点</span><br>            rightTail = backtrack(right);<br><br>            <span class="hljs-comment">// 此时，node 的右子树 right 已经是链表的形式</span><br>            <span class="hljs-comment">// 如果当前节点 node 不存在左子树，那么 node.left = null</span><br>            <span class="hljs-comment">// 由于 node 的右指针就是 right，所以不需要执行其它操作</span><br>            <span class="hljs-comment">// 但如果存在左子树，就需要把 left 链表和 right 链表串联起来</span><br>            <span class="hljs-comment">// 也就是把 left 链表的尾节点和 right 的头节点拼接起来</span><br>            <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 将 leftTail 和 right 转换成的链表链接起来</span><br>                leftTail.right = right;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果存在右子树，那么根据第 7 点的代码，tail 指向右子树最后一个节点</span><br>            tail = rightTail;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回链表的尾节点位置继续去拼接其它的递归链表</span><br>        <span class="hljs-keyword">return</span> tail;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法33[力扣538]-把二叉搜索树转换为累加树</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9533-%E5%8A%9B%E6%89%A3538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9533-%E5%8A%9B%E6%89%A3538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">// 定义一个变量，用来记录已经访问的所有节点值的总和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、从根节点开始，修改二叉树上的每一个节点的值</span><br>        modify(root);<br><br>        <span class="hljs-comment">// 返回修改后的二叉树的根节点</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-comment">// 按照右根左的顺序，遍历二叉树上的每一个节点，将每个节点的值累加到 sum 上面</span><br>    <span class="hljs-comment">// 同时把 sum 累加到当前节点上</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(TreeNode node )</span></span>&#123;<br><br>        <span class="hljs-comment">// 如果当前节点为空，那么就不需要计算了</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-comment">// 2、去修改当前节点的右子树上面的节点</span><br>        <span class="hljs-comment">// 修改的过程中，会不断的累加当前节点右子树上所有的节点值之和</span><br>        modify(node.right);<br><br>        <span class="hljs-comment">// 3、把当前节点右子树上所有的节点值之和在加上当前节点的值更新到 sum 上</span><br>        sum += node.val;<br><br>        <span class="hljs-comment">// 4、 修改当前节点的值为 sum</span><br>        node.val = sum;<br><br>        <span class="hljs-comment">// 5、去修改当前节点的左子树上面的节点</span><br>        <span class="hljs-comment">// 修改的过程中，会不断的累加当前节点左子树上所有的节点值之和</span><br>        modify(node.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法32[力扣108]-将有序数组转换为二叉搜索树</title>
    <link href="/2021/09/02/%E7%AE%97%E6%B3%9532-%E5%8A%9B%E6%89%A3108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/09/02/%E7%AE%97%E6%B3%9532-%E5%8A%9B%E6%89%A3108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><h3 id="二、代码参考"><a href="#二、代码参考" class="headerlink" title="二、代码参考"></a>二、代码参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 作者：程序员吴师兄</span><br><span class="hljs-comment">// 网站：https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> toBST(nums,<span class="hljs-number">0</span>,nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 将升序排序数组 nums，从下标 begin 到 end 的部分元素转换为平衡二叉排序树</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">toBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span>&#123;<br><br>        <span class="hljs-comment">// 整个递归的终止条件是 begin 的位置超过了 end</span><br>        <span class="hljs-comment">// 比如对于排序数组 [ 7，8 ]，它的起始位置 begin 为 0，结束位置 end 为 1</span><br>        <span class="hljs-comment">// 所以 mid 为 （ 0 + 1 ）/ 2 = 0</span><br>        <span class="hljs-comment">// 这个时候根据 mid 的位置划分为两个子区域</span><br>        <span class="hljs-comment">// [begin , mid - 1] 和 [ mid + 1 , end ]</span><br>        <span class="hljs-comment">// 即 7 的左区域位置为 [ 0 ，-1]，这个区域的 begin 为 0 ，end 为 -1</span><br>        <span class="hljs-comment">// 所以返回 null，结束了递归</span><br>        <span class="hljs-comment">// 很直观的可以看到对于排序数组 [ 7，8 ]来说，在数组中没有小于 7 的元素</span><br>        <span class="hljs-keyword">if</span>(begin &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 获取从 begin 到 end 排序数组中中间元素的下标</span><br>        <span class="hljs-keyword">int</span> mid = (begin + end) / <span class="hljs-number">2</span> ;<br><br>        <span class="hljs-comment">// 获取以 mid 下标的元素</span><br>        <span class="hljs-comment">// 把这个元素作为转换后的二叉树根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br><br>        <span class="hljs-comment">// 递归的将 mid 左侧所有元素转换为平衡二叉排序树</span><br>        TreeNode left = toBST(nums,begin,mid - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归的将 mid 右侧所有元素转换为平衡二叉排序树</span><br>        TreeNode right = toBST(nums,mid + <span class="hljs-number">1</span>,end);<br><br>        <span class="hljs-comment">// 将 mid 左侧所有元素转换为平衡二叉排序树后作为 root 的左子树</span><br>        root.left = left;<br><br>        <span class="hljs-comment">// 将 mid 右侧所有元素转换为平衡二叉排序树后作为 root 的右子树</span><br>        root.right = right;<br><br>        <span class="hljs-comment">// 返回转换好的平衡二叉排序树</span><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法31[力扣113]-路径总和Ⅱ</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9531-%E5%8A%9B%E6%89%A3113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9531-%E5%8A%9B%E6%89%A3113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> targetSum) &#123;<br><br>        <span class="hljs-comment">// 构建一个 value，用来计算当前路径下节点的总和</span><br>        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 构建一个 path，用来记录满足条件的路径</span><br>        List&lt;List&lt;Integer&gt;&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个栈，用来保存当前路径下的节点</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 从根节点开始搜索</span><br>        search(root,value,targetSum,stack,path);<br><br>        <span class="hljs-comment">// 返回满足条件的路径</span><br>        <span class="hljs-keyword">return</span> path;<br><br>    &#125;<br><br>    <span class="hljs-comment">// node 为正在遍历的节点</span><br>    <span class="hljs-comment">// value 为栈中各个节点值的总和</span><br>    <span class="hljs-comment">// targetSum 为目标路径的和</span><br>    <span class="hljs-comment">// stack 存储该路径上的所有节点</span><br>    <span class="hljs-comment">// path 存储满足条件，即路径上的各个节点之和为 targetSum 的那些路径</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">int</span> value,<span class="hljs-keyword">int</span> targetSum ,Stack&lt;Integer&gt; stack,List&lt;List&lt;Integer&gt;&gt; path)</span></span>&#123;<br><br>            <span class="hljs-comment">// 如果节点为空，那么就不需要再访问下去了</span><br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 将当前访问节点的值累加到 value 上</span><br>            value += node.val;<br><br>            <span class="hljs-comment">// 把当前的节点值添加到栈中，栈中保存的就是从根节点到当前节点的路径</span><br>            stack.push(node.val);<br><br>            <span class="hljs-comment">// 如果当前节点的左子树为空</span><br>            <span class="hljs-comment">// 并且当前节点的右子树也为空</span><br>            <span class="hljs-comment">// 即当前节点为叶子节点</span><br>            <span class="hljs-comment">// 同时当前路径下的节点值之和 value 与目标值 targetSum 相等</span><br>            <span class="hljs-comment">// 说明找到了一条符合条件的路径</span><br>            <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span> &amp;&amp; value == targetSum)&#123;<br><br>                <span class="hljs-comment">// 把这条路径添加到 path 中</span><br>                path.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(stack));<br>            &#125;<br><br>            <span class="hljs-comment">// 继续递归的搜索当前节点 node 的左子树</span><br>            search(node.left,value,targetSum,stack,path);<br><br>            <span class="hljs-comment">// 继续递归的搜索当前节点 node 的右子树</span><br>            search(node.right,value,targetSum,stack,path);<br><br>            <span class="hljs-comment">// 搜索完当前节点的左右子树之后，当前节点已经完成了访问，需要返回到它的父节点</span><br>            <span class="hljs-comment">// 所以 value 减去当前节点的值</span><br>            value -= node.val;<br><br>            <span class="hljs-comment">// 栈也弹出当前的节点值</span><br>            stack.pop();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法30[力扣199]-二叉树的右视图</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9530-%E5%8A%9B%E6%89%A3199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9530-%E5%8A%9B%E6%89%A3199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树的 <strong>根节点</strong> root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置一个数组用来存储二叉树的右视图结果</span><br>        <span class="hljs-comment">// 题目要求存储的是节点的值，所以类型是 Integer</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个队列，用来保存二叉树每一层的节点</span><br>        Queue&lt;TreeNode&gt; que = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        <span class="hljs-comment">// 边界判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> list;<br><br>        <span class="hljs-comment">// 首先，把二叉树的根节点加入到队列中</span><br>        que.add(root);<br><br>        <span class="hljs-comment">// 观察队列是否为空</span><br>        <span class="hljs-keyword">while</span> (!que.isEmpty()) &#123;<br><br>            <span class="hljs-comment">// 1、获取队列的长度</span><br>            <span class="hljs-keyword">int</span> levelSize = que.size();<br><br>            <span class="hljs-comment">// 2、通过一个循环，获取队列中每个节点的左右子树，把这些左右子树节点也添加到队列中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) &#123;<br><br>                <span class="hljs-comment">// 3、弹出队列的队首元素</span><br>                TreeNode node = que.poll();<br><br>                <span class="hljs-comment">// 4、判断弹出的节点是否有左子树</span><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果有左子树，把它加入到队列中</span><br>                    que.add(node.left);<br>                &#125;<br><br>                <span class="hljs-comment">// 5、判断弹出的节点是否有右子树</span><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果有右子树，把它加入到队列中</span><br>                    que.add(node.right);<br>                &#125;<br><br>                <span class="hljs-comment">// 对于每一层的二叉树节点，我们是从左到右依次添加，所以末尾的节点的顺序是 levelSize - 1</span><br>                <span class="hljs-comment">// 6、这个末尾的节点就是这一层中最右侧的节点 </span><br>                <span class="hljs-keyword">if</span> (i == levelSize - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 把最右侧的节点值加入到结果中</span><br>                    list.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法29[力扣105]-根据前序与中序遍历序列构造二叉树</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9529-%E5%8A%9B%E6%89%A3105-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9529-%E5%8A%9B%E6%89%A3105-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 题目中说 preorder 和 inorder 均无重复元素</span><br>        <span class="hljs-comment">// 通过哈希表把中序遍历序列中的值和顺序建立映射关系</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 通过 for 循环，遍历完中序遍历序列中的所有元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>             <span class="hljs-comment">// 以中序序列中的元素值 inorder[i] 作为 key</span><br>             <span class="hljs-comment">// 以位置 i 作为 value</span><br>             <span class="hljs-comment">// 存放到哈希表中</span><br>             <span class="hljs-comment">// 比如中序遍历序列中的元素是 [   A  ,   D  ,   E  ,   F  ,   G  ,   H  ,   M  ,   Z  ]</span><br>             <span class="hljs-comment">// 那么这个哈希表就是以下的样子</span><br>             <span class="hljs-comment">// | 索引 | 位置  |</span><br>             <span class="hljs-comment">// | A | 0  |</span><br>             <span class="hljs-comment">// | D | 1  |</span><br>             <span class="hljs-comment">// | E | 2  | </span><br>             <span class="hljs-comment">// | F | 3  | </span><br>             <span class="hljs-comment">// | G | 4  | </span><br>             <span class="hljs-comment">// | H | 5  | </span><br>             <span class="hljs-comment">// | M | 6  | </span><br>             <span class="hljs-comment">// | Z | 7  |            </span><br>             map.put(inorder[i], i);<br>        &#125;<br><br>        <span class="hljs-comment">// 下面开始构建二叉树</span><br>        <span class="hljs-comment">// 把前序遍历序列中的第一个元素 preorder[0] 作为二叉树的根节点</span><br>        <span class="hljs-comment">// 因为任意二叉树的前序遍历序列中的第一个元素，一定是二叉树的根节点</span><br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br><br><br>        <span class="hljs-comment">// 继续遍历前序遍历序列中的其它元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; preorder.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 把当前遍历的元素构造为一个二叉树的节点</span><br>            TreeNode node = <span class="hljs-keyword">new</span> TreeNode(preorder[i]);<br><br>            <span class="hljs-comment">// 把构造的节点插入到以 root 为根节点的二叉树中</span><br>            insertNode(root,node,map);<br><br>        &#125;<br><br>        <span class="hljs-comment">// 当 preorder 中所有元素都构造并且插入完毕之后</span><br>        <span class="hljs-comment">// 二叉树就完成了构建</span><br>        <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">// root : 二叉树的根节点</span><br>    <span class="hljs-comment">// node : 待插入的节点</span><br>    <span class="hljs-comment">// map : 节点值和中序遍历序列位置的映射</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(TreeNode root,TreeNode node,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;<br><br>            <span class="hljs-comment">// 当 root 和 node 指向的节点相同时，跳出循环</span><br>            <span class="hljs-keyword">while</span>(root != node)&#123;<br><br>                <span class="hljs-comment">// 如果 node 的中序遍历序列位置小于 root 的中序遍历序列位置</span><br>                <span class="hljs-comment">// 说明 node 应该在 root 的左子树中</span><br>                <span class="hljs-keyword">if</span>(map.get(node.val) &lt; map.get(root.val))&#123;<br><br>                    <span class="hljs-comment">// 如果此时 root 没有左子树</span><br>                    <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>                        <span class="hljs-comment">// 那么就把 node 设置为 root 的左子树</span><br>                        root.left = node;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 1、如果之前 root 没有左子树，那么通过上面的代码，就设置好了 root 的左子树</span><br>                    <span class="hljs-comment">// 也就是说 node 是 root 的一个叶子节点，完成了插入操作</span><br>                    <span class="hljs-comment">// 把 root 指向 root.left 后，root 为 node，跳出了循环</span><br><br>                    <span class="hljs-comment">// 2、如果之前 root 已经有左子树，那么就不能直接把 node 插入到 root 的左子树上</span><br>                    <span class="hljs-comment">// 需要判断应该把 node 插入到 root 左子树上的孩子节点的那个位置上</span><br>                    <span class="hljs-comment">// 比如现在的 root 是这个样子，node 为 A</span><br>                    <span class="hljs-comment">//        G</span><br>                    <span class="hljs-comment">//       /</span><br>                    <span class="hljs-comment">//      D</span><br>                    <span class="hljs-comment">//     /  \</span><br>                    <span class="hljs-comment">//    ①   ②</span><br>                    <span class="hljs-comment">// root 已经有左子树 D 了，所以 node 应该考虑插入到 D 中的 ① 还是 ② 上面</span><br>                    <span class="hljs-comment">// 所以，把 root 指向 root.left ，继续遍历 root 的左子树的情况</span><br>                    root = root.left;<br><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 如果 node 的中序遍历序列位置大于 root 的中序遍历序列位置</span><br>                    <span class="hljs-comment">// 说明 node 应该在 root 的右子树中</span><br><br>                    <span class="hljs-comment">// 如果此时 root 没有右子树</span><br>                    <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>)&#123;<br>                        <span class="hljs-comment">// 那么就把 node 设置为 root 的右子树</span><br>                        root.right = node;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 把 root 指向 root.right ，继续遍历 root 的右子树的情况</span><br>                    root = root.right;<br><br>                &#125;<br><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法28一套模板解决二叉树的前序、中序、后序遍历</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9528%E4%B8%80%E5%A5%97%E6%A8%A1%E6%9D%BF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9528%E4%B8%80%E5%A5%97%E6%A8%A1%E6%9D%BF%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序、中序、后序</strong> 遍历。</p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树前序遍历的结果</span><br>        List&lt;Integer&gt; preorderReslut = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树中序遍历的结果</span><br>        List&lt;Integer&gt; inorderResult = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个数组用来保存二叉树后序遍历的结果</span><br>        List&lt;Integer&gt; postorderResult = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个栈，用来保存路径</span><br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 设置一个节点，一开始指向根节点</span><br>        TreeNode node = root;<br><br>        <span class="hljs-comment">// 设置三种状态，方便表示当前遍历当前节点的时候进行到哪一步了</span><br>        <span class="hljs-comment">// 每个节点都有 左、右、上 这三种状态</span><br>        <span class="hljs-comment">// 按照 左 --&gt; 右 --&gt; 上 的顺序观察每个节点</span><br><br>        <span class="hljs-comment">// 左代表该节点的左右孩子节点都没有遍历</span><br>        <span class="hljs-keyword">int</span> nodeLeft = <span class="hljs-number">100</span>;<br><br>        <span class="hljs-comment">// 右代表该节点的左孩子节点已经遍历，右孩子节点还没有遍历</span><br>        <span class="hljs-keyword">int</span> nodeRight = <span class="hljs-number">200</span>;<br><br>        <span class="hljs-comment">// 上代表左右孩子节点都已经遍历，需要返回到它的父节点</span><br>        <span class="hljs-keyword">int</span> nodeUp = <span class="hljs-number">300</span>;<br><br>        <span class="hljs-comment">// 每个节点的初始化状态都是从 左 开始</span><br>        <span class="hljs-keyword">int</span> nodeState = nodeLeft;<br><br><br>        <span class="hljs-comment">// 对二叉树进行遍历</span><br>        <span class="hljs-keyword">while</span>(node != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 位置 ① </span><br><br>            <span class="hljs-comment">// 如果当前节点的状态是【左】，说明该节点的左右孩子节点都没有遍历</span><br>            <span class="hljs-keyword">if</span>(nodeState == nodeLeft)&#123;<br>                <span class="hljs-comment">// 把当前节点加入到二叉树前序遍历的结果数组中</span><br>                preorderReslut.add(node.val);<br><br>                <span class="hljs-comment">// 如果当前节点有左子树</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br><br>                    <span class="hljs-comment">// 先把当前节点加入到栈中，用来记录节点移动的路径</span><br>                    stack.push(node);<br><br>                    <span class="hljs-comment">// 开始观察当前节点的左孩子节点，代码来到了位置 ① </span><br>                    node = node.left;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                    <span class="hljs-comment">// 如果当前节点没有左子树，切换当前节点的状态为【右】</span><br>                    <span class="hljs-comment">// 代码来到了位置 ① </span><br>                    nodeState = nodeRight;<br>                &#125;<br><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nodeState == nodeRight)&#123; <span class="hljs-comment">// 如果当前节点的状态是【右】，说明该节点的左孩子节点已经遍历，右孩子节点还没有遍历</span><br><br>                <span class="hljs-comment">// 把当前节点加入到二叉树中序遍历的结果数组中</span><br>                <span class="hljs-comment">// inorderResult.add(node.val);</span><br><br>                <span class="hljs-comment">// 如果当前节点有右子树</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br><br>                    <span class="hljs-comment">// 先把当前节点加入到栈中，用来记录节点移动的路径</span><br>                    stack.push(node);<br><br>                    <span class="hljs-comment">// 开始观察当前节点的右孩子节点</span><br>                    node = node.right;<br><br>                    <span class="hljs-comment">// 每个节点开始的状态都是【左】开始，所以需要重新设置一下节点的状态</span><br>                    nodeState = nodeLeft;<br><br>                    <span class="hljs-comment">// 执行完上面三行代码，代码来到了位置 ①     </span><br><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// 如果当前节点没有右子树，切换当前节点的状态为【上】</span><br>                    <span class="hljs-comment">// 代码来到了位置 ①</span><br>                    nodeState = nodeUp;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nodeState == nodeUp)&#123; <span class="hljs-comment">// 如果当前节点的状态是【上】，说明左右孩子节点都已经遍历，需要返回到它的父节点</span><br>                <span class="hljs-comment">// 把当前节点加入到二叉树后序遍历的结果数组中</span><br>                <span class="hljs-comment">//postorderResult.add(node.val);</span><br><br>                <span class="hljs-comment">// 需要返回到当前节点的父节点位置，通过栈顶元素来获取当前节点的父节点</span><br>                <span class="hljs-comment">// 首先构建一个空的节点</span><br>                TreeNode parent = <span class="hljs-keyword">null</span>;<br><br>                <span class="hljs-comment">// 如果栈中有元素</span><br>                <span class="hljs-keyword">if</span>(!stack.isEmpty())&#123;<br><br>                    <span class="hljs-comment">// 那么，栈顶元素就是当前节点的父节点</span><br>                    parent = stack.pop();<br><br>                    <span class="hljs-comment">// 判断一下父节点的左节点是否为当前节点</span><br>                    <span class="hljs-comment">// 比如这颗二叉树</span><br>                    <span class="hljs-comment">//           1</span><br>                    <span class="hljs-comment">//         /   \</span><br>                    <span class="hljs-comment">//        2     3</span><br>                    <span class="hljs-comment">//       / \     \</span><br>                    <span class="hljs-comment">//      4   5     6</span><br>                    <span class="hljs-comment">//  如果当前节点是 4 ，那么 4 的父节点是 2，2 的左孩子节点是 4，此时需要切换状态为【右】</span><br>                    <span class="hljs-comment">//  如果当前节点是 5 ，那么 5 的父节点是 2，2 的左孩子节点是 4，此时不需要切换状态</span><br><br>                    <span class="hljs-comment">// 如果父节点的左节点为当前节点</span><br>                    <span class="hljs-keyword">if</span>(parent.left == node)&#123;<br>                        <span class="hljs-comment">// 切换当前节点的状态为【右】</span><br>                        nodeState = nodeRight;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 开始观察当前节点的父节点</span><br>                <span class="hljs-comment">// 如果上述代码中栈中有元素，那么 parent 有值，代码来到了位置 ①</span><br>                <span class="hljs-comment">// 如果上述代码中栈中没有元素，那么 parent 没有值，会跳出循环</span><br>                node = parent;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 根据题目要求，返回二叉树前序、中序、后序遍历的结果</span><br>        <span class="hljs-keyword">return</span> preorderReslut;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法27[力扣102]-二叉树的层序遍历</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9527-%E5%8A%9B%E6%89%A3102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9527-%E5%8A%9B%E6%89%A3102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 设置 res 用来保存输出结果</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 边界情况处理</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-comment">// 设置一个队列，用来存储二叉树中的元素</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 队列添加二叉树的根节点</span><br>        queue.add(root);<br><br>        <span class="hljs-comment">// 遍历队列，直到队列为空，说明访问了二叉树中所有的节点</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;  <br>            <span class="hljs-comment">// 用来记录 queue 的长度，即每层节点的个数</span><br>            <span class="hljs-keyword">int</span> size = queue.size();  <br><br>            <span class="hljs-comment">// 用来保存每一层节点，保存成功后添加到 res 中</span><br>            List&lt;Integer&gt; temp =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); <br><br>            <span class="hljs-comment">// 使用 for 循环，将 queue 中的元素添加的 temp 中</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size ;  i++ )&#123;     <br>                <span class="hljs-comment">// 从 queue 中取出一个节点         </span><br>                TreeNode node = queue.poll();  <br>                <span class="hljs-comment">// 把节点存放到 list 中</span><br>                temp.add(node.val);  <span class="hljs-comment">//将节点值加入list</span><br><br>                <span class="hljs-comment">// 判断当前节点的左子节点是否有值，如果有，则添加到 queue 中</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)<br>                    queue.add(node.left);<br><br>                <span class="hljs-comment">// 判断当前节点的右子节点是否有值，如果有，则添加到 queue 中    </span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)<br>                    queue.add(node.right);<br>            &#125;<br><br>            <span class="hljs-comment">// 把存放了每一层元素的数组 temp 添加到 res 中</span><br>            res.add(temp);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回 res</span><br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法26[力扣104]-二叉树的最大深度</title>
    <link href="/2021/08/31/%E7%AE%97%E6%B3%9526-%E5%8A%9B%E6%89%A3104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2021/08/31/%E7%AE%97%E6%B3%9526-%E5%8A%9B%E6%89%A3104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 如果 root 为空，直接返回 0</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 递归调用 maxDepth，求出当前节点的左子树的最大深度</span><br>        <span class="hljs-keyword">int</span> left = maxDepth(root.left);<br><br>        <span class="hljs-comment">// 递归调用 maxDepth，求出当前节点的右子树的最大深度</span><br>        <span class="hljs-keyword">int</span> right = maxDepth(root.right);<br><br>        <span class="hljs-comment">// 求出当前节点的左右子树中较大的值</span><br>        <span class="hljs-keyword">int</span> childMaxDepth = Math.max(left,right);<br><br>        <span class="hljs-comment">// 二叉树的最大深度就是它的左右子树中较大的值加上 1</span><br>        <span class="hljs-keyword">return</span> childMaxDepth + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法25[力扣445]-两数相加Ⅱ</title>
    <link href="/2021/08/21/%E7%AE%97%E6%B3%9525-%E5%8A%9B%E6%89%A3445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/"/>
    <url>/2021/08/21/%E7%AE%97%E6%B3%9525-%E5%8A%9B%E6%89%A3445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 构建两个栈，用来储存两个链表中的元素</span><br><br>        <span class="hljs-comment">// stack1 用来存储链表 l1 中的元素</span><br>        Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// stack2 用来存储链表 l2 中的元素</span><br>        Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 依次把链表 l1 中的元素加入到 stack1 中</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把当前节点加入到 stack1 中</span><br>            stack1.push(l1.val);<br>            <span class="hljs-comment">// 继续向后遍历</span><br>            l1 = l1.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 依次把链表 l2 中的元素加入到 stack2 中</span><br>        <span class="hljs-keyword">while</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把当前节点加入到 stack2 中</span><br>            stack2.push(l2.val);<br>            <span class="hljs-comment">// 继续向后遍历</span><br>            l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置一个进位，初始化为 0</span><br>        <span class="hljs-comment">// 两个个位数相加，进位只能是 1 或者 0</span><br>        <span class="hljs-comment">// 比如 7 + 8 = 15，进位是 1</span><br>        <span class="hljs-comment">// 比如 2 + 3 = 6，没有进位，或者说进位是 0</span><br>        <span class="hljs-keyword">int</span> carryBit = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 构建一个链表用来存放 l1 和 l2 两个链表相加的结果</span><br>        <span class="hljs-comment">// 其中 dummy 这个节点为虚拟头结点</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 只要任意一个栈或者 carryBit 有值，那么就需要求和</span><br>        <span class="hljs-keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carryBit != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-comment">// 三目运算符，如果栈为空，就用 0 来占位，否则使用栈顶元素值</span><br><br>            <span class="hljs-comment">// 获取 stack1 的栈顶元素值</span><br>            <span class="hljs-keyword">int</span> x = stack1.isEmpty() ? <span class="hljs-number">0</span> : stack1.pop();<br><br>            <span class="hljs-comment">// 获取 stack2 的栈顶元素值</span><br>            <span class="hljs-keyword">int</span> y = stack2.isEmpty() ? <span class="hljs-number">0</span> : stack2.pop();<br><br>            <span class="hljs-comment">// 每一位计算的同时需要考虑上一位的进位情况</span><br>            <span class="hljs-keyword">int</span> sum = x + y + carryBit;<br><br>            <span class="hljs-comment">// 获取当前计算结果的十位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum / 10 = 1，进位为 1</span><br>            carryBit = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 获取当前计算结果的个位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum % 10 = 5</span><br>            <span class="hljs-keyword">int</span> diget =  sum % <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 构建一个节点用来存放这个个位数</span><br>            ListNode digetNode = <span class="hljs-keyword">new</span> ListNode(diget);<br><br>            <span class="hljs-comment">// 把这个节点插入到结果链表中</span><br>            <span class="hljs-comment">// 注意是插入，越后面计算的结果越在链表的前面</span><br><br>            <span class="hljs-comment">// 一开始，dummy 后面没有其它节点，当发生求和计算时</span><br>            <span class="hljs-keyword">if</span>(dummy.next == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 第一个计算结果直接加入到 dummy 后面</span><br>                dummy.next = digetNode;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">// 新的节点的 next 指针为之前的虚拟头节点 dummy 后面的那个节点</span><br>                digetNode.next = dummy.next;<br><br>                <span class="hljs-comment">// 更新 dummy 的 next 指针指向的节点</span><br>                dummy.next = digetNode;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回结果链表的头节点就行，即虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法24[力扣2]-两数相加</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9524-%E5%8A%9B%E6%89%A32-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9524-%E5%8A%9B%E6%89%A32-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://img-blog.csdnimg.cn/3f6824460384408e859c1a70233eeaf2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 构建一个链表用来存放 l1 和 l2 两个链表相加的结果</span><br>        <span class="hljs-comment">// 其中 dummy 这个节点为虚拟头结点</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个进位，初始化为 0</span><br>        <span class="hljs-comment">// 两个个位数相加，进位只能是 1 或者 0</span><br>        <span class="hljs-comment">// 比如 7 + 8 = 15，进位是 1</span><br>        <span class="hljs-comment">// 比如 2 + 3 = 6，没有进位，或者说进位是 0</span><br>        <span class="hljs-keyword">int</span> carryBit = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// l1 和 l2 有可能为空，所以先默认结果链表从虚拟头结点位置开始</span><br>        ListNode cur = dummy;<br><br>        <span class="hljs-comment">// 同时遍历 l1 和 l2</span><br>        <span class="hljs-comment">// 只要此时 l1 和 l2 两个链表中的任意链表中节点有值，就一直加下去</span><br>        <span class="hljs-comment">// 直到两个链表中的所有节点都遍历完毕为止</span><br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 获取 l1 链表中节点的值</span><br>            <span class="hljs-keyword">int</span> x;<br><br>            <span class="hljs-comment">// 观察此时 l1 中的节点是否有值</span><br>            <span class="hljs-comment">// 如果节点不存在，那么就用 0 来占位</span><br>            <span class="hljs-keyword">if</span>( l1 == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 用 0 来占位</span><br>                x = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则，将 l1 的节点值赋值给 x</span><br>                x = l1.val;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取 l2 链表中节点的值</span><br>            <span class="hljs-keyword">int</span> y;<br><br>            <span class="hljs-comment">// 观察此时 l2 中的节点是否有值</span><br>            <span class="hljs-comment">// 如果节点不存在，那么就用 0 来占位</span><br>            <span class="hljs-keyword">if</span>( l2 == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 用 0 来占位</span><br>                y = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则，将 l2 的节点值赋值给 y</span><br>                y = l2.val;<br>            &#125;<br><br>            <span class="hljs-comment">// 每一位计算的同时需要考虑上一位的进位情况</span><br>            <span class="hljs-keyword">int</span> sum = x + y + carryBit;<br><br>            <span class="hljs-comment">// 获取当前计算结果的十位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum / 10 = 1，进位为 1</span><br>            carryBit = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 获取当前计算结果的个位数</span><br>            <span class="hljs-comment">// 比如 7 + 8 = 15</span><br>            <span class="hljs-comment">// 那么 sum % 10 = 5</span><br>            <span class="hljs-keyword">int</span> digit = sum % <span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">// 构建一个节点用来存放这个个位数</span><br>            ListNode digitNode = <span class="hljs-keyword">new</span> ListNode(digit);<br><br>            <span class="hljs-comment">// 把这个节点加入到结果链表中</span><br>            cur.next = digitNode;<br><br>            <span class="hljs-comment">// 移动 cur 的位置，观察后面应该存放什么节点</span><br>            cur = cur.next;<br><br>            <span class="hljs-comment">// l1 链表中还有节点未遍历完毕就继续遍历下去</span><br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>) l1 = l1.next;<br><br>            <span class="hljs-comment">// l2 链表中还有节点未遍历完毕就继续遍历下去</span><br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>) l2 = l2.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 两个链表的尾节点相加之后，有可能产生进位的情况</span><br>        <span class="hljs-comment">// 所以，需要构建一个新的节点用来存放这个进位的结果</span><br>        <span class="hljs-keyword">if</span>(carryBit == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 构建一个节点用来存放这个进位</span><br>            ListNode carryBitNode = <span class="hljs-keyword">new</span> ListNode(carryBit);<br><br>            <span class="hljs-comment">// 把这个节点加入到结果链表中</span><br>            cur.next = carryBitNode;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回结果链表的头节点就行，即虚拟头结点的下一个节点</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法23[力扣142]-环形链表Ⅱ</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9523-%E5%8A%9B%E6%89%A3142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9523-%E5%8A%9B%E6%89%A3142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h3><p>给定一个链表，<strong>返回链表开始入环的第一个节点</strong>。</p><p>如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</p><p>如果 pos 是 -1，则在该链表中没有环。</p><p>注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>1、通过快慢指针的方式，在环中寻找它们的第一次相遇的节点位置</p><p>2、当快慢指针相遇的时候：</p><p><img src="https://img-blog.csdnimg.cn/98527c5216194aca93970af2575ee1f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>x 代表从头节点到环形入口节点的节点数（不包含头节点）</p><p>y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</p><p>z 代表从第一次相遇节点到环形入口的节点数（不包含第一次相遇节点）</p><p>此时，快指针走了 x + y + n (y + z)，其中，x + y 表示快指针第一次到达相遇节点，n 代表快指针在环里面绕了多少圈。</p><p>而慢指针走了 x + y 步。</p><p>那么就出现了一个等式 <code>x + y = [x + y + n (y + z)] / 2</code>，即<code>x = n（y + z）- y</code>。</p><p><strong>n（y + z）- y</strong> 代表的含义是<strong>一个指针从相遇节点开始出发，走了 n 圈之后回到原来的出发位置，往后退 y 步</strong>。</p><p>由于 x 代表从头节点到环形入口节点的节点数，并且<code>x = n（y + z）- y</code>，所以<strong>n（y + z）- y</strong> 代表的含义就是<strong>一个指针从相遇节点开始出发，走了 n 圈之后回到原来的出发位置，往后退 y 步来到了环的入口位置</strong>。</p><p>那么，我们就可以设置两个指针，一个从链表的头节点开始出发，一个指针从相遇节点开始出发，当它们相遇的时候，代表着环的入口节点找到了。</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 1、通过快慢指针的方式，在环中寻找它们的第一次相遇的节点位置</span><br><br>        <span class="hljs-comment">// 2、定义一个慢指针，每次只会向前移动 1 步</span><br>        ListNode slow = head;<br>        <span class="hljs-comment">// 3、定义一个快指针，每次只会向前移动 2 步</span><br>        ListNode fast = head;<br><br>        <span class="hljs-comment">// 4、如果链表有环，那么无论怎么移动，fast 指向的节点都是有值的</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 慢指针每次只会向前移动 1 步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// 快指针每次只会向前移动 2 步</span><br>            fast = fast.next.next;<br><br>            <span class="hljs-comment">// 快慢指针相遇，说明有环</span><br>            <span class="hljs-comment">// x 代表从头节点到环形入口节点的节点数（不包含头节点）</span><br>            <span class="hljs-comment">// y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</span><br>            <span class="hljs-comment">// z 代表从第一次相遇节点到环形入口的节点数（不包含第一次相遇节点）</span><br>            <span class="hljs-comment">// y + z 代表环的节点总数</span><br>            <span class="hljs-comment">// 此时，快指针走了 x + y + n (y + z)</span><br>            <span class="hljs-comment">// 其中，x + y 表示快指针第一次到达相遇节点，n 代表快指针在环里面绕了多少圈</span><br>            <span class="hljs-comment">// 此时，慢指针走了 x + y 步</span><br><br>            <span class="hljs-comment">// 由于快指针每次走 2 步，所以快慢指针第一次相遇的时候出现一个等式</span><br>            <span class="hljs-comment">// x + y = [x + y + n (y + z)] / 2</span><br>            <span class="hljs-comment">// 即 2 * (x + y) = x + y + n (y + z)</span><br>            <span class="hljs-comment">// 即 x + y = n（y + z）</span><br>            <span class="hljs-comment">// 即 x = n（y + z）- y</span><br>            <span class="hljs-comment">// 我们的目的就是去求 x</span><br><br>            <span class="hljs-comment">// 定义两个指针，一个指向相遇节点，定义为 b，一个指向链表头节点，定义为 a</span><br><br>            <span class="hljs-comment">// b 在环中绕圈圈，走了 n（y + z）步会回到原处，即回到相遇节点处</span><br>            <span class="hljs-comment">// 由于 y 代表从环形入口到第一次相遇节点的节点数（不包含环形入口节点）</span><br>            <span class="hljs-comment">// 所以 n（y + z） - y 时，b 到达了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 由于 x 代表从头节点到环形入口节点的节点数（不包含头节点）</span><br>            <span class="hljs-comment">// 所以 a 走了 x 步时，a 到达了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 当 x = n（y + z）- y 时，找到了环形入口节点位置</span><br><br>            <span class="hljs-comment">// 5、开始寻找环入口</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br><br>                <span class="hljs-comment">// 定义两个指针，一个指向相遇节点，定义为 b，一个指向链表头节点，定义为 a</span><br>                <span class="hljs-comment">// 一个指向相遇节点，定义为 b</span><br>                ListNode b = fast;<br><br>                <span class="hljs-comment">// 一个指向链表头节点，定义为 a</span><br>                ListNode a = head;<br><br>                <span class="hljs-comment">// 让 a 、b 两个指针向前移动，每次移动一步，直到相遇位置</span><br>                <span class="hljs-comment">// 由于有环，必然相遇</span><br>                <span class="hljs-comment">// 当 b 走了 n（y + z） - y 时，b 到达了环形入口节点位置</span><br>                <span class="hljs-comment">// 当 a 走了 x 步时，a 到达了环形入口节点位置</span><br>                <span class="hljs-comment">// a 与 b 相遇</span><br>                <span class="hljs-keyword">while</span> (a != b) &#123;<br>                    <span class="hljs-comment">// a 指针每次只会向前移动 1 步</span><br>                    a = a.next;<br>                    <span class="hljs-comment">// b 指针每次只会向前移动 1 步</span><br>                    b = b.next;<br>                &#125;<br><br>                <span class="hljs-comment">// 6、返回 a 和 b 相遇的节点位置就是环形入口节点位置</span><br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有环，返回 null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法22[剑指offer22]-链表中倒数k个节点</title>
    <link href="/2021/08/19/%E7%AE%97%E6%B3%9522-%E5%89%91%E6%8C%87offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0k%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2021/08/19/%E7%AE%97%E6%B3%9522-%E5%89%91%E6%8C%87offer22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0k%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、算法描述"><a href="#一、算法描述" class="headerlink" title="一、算法描述"></a>一、算法描述</h3><p>输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6 。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>一般来说，链表相关的算法题考察的知识点有以下几个：</p><ul><li>递归</li><li>反转</li><li>双指针</li><li>环</li></ul><p>本题解题思路如下：</p><ul><li>1、初始化两个指针 <code>former</code> 和 <code>latter</code>，一开始都指向链表的头节点</li><li>2、前指针 <code>former</code> 先向前走 k 步</li><li>3、两个指针 <code>former</code> 和 <code>latter</code> 同时向前移动，直到前指针 <code>former</code> 指向 <code>NULL</code></li><li>4、由于 former 和 latter 之间的距离为 k，所以 latter 指向的节点即是倒数第 k 个节点，最后返回 <code>latter</code></li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化两个指针 former 和 latter，一开始都指向链表的头节点</span><br><br>        <span class="hljs-comment">// 指针 former 指向链表的头节点</span><br>        ListNode former = head;<br><br>        <span class="hljs-comment">// 指针 latter 指向链表的头节点</span><br>        ListNode latter = head;<br><br>        <span class="hljs-comment">// 让 former 指针先向前走 k 步</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; k; i++)&#123;<br>            <span class="hljs-comment">// former 指针向后移动</span><br>            former = former.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 接下来，让这两个指针 former 和 latter 同时向前移动，直到前指针 former 指向 NULL</span><br>        <span class="hljs-keyword">while</span>(former != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// former 指针向后移动</span><br>            former = former.next;<br>            <span class="hljs-comment">// latter 指针向后移动</span><br>            latter = latter.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 此时，由于 former 和 latter 之间的距离为 k</span><br>        <span class="hljs-comment">// 所以 latter 指向的节点即是倒数第 k 个节点</span><br>        <span class="hljs-keyword">return</span> latter;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法21[面试题35]-复杂链表的复制</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9521-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9521-%E9%9D%A2%E8%AF%95%E9%A2%9835-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目算法"><a href="#一、题目算法" class="headerlink" title="一、题目算法"></a>一、题目算法</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://img-blog.csdnimg.cn/053d8772392f430fa909c1d0a0b412ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>对于链表中的每个节点来说，它都有三个特征：</p><ul><li>值为 val</li><li>一个指向下一个节点的指针 <code>next</code></li><li>一个指向随机节点的指针 <code>random</code></li></ul><p><img src="https://img-blog.csdnimg.cn/1d7aeb183d55481b8b61308912b93730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><p>要想<strong>复制这样一个复杂链表</strong>必须要考虑到这三个特征。</p><p>如果没有 <code>random</code> 指针的话，那就是普通的链表，只需要遍历链表，然后每轮创建新节点，同时赋值 val 和调整前驱指针指向当前节点就行。</p><p>这题出现了 <code>random</code> 指针，由于它可以指向 null 、前面的节点或者后面的节点， 无法做到在一次遍历的过程中就确定下来，因为如果是<strong>指向后面的节点</strong>，但后面的节点还没有创建生成，无法确定。</p><p><img src="https://img-blog.csdnimg.cn/59dd792808be496ca281f89bbe1da7c6.png" alt="3"></p><p>所以，我们需要在<strong>一开始把所有的节点都创建出来</strong>，避免 <code>random</code> 找不到指向，同时观察上图，<strong>每个节点都通过 random 对应着一个新的节点</strong>，这种一一对应的关系，符合<strong>哈希表</strong>的特征。</p><p>此时的哈希表<strong>以原链表的节点作为键，新创建的节点作为值</strong>。</p><p><img src="https://img-blog.csdnimg.cn/54b0ad5bf8f6498ea57be731e7ea0127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="4"></p><p>原链表（Key）中的每个节点都有 next 和 random 指针，而新链表（Value） 没有 next 和 random 指针。</p><p>需要通过第二次的遍历过程进行指针指向的调整。</p><p>在第二次遍历过程中，以原链表中的节点作为键，查找当前<strong>原节点</strong>的指针指向，然后调整<strong>新节点</strong>的指针指向。</p><p><img src="https://img-blog.csdnimg.cn/238575bec17846bb9092945dedce67be.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="5"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界判断，一般链表的题目都需要判断头节点是否为空</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 从链表的头节点开始遍历</span><br>        Node cur = head;<br><br>        <span class="hljs-comment">// 使用一一对应的哈希表结构 Map 存放已经创建的节点</span><br>        Map&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-comment">// 遍历原链表</span><br>        <span class="hljs-keyword">while</span>( cur != <span class="hljs-keyword">null</span> ) &#123;<br>            <span class="hljs-comment">// 以原链表的节点为 Key，构建一个 Map</span><br>            <span class="hljs-comment">// Map 的 Value 为一个新链表中的节点</span><br>            <span class="hljs-comment">// 新节点的值 val 和原链表的值 val 一样</span><br>            <span class="hljs-comment">// 但原链表中的每个节点都有 next 和 random 指针，而 Map 中的 Value 没有 next 和 random 指针</span><br>            <span class="hljs-comment">// map.put(Key,Value)</span><br>            map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));<br>            <span class="hljs-comment">// 查看下一个节点的情况</span><br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 再次从链表的头节点开始遍历</span><br>        cur = head;<br><br>        <span class="hljs-comment">// 遍历原链表</span><br>        <span class="hljs-keyword">while</span>( cur != <span class="hljs-keyword">null</span> ) &#123;<br><br>            <span class="hljs-comment">// 原链表节点 ----  新链表节点</span><br>            <span class="hljs-comment">// key      ----- value</span><br>            <span class="hljs-comment">// cur      ----- map.get(cur)</span><br><br>            <span class="hljs-comment">// 0、在字典中找到一个 cur 为 key 对应的那个 value 值</span><br>            Node valueCur = map.get(cur);<br><br>            <span class="hljs-comment">// 接下来，需要去寻找 valueCur 的 next 节点和 random 节点</span><br><br>            <span class="hljs-comment">// 寻找 valueCur 的 next 节点</span><br>            <span class="hljs-comment">// 1、获取当前节点 cur 在原链表中的 next 指针指向的节点</span><br>            Node keyNextNode = cur.next;<br><br>            <span class="hljs-comment">// 2、在字典中找到以 keyNextNode 为 key 对应的那个 value 值</span><br>            Node valueNextNode = map.get(keyNextNode);<br><br>            <span class="hljs-comment">// 3、那么新链表中的这个节点的 next 指针就是 valueNextNode</span><br>            valueCur.next = valueNextNode;<br><br>            <span class="hljs-comment">// 寻找 valueCur 的  节点</span><br>            <span class="hljs-comment">// 1、获取当前节点 cur 在原链表中的 random 指针指向的节点</span><br>            Node keyRandomNode = cur.random;<br><br>            <span class="hljs-comment">// 2、在字典中找到以 valueRandomNode 为 key 对应的那个 value 值</span><br>            Node valueRandomNode = map.get(keyRandomNode);<br><br>            <span class="hljs-comment">// 4、那么新链表中的这个节点的 next 指针就是 valueNextNode</span><br>            valueCur.random = valueRandomNode;<br><br><br>            <span class="hljs-comment">//遍历下去，查看下一个节点</span><br>            cur = cur.next;<br><br>        &#125;<br>        <span class="hljs-comment">// 原链表节点 ----  新链表节点</span><br>        <span class="hljs-comment">// key      ----- value</span><br>        <span class="hljs-comment">// cur      ----- map.get(cur)</span><br>        <span class="hljs-comment">// head     ----- map.get(head)</span><br>        <span class="hljs-keyword">return</span> map.get(head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法20[力扣328]-奇偶链表</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9520-%E5%8A%9B%E6%89%A3328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9520-%E5%8A%9B%E6%89%A3328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;NULL <br>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 边界情况处理，如果链表为空或者只有一个节点，返回 head 就行</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> ) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头节点，odd 代表奇数节点的头节点</span><br>        ListNode odd = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头节点的下一个节点，even 代表偶数节点的头节点</span><br>        ListNode even = head.next; <br><br>        <span class="hljs-comment">// 设置一个指针，指向偶数节点的头节点，最终让奇数节点的尾节点的 next 指针指向它</span><br>        ListNode evenHead = even;<br><br>        <span class="hljs-comment">// 从偶数链表的头节点开始向后遍历</span><br>        <span class="hljs-comment">// 如果当前节点为空，或者后一节点为空，那么说明整个链表已经查看完毕，不需要再遍历了</span><br>        <span class="hljs-keyword">while</span>(even != <span class="hljs-keyword">null</span> &amp;&amp; even.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 原先奇数节点的下一个节点是偶数节点，即 even 这个节点</span><br>            <span class="hljs-comment">// 根据数学知识，奇数后面一定是偶数，偶数后面一定是奇数</span><br>            <span class="hljs-comment">// 那么 even.next 节点必然是奇数节点</span><br>            <span class="hljs-comment">// 所以让 odd 这个奇数节点的 next 指针指向 even.next 这个奇数节点</span><br>            <span class="hljs-comment">// 这样，odd 上面都是奇数</span><br>            odd.next = even.next;<br>            <span class="hljs-comment">// 让 odd 移动到最新的由奇数节点组成的链表的尾部位置</span><br>            odd = odd.next;<br><br>            <span class="hljs-comment">// 这个时候，odd.next 必然是偶数节点</span><br>            <span class="hljs-comment">// 所以让 even 这个偶数节点的 next 指针指向 odd.next 这个偶数节点</span><br>            even.next = odd.next;<br>            <span class="hljs-comment">// 让 even 移动到最新的由偶数节点组成的链表的尾部位置</span><br>            even = even.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 此时，原链表所有的节点已经遍历完毕</span><br>        <span class="hljs-comment">// odd 上都是奇数节点</span><br>        <span class="hljs-comment">// even 都是偶数节点</span><br>        <span class="hljs-comment">// 根据题目要求，奇数节点都在偶数节点之前</span><br>        <span class="hljs-comment">// 所以让此时右奇数节点组成的链表的尾部的 next 指针指向由偶数节点组成的链表的头部</span><br>        odd.next = evenHead;<br><br>        <span class="hljs-comment">// 最后返回原链表的头部节点就可以了</span><br>        <span class="hljs-comment">// 链表的头部节点没有发生过变化，因为它是奇数节点，并且是第一个奇数节点</span><br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法19[剑指offer06]-从尾到头打印链表</title>
    <link href="/2021/08/17/%E7%AE%97%E6%B3%9519-%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/17/%E7%AE%97%E6%B3%9519-%E5%89%91%E6%8C%87offer06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li>0 &lt;= 链表长度 &lt;= 10000</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>链表都是从头读到尾依次访问每个节点，题目要求我们 <strong>从尾到头</strong> 打印链表，这种逆序的操作很显然可以考虑使用</p><p>具有 <strong>先入后出</strong> 特点的数据结构，那就是 <strong>栈</strong>。</p><p>具体操作如下：</p><ul><li><strong>入栈：</strong> 遍历链表，将各节点值 <code>push</code> 入栈。</li><li><strong>出栈：</strong> 将各个节点值 <code>pop</code> 出栈，存储于数组并返回。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reversePrint(ListNode head) &#123;<br><br>        <span class="hljs-comment">// 构建一个栈，用来存储链表中每个节点的值</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个指针，指向链表的头结点位置，从它开始向后遍历</span><br>        ListNode curNode = head;<br><br>        <span class="hljs-comment">// 不断的遍历原链表中的每个节点，直到为 null</span><br>        <span class="hljs-keyword">while</span> (curNode != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 把每个节点的值加入到栈中</span><br>            stack.push(curNode.val);<br>            <span class="hljs-comment">// curNode 向后移动</span><br>            curNode = curNode.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取栈的长度</span><br>        <span class="hljs-keyword">int</span> size = stack.size();<br><br>        <span class="hljs-comment">// 通过栈的长度，定义一个同样长度的数组 res</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br><br>        <span class="hljs-comment">// 遍历栈，从栈顶挨个弹出每个值，把这些值依次加入到数组 res 中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; size; i++)&#123;<br>            <span class="hljs-comment">// 数组接收栈顶元素值</span><br>            res[i] = stack.pop();<br>        &#125;<br>        <span class="hljs-comment">// 最后返回结果数组就行</span><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法18[力扣25]-k个一组翻转链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9518-%E5%8A%9B%E6%89%A325-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9518-%E5%8A%9B%E6%89%A325-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 虚拟头节点的下一节点指向 head 节点</span><br>        <span class="hljs-comment">// 如果原链表是  1 --&gt;  2 --&gt;  3</span><br>        <span class="hljs-comment">// 那么加上虚拟头节点就是  -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br><br>        dummy.next = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点，pre 表示每次要翻转的链表的头结点的【上一个节点】</span><br>        <span class="hljs-comment">// pre: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点，end 表示每次要翻转的链表的尾节点</span><br>        <span class="hljs-comment">// end: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>        ListNode end = dummy;<br><br>        <span class="hljs-comment">// 通过 while 循环，不断的找到翻转链表的尾部</span><br>        <span class="hljs-keyword">while</span>( end.next != <span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-comment">// 通过 for 循环，找到【每一组翻转链表的尾部】</span><br>            <span class="hljs-comment">// 由于原链表按照 k 个一组进行划分会可能出现有一组的长度不足 k 个</span><br>            <span class="hljs-comment">// 比如原链表 1 --&gt;  2 --&gt;  3 --&gt;  4 --&gt;  5</span><br>            <span class="hljs-comment">// k = 2，划分了三组 1 --&gt;  2， 3 --&gt;  4， 5</span><br>            <span class="hljs-comment">// 所以得确保 end 不为空才去找它的 next 指针，否则 null.next 会报错</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; k &amp;&amp; end != <span class="hljs-keyword">null</span> ; i++)&#123;<br>                <span class="hljs-comment">// end 不断的向后移动，移动 k 次到达【每一组翻转链表的尾部】</span><br>                end = end.next ;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果发现 end == null，说明此时翻转的链表的节点数小于 k ，保存原有顺序就行</span><br>            <span class="hljs-keyword">if</span>(end == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 直接跳出循环，只执行下面的翻转操作</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br><br>            <span class="hljs-comment">// next 表示【待翻转链表区域】里面的第一个节点</span><br>            ListNode next = end.next;<br><br>            <span class="hljs-comment">// 【翻转链表区域】的最尾部节点先断开</span><br>            end.next = <span class="hljs-keyword">null</span> ;<br><br>            <span class="hljs-comment">// start 表示【翻转链表区域】里面的第一个节点</span><br>            ListNode start = pre.next;<br><br><br><br>            <span class="hljs-comment">// 【翻转链表区域】的最头部节点和前面断开</span><br>            pre.next = <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// 这个时候，【翻转链表区域】的头节点是 start，尾节点是 end</span><br>            <span class="hljs-comment">// 开始执行【反转链表】操作</span><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br><br>            <span class="hljs-comment">// 要翻转的链表的头结点的【上一个节点】的 next 指针指向这次翻转的结果</span><br>            pre.next = reverse(start);<br><br>            <span class="hljs-comment">// 接下来的操作是在为【待翻转链表区域】的反转做准备</span><br><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br>            <span class="hljs-comment">// 【翻转链表区域】里面的尾节点的 next 指针指向【待翻转链表区域】里面的第一个节点</span><br>            start.next = next ;<br><br>            <span class="hljs-comment">// 原先是 start --&gt; ...--&gt; end</span><br>            <span class="hljs-comment">// 现在变成了 end --&gt; ...--&gt; start</span><br>            <span class="hljs-comment">// pre 表示每次要翻转的链表的头结点的【上一个节点】</span><br>            pre = start;<br><br>            <span class="hljs-comment">// 将 end 重置为【待翻转链表区域】的头结点的上一个节点。</span><br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br><br><br>    &#125;<br>    <span class="hljs-comment">// 反转链表的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverse(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法17[力扣234]-回文链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9517-%E5%8A%9B%E6%89%A3234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9517-%E5%8A%9B%E6%89%A3234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>请判断一个链表是否为回文链表。    </p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 边界情况判断</span><br><br>        <span class="hljs-comment">// 链表为空或者只有一个节点的情况，属于回文链表</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// 链表只有两个节点的时候，判断这两个节点值是否相等</span><br>        <span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head.val == head.next.val;<br><br>        <span class="hljs-comment">// 通过快慢指针寻找链表的中心点</span><br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头部</span><br>        <span class="hljs-comment">// fast 这个指针每次都向后移动两步</span><br>        ListNode fast = head;<br><br><br>        <span class="hljs-comment">// 设置一个指针，指向链表的头部</span><br>        <span class="hljs-comment">// slow 这个指针每次都向后移动一步</span><br>        ListNode slow = head;<br><br>        <span class="hljs-comment">// 让 fast 和 slow 同时向后移动</span><br>        <span class="hljs-comment">// 其中，fast 这个指针每次都向后移动两步，slow 这个指针每次都向后移动一步</span><br>        <span class="hljs-comment">// 直到 fast 这个指针指向了链表的尾节点，即 fast.next = null</span><br>        <span class="hljs-comment">// 或者 fast 这个指针指向了链表的尾节点的前一个节点，即 fast.next.next = null</span><br>        <span class="hljs-comment">// 这个时候，fast 这个指针无法向后移动两位，跳出循环，找到了中间点</span><br>        <span class="hljs-comment">// 如果链表长度为偶数，则 slow 指向了中间节点前的那个节点</span><br>        <span class="hljs-comment">// 比如链表为  1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; null</span><br><br>        <span class="hljs-comment">// 一开始，slow 和 fast 同时指向 1，slow 移动一位到 2，fast 移动两位到 3</span><br>        <span class="hljs-comment">// 由于 3.next.next 为空，所以跳出 while，此时 slow 指向了中间节点前的那个节点</span><br><br>        <span class="hljs-comment">// 如果链表长度为奇数，则 slow 指向了中间节点</span><br>        <span class="hljs-comment">// 比如链表为  1 --&gt; 2 --&gt; 3 </span><br>        <span class="hljs-comment">// 一开始，slow 和 fast 同时指向 1，slow 移动一位到 2，fast 移动两位到 3</span><br>        <span class="hljs-comment">// 由于 3.next 为空，所以跳出 while，此时 slow 指向了中间节点</span><br><br>        <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// slow 这个指针每次都向后移动一步</span><br>            slow = slow.next;<br>            <span class="hljs-comment">// fast 这个指针每次都向后移动两步</span><br>            fast = fast.next.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 这个时候，slow 指向的那个节点把链表划分为两个区域</span><br>        <span class="hljs-comment">// 翻转右区域的链表</span><br>        <span class="hljs-comment">// 获取右区域的链表翻转之后的头节点</span><br>        ListNode rightHead =  reverse(slow.next);<br><br>        <span class="hljs-comment">// 获取左区域的链表的头节点</span><br>        ListNode leftHead = head;<br><br>        <span class="hljs-comment">// 让 leftHead 和 rightHead 同时向后移动，直到 rightHead 指向 null 为止</span><br>        <span class="hljs-comment">// 说明比较完了所有的节点</span><br>        <span class="hljs-keyword">while</span>(rightHead != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">// 如果它们的节点值不一样，那么就不是回文链表</span><br>            <span class="hljs-keyword">if</span>(leftHead.val != rightHead.val)&#123;<br>                <span class="hljs-comment">// 不是回文链表，返回 false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">// 否则，让 rightHead 继续向右移动</span><br>            rightHead = rightHead.next;<br><br>            <span class="hljs-comment">// 否则，让 rightHead 继续向右移动</span><br>            leftHead = leftHead.next;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 比较完所有的节点，说明是回文链表，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 反转链表的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverse(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法16[力扣面试题02.04]-分割链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9516-%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%9802-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9516-%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E9%A2%9802-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 <strong>小于</strong> x 的节点都出现在 <strong>大于或等于</strong> x 的节点之前。</p><p>你不需要 <strong>保留</strong> 每个分区中各节点的初始相对位置。</p><p>1—–&gt;4—–&gt;<strong>3</strong>—–&gt;2—–&gt;5—–&gt;2</p><p>1—–&gt;2—–&gt;2—–&gt;4—–&gt;<strong>3</strong>—–&gt;5</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>通过构建两个链表来分别处理大于等于 x 的那些节点和小于 x 的那些节点。</p><ul><li>大链表：大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</li><li>小链表：小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</li></ul><p>在遍历原链表的过程中，让大链表去接收那些大于等于 x 的节点，用小链表去接收那些小于 x 的节点，接着让小链表的尾部接上大链表的虚拟头节点的下一个节点，然后让大链表的尾部节点的 next 指针指向 null，最后返回小链表的虚拟头节点的下一个节点就行。</p><h3 id="三、题目代码"><a href="#三、题目代码" class="headerlink" title="三、题目代码"></a>三、题目代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br><br>        <span class="hljs-comment">// 构建两个新链表</span><br>        <span class="hljs-comment">// 大链表：大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 小链表：小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</span><br><br>        <span class="hljs-comment">// 设置一个指针，执行大链表的头结点</span><br>        ListNode bigHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，执行大链表的尾结点</span><br>        ListNode bigTail = bigHead;<br><br>        <span class="hljs-comment">// 设置一个指针，执行小链表的头结点</span><br>        ListNode smallHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，执行小链表的尾结点</span><br>        ListNode smallTail = smallHead;<br><br>        <span class="hljs-comment">// 开始遍历原链表 head，直到遍历到尾部位置</span><br>        <span class="hljs-comment">// 在遍历的过程查看当前节点的值</span><br>        <span class="hljs-keyword">while</span> ( head != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-comment">// 如果当前节点的值小于了特定值 x</span><br>            <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;<br>                <span class="hljs-comment">// 那么我们就把这个节点添加到小链表中</span><br>                <span class="hljs-comment">// 操作就是让小链表中的尾节点的 next 指针指向这个节点</span><br>                smallTail.next = head;<br><br>                <span class="hljs-comment">// 同时，小链表中的尾节点位置发生了变化，也移动到 head 这个位置</span><br>                smallTail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-comment">// 否则，如果当前节点的值大于或者等于了特定值 x</span><br>                 <span class="hljs-comment">// 那么我们就把这个节点添加到大链表中</span><br>                 <span class="hljs-comment">// 操作就是让大链表中的尾节点的 next 指针指向这个节点                 </span><br>                 bigTail.next = head;<br><br>                 <span class="hljs-comment">// 同时，大链表中的尾节点位置发生了变化，也移动到 head 这个位置</span><br>                 bigTail = head;<br>            &#125;<br><br>            <span class="hljs-comment">// 操作完当前节点的值之后，继续去查看链表中的下一个节点</span><br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 通过上面的循环，原链表已经被分割为两个部分</span><br>        <span class="hljs-comment">// 其中，大链表中的所有节点值都是大于或者等于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 小链表中的所有节点值都是小于特定值（除了虚拟头节点的值）</span><br>        <span class="hljs-comment">// 接下来，我们把大小链表串联起来</span><br><br>        <span class="hljs-comment">// 让小链表的尾节点的 next 指针指向大链表虚拟头节点的下一个节点</span><br>        smallTail.next = bigHead.next;<br><br>        <span class="hljs-comment">// 让大链表的尾节点的 next 指针指向 null</span><br>        bigTail.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 最后返回小链表的虚拟头节点的下一个节点就行</span><br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法15[力扣160]-相交链表</title>
    <link href="/2021/08/16/%E7%AE%97%E6%B3%9515-%E5%8A%9B%E6%89%A3160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/16/%E7%AE%97%E6%B3%9515-%E5%8A%9B%E6%89%A3160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://img-blog.csdnimg.cn/866d054fee8a4e2394c2d27df596adf8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>在节点 c1 开始相交。</p><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 null。</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h3 id="二、题目描述"><a href="#二、题目描述" class="headerlink" title="二、题目描述"></a>二、题目描述</h3><h4 id="1、模拟"><a href="#1、模拟" class="headerlink" title="1、模拟"></a>1、模拟</h4><p>首先假设 A 、B 两个链表是有<strong>相交节点</strong>的情况。</p><p><img src="https://img-blog.csdnimg.cn/3cdc5cf2e6a84144b501a5b14ad35609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><p><img src="https://img-blog.csdnimg.cn/e9149b232ce54441884c3754b6e15e58.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="3"></p><p><img src="https://img-blog.csdnimg.cn/92457e3ef68647f4b8abfdf9a4e07168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="4"></p><p><img src="https://img-blog.csdnimg.cn/eefe202962b44c9fabc14f1fa7aca9da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="5"></p><p><img src="https://img-blog.csdnimg.cn/3fb1bbb86ea14d7d881f44fe37c1aac4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="6"></p><p>再假设 A 、B 两个链表是<strong>没有相交节点</strong>的情况。</p><p><img src="https://img-blog.csdnimg.cn/2fd058aef79e470ba8a7d6dc354bccb2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="7"></p><p><img src="https://img-blog.csdnimg.cn/4bde317acefa4abf9dfecef6c9336026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="8"></p><h4 id="2、规律"><a href="#2、规律" class="headerlink" title="2、规律"></a>2、规律</h4><p>也就是说，无论 A、B 两个链表是否有相交点，最终都会指向一个相同的节点，要么是它们的公共尾部，要么是 NULL。</p><p>让指针 <code>pointA</code> 和 <code>pointB</code> 分别指向链表 A 和链表 B 的头结点，之后两个指针分别以步幅为 1 的速度向链表的尾部遍历。</p><ul><li>当指针 <code>pointA</code> 遍历到链表 A 的尾节点时，此时指针 <code>pointA</code> 走了 a 个节点，将指针 <code>pointA</code> 指向链表 B 的头部，继续向后遍历，直至走到 <code>c1</code>，此时指针 <code>pointA</code> 总共走了 <code>a + ( b - c )</code> 步。</li><li>当指针 <code>pointB</code> 遍历到链表 B 的尾节点时，此时指针 <code>pointB</code> 走了 b 个节点，将指针 <code>pointB</code> 指向链表 A 的头部，继续向后遍历，直至走到 <code>c1</code>，此时指针 <code>pointB</code> 总共走了 <code>b + ( a - c )</code> 步。</li></ul><p>根据数学知识，<code>a + ( b - c ) = b + ( a - c )</code> ，如果 c &gt; 0，表明两链表有公共尾部， <code>c1</code> 存在，两两链表同时到达 <code>c1</code>；如果 c = 0，表明两链表没有公共尾部，指针 <code>pointA</code> 和 <code>pointB</code> 都指向 <code>NULL</code>。</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 边界判断</span><br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 设置一个指针 pointA，指向链表 A 的头节点</span><br>        ListNode pointA = headA;<br><br>        <span class="hljs-comment">// 设置一个指针 pointB，指向链表 B 的头节点</span><br>        ListNode pointB = headB;<br><br>        <span class="hljs-comment">// 指针 pointA 和 指针 pointB 不断向后遍历，直到找到相交点</span><br>        <span class="hljs-comment">// 不用担心会跳不出这个循环，实际上在链表 headA 长度和链表 headB 长度的最小公倍数的情况下</span><br>        <span class="hljs-comment">// pointA 和 pointB 都会同时指向 null</span><br>        <span class="hljs-comment">// 比如 headA 的长度是 7，headB 的长度是 11，这两个链表不相交</span><br>        <span class="hljs-comment">// 那么 pointA 移动了 7 * 11 = 77 次之后，会指向 null</span><br>        <span class="hljs-comment">// pointB 移动了 7 * 11 = 77 次之后，也指向 null</span><br>        <span class="hljs-comment">// 这个时候就跳出了循环</span><br>        <span class="hljs-keyword">while</span> (pointA != pointB) &#123;<br>            <span class="hljs-comment">// 指针 pointA 一开始在链表 A 上遍历，当走到链表 A 的尾部即 null 时，跳转到链表 B 上 </span><br>            <span class="hljs-keyword">if</span>( pointA == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 指针 pointA 跳转到链表 B 上  </span><br>                pointA = headB;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则的话 pointA 不断的向后移动</span><br>                pointA = pointA.next;<br>            &#125;<br><br>             <span class="hljs-comment">// 指针 pointB 一开始在链表 B 上遍历，当走到链表 B 的尾部即 null 时，跳转到链表 A 上 </span><br>            <span class="hljs-keyword">if</span>( pointB == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-comment">// 指针 pointA 跳转到链表 B 上  </span><br>                pointB = headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 否则的话 pointB 不断的向后移动</span><br>                pointB = pointB.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 1、此时，pointA 和 pointB 指向那个相交的节点，返回任意一个均可</span><br>        <span class="hljs-comment">// 2、此时，headA 和 headB 不想交，那么 pointA 和 pointB 均为 null，也返回任意一个均可</span><br>        <span class="hljs-keyword">return</span> pointA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法14[力扣203]-移除链表元素</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9514-%E5%8A%9B%E6%89%A3203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9514-%E5%8A%9B%E6%89%A3203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val val 的节点，并返回 <strong>新的头节点</strong> 。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>移除的节点有两种情况。</p><p>1、移除的是头节点</p><p>2、移除的是其它节点</p><p>对于<strong>移除其它节点</strong>这种情况，我们可以让它的前一个节点指向移除节点的下一节点来解决。</p><p><img src="https://img-blog.csdnimg.cn/e26296f32514448686d9787357fdc663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><p>对于<strong>移除头节点</strong>这种情况，为了让解决情况和上面的逻辑一样，我们借助一个<strong>虚拟节点</strong>来解决。</p><p>我们给链表添加一个虚拟头节点作为新的头节点。</p><p><img src="https://img-blog.csdnimg.cn/1cffa5517d014bf3a2d7d0a9810bd231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="2"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 边界情况，如果链表为空，那么没有元素可以删除，直接返回空</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>    <span class="hljs-comment">// 设置虚拟节点的目的是为了让原链表中所有节点就都可以按照统一的方式进行移除</span><br>    <span class="hljs-comment">// 因为如果不设置虚拟节点，如果删除的元素是原链表中的头节点，那么需要额外的做一些判断，比较繁琐</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 虚拟头节点的下一节点指向 head 节点</span><br>    <span class="hljs-comment">// 如果原链表是  1 --&gt;  2 --&gt;  3</span><br>    <span class="hljs-comment">// 那么加上虚拟头节点就是  -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>    dummy.next = head;<br><br>    <span class="hljs-comment">// 设置一个指针，指向此时的虚拟节点</span><br>    <span class="hljs-comment">// pre: -1 --&gt;  1 --&gt;  2 --&gt;  3</span><br>    ListNode pre = dummy;<br><br>    <span class="hljs-comment">// 设置一个指针，指向原链表 head</span><br>    ListNode cur = head;<br><br>    <span class="hljs-comment">// 让 cur 不断的向后移动，直到移动到链表的最尾部，指向 null 的那个位置</span><br>    <span class="hljs-comment">// 此时 pre 还在指向 dummy</span><br>    <span class="hljs-comment">// 也就是说一开始 pre 落后 cur 一个节点</span><br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br><br>        <span class="hljs-comment">// 移动的过程中，如果发现当前的节点值和目标值一样</span><br>        <span class="hljs-comment">// 我们就让指针 pre 所指向的节点的下一节点跳过这个值</span><br>        <span class="hljs-keyword">if</span> (cur.val == val) &#123;<br>            <span class="hljs-comment">// 让指针 pre 所指向的节点的下一节点跳过这个值</span><br>            pre.next = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则的话，pre 跟上 cur 的位置</span><br>            pre = cur;<br>        &#125;<br>        <span class="hljs-comment">// 判断完当前的节点情况后，让 cur 向后移动</span><br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后返回 dummy 节点的下一节点</span><br>    <span class="hljs-comment">// 因为这个时候 dummy 指向的是一个我们设置的节点，它的下一节点才是原链表中的节点</span><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法13[力扣92]-反转链表Ⅱ</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9513-%E5%8A%9B%E6%89%A392-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9513-%E5%8A%9B%E6%89%A392-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><img src="https://img-blog.csdnimg.cn/9402f191ec7a4f64bb30c3f9c849624d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="1"></p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>1、构建一个虚拟节点，让它指向原链表的头节点。</p><p>2、设置两个指针，pre 指针指向以虚拟头节点为链表的头部位置，cur 指针指向原链表的头部位置。</p><p>3、让着两个指针向前移动，直到 pre 指向了第一个要反转的节点的前面那个节点，而 cur 指向了第一个要反转的节点。</p><p>4、开始指向翻转操作</p><ul><li>1）、设置临时变量 temp，temp 是 cur 的 next 位置，保存当前需要翻转节点的后面的节点，我们需要交换 temp 和 cur</li><li>2）、让 cur 的 next 位置变成 temp 的下一个节点</li><li>3）、让 temp 的 next 位置变成 cur</li><li>4）、让 pre 的 next 位置变成 temp</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        <span class="hljs-comment">// 设置虚拟节点的目的是为了让原链表中所有节点就都可以按照统一的方式进行翻转</span><br>        <span class="hljs-comment">// 比如如果翻转的区间包含了原链表中的第一个位置，那么如果不设置 dummy</span><br>        <span class="hljs-comment">// 在翻转的过程中需要设置其它的临时变量来保持第一位置节点的指针</span><br>        <span class="hljs-comment">// 具体可以通过动画来理解</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 让虚拟节点指向原链表的头部</span><br>        dummy.next = head;<br><br>        <span class="hljs-comment">// 设置一个指针，指向以虚拟头节点为链表的头部位置</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 设置一个指针，指向原链表的头部位置</span><br><br>        ListNode cur = head;<br><br><br>        <span class="hljs-comment">// 从虚拟头节点出发，pre 走 left - 1 步找到需要翻转的左区间</span><br>        <span class="hljs-comment">// for 循环结束后，pre 的右节点是需要翻转的节点</span><br>        <span class="hljs-comment">// for 循环结束后，cur 指向的就是需要翻转的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br><br><br>            <span class="hljs-comment">// pre 不断的向右移动，直到走到翻转的左区间为止</span><br>            pre = pre.next;<br>            <span class="hljs-comment">// cur 不断的向右移动，找到了需要翻转的第一个节点</span><br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始翻转这些节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br><br>            <span class="hljs-comment">// 设置临时变量，保存当前需要翻转节点的后面的节点</span><br>            ListNode temp = cur.next;<br><br>            <span class="hljs-comment">// 这个时候，让 temp 和 cur 两个节点翻转一下</span><br>            <span class="hljs-comment">// 比如，一开始 i = 0 的时候 cur 为 2， temp 为 3</span><br>            <span class="hljs-comment">// 执行完下面的代码，如果原链表是</span><br>            <span class="hljs-comment">// 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>            <span class="hljs-comment">// 变成了</span><br>            <span class="hljs-comment">// 1 --&gt; 3 --&gt; 2 --&gt; 4 --&gt; 5</span><br><br>            <span class="hljs-comment">// cur 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， cur 为 2，cur.next.next 的值是 4</span><br>            <span class="hljs-comment">// 所以，这行代码让 cur 的下一节点不是 3 ，而是 4 </span><br>            <span class="hljs-comment">// 2 --&gt; 4</span><br>            <span class="hljs-comment">// 等价于 cur.next = temp.next</span><br>            cur.next = cur.next.next;<br><br>            <span class="hljs-comment">// temp 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， temp 为 3，pre 为 1，pre 下一节点的值是 2</span><br>            <span class="hljs-comment">// 所以，这行代码让 temp 的下一节点不是 4 ，而是 2 </span><br>            <span class="hljs-comment">// 3 --&gt; 2</span><br>            temp.next = pre.next;<br><br>            <span class="hljs-comment">// pre 的下一节点是等号右侧的值</span><br>            <span class="hljs-comment">// i = 0 的时候， pre 为 1，temp 的值是 3</span><br>            <span class="hljs-comment">// 所以，这行代码让 pre 的下一节点为 3</span><br>            <span class="hljs-comment">// 1 --&gt; 3</span><br><br>            pre.next =temp;<br><br>            <span class="hljs-comment">// i = 0 结束之后，链表变成了</span><br>            <span class="hljs-comment">// 1 --&gt; 3 --&gt; 2 --&gt; 4 --&gt; 5</span><br><br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回虚拟头节点的下一个节点，因为虚拟节点不在链表中</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法12[力扣21]-合并两个有序链表</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9512-%E5%8A%9B%E6%89%A321-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9512-%E5%8A%9B%E6%89%A321-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><h3 id="二、参考代码"><a href="#二、参考代码" class="headerlink" title="二、参考代码"></a>二、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始设置一个虚拟节点，它的值为 -1，它的值可以设置为任何的数，因为我们根本不需要使用它的值</span><br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置一个指针，指向虚拟节点</span><br>        ListNode pre = dummy;<br><br>        <span class="hljs-comment">// 通过一个循环，不断的比较 l1 和 l2 中当前节点值的大小，直到 l1 或者 l2 遍历完毕为止</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 如果 l1 当前节点的值小于等于了 l2 当前节点的值</span><br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                <span class="hljs-comment">// 让 pre 指向节点的 next 指针指向这个更小值的节点</span><br>                <span class="hljs-comment">// 即指向 l1</span><br>                pre.next = l1;<br>                <span class="hljs-comment">// 让 l1 向后移动</span><br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 让 pre 指向节点的 next 指针指向这个更小值的节点</span><br>                <span class="hljs-comment">// 即指向 l2</span><br>                pre.next =l2;<br>                <span class="hljs-comment">// 让 l2 向后移动</span><br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">// 让 pre 向后移动</span><br>            pre = pre.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 跳出循环后，l1 或者 l2 中可能有剩余的节点没有被观察过</span><br>        <span class="hljs-comment">// 直接把剩下的节点加入到 pre 的 next 指针位置</span><br><br>        <span class="hljs-comment">// 如果 l1 中还有节点</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把 l1 中剩下的节点全部加入到 pre 的 next 指针位置</span><br>            pre.next = l1;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果 l2 中还有节点</span><br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 把 l2 中剩下的节点全部加入到 pre 的 next 指针位置</span><br>            pre.next = l2;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回虚拟节点的 next 指针</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法11[力扣206]-反转链表</title>
    <link href="/2021/08/12/%E7%AE%97%E6%B3%9511-%E5%8A%9B%E6%89%A3206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/08/12/%E7%AE%97%E6%B3%9511-%E5%8A%9B%E6%89%A3206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; null</p><p>5 –&gt; 4 –&gt; 3 –&gt; 2 –&gt; 1 –&gt; null</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>这道题目有很多种解法，递归解法最难以理解整个过程，今天我就带大家来探究一次！</p><p>先来看分析过程，这里看不懂没关系，一定要看最后的<strong>动画过程</strong>。</p><ul><li>1、通过<strong>递归函数</strong>，一直递归到链表的最后一个结点为止，此时，<strong>该结点就是反转成功后的头结点</strong>，是最终的返回结果。</li><li>2、在递归函数中，让当前节点的下一个节点的 <code>next</code> 指针指向当前节点。</li><li>3、在递归函数中，让当前节点的 <code>next</code> 指针指向 <code>null</code></li><li>4、通过二三步的操作，已经让递归函数中的链表实现了<strong>局部反转</strong>，将结果返回给上一层递归函数</li><li>5、所有递归结束后，链表反转成功。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 寻找递归终止条件</span><br>        <span class="hljs-comment">// 1、head 指向的结点为 null </span><br>        <span class="hljs-comment">// 2、head 指向的结点的下一个结点为 null </span><br>        <span class="hljs-comment">// 在这两种情况下，反转之后的结果还是它自己本身</span><br>        <span class="hljs-keyword">if</span>( head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)  <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">// 不断的通过递归调用，直到无法递归下去，递归的最小粒度是在最后一个节点</span><br>        <span class="hljs-comment">// 因为到最后一个节点的时候，由于当前节点 head 的 next 节点是空，所以会直接返回 head</span><br>        ListNode cur = reverseList(head.next);<br><br>        <span class="hljs-comment">// 比如原链表为 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br>        <span class="hljs-comment">// 第一次执行下面代码的时候，head 为 4，那么 head.next = 5</span><br>        <span class="hljs-comment">// 那么 head.next.next 就是 5.next ，意思就是去设置 5 的下一个节点</span><br>        <span class="hljs-comment">// 等号右侧为 head，意思就是设置 5 的下一个节点是 4</span><br><br>        <span class="hljs-comment">// 这里出现了两个 next</span><br>        <span class="hljs-comment">// 第一个 next 是「获取」 head 的下一节点</span><br>        <span class="hljs-comment">// 第二个 next 是「设置」 当前节点的下一节点为等号右侧的值</span><br>        head.next.next = head;<br><br><br>        <span class="hljs-comment">// head 原来的下一节点指向自己，所以 head 自己本身就不能再指向原来的下一节点了</span><br>        <span class="hljs-comment">// 否则会发生无限循环</span><br>        head.next = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// 我们把每次反转后的结果传递给上一层</span><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法10[力扣239]-滑动窗口的最大值</title>
    <link href="/2021/08/09/%E7%AE%97%E6%B3%9510-%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2021/08/09/%E7%AE%97%E6%B3%9510-%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,3,-1,-3,5,3,6,7]</span>, 和 k = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">[3,3,5,5,6,7]</span> <br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/1crv4.png" alt="1"></p><p><strong>提示：</strong></p><ul><li>你可以假设 <code>k</code> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p><strong>滑动窗口</strong>这个词包含两个概念，一个是<strong>滑动</strong>，一个是<strong>窗口</strong>。</p><p>首先是窗口需要生成，一开始里面是没有任何元素的。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/p57vp.jpg" alt="2"></p><p>然后再<strong>滑动</strong>，随着窗口不断的滑动，窗口里面的元素个数从 0 到 1，再到 2，再到 3，此时，从窗口里面宣传最大值。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/624h8.jpg" alt="3"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/f9wt0.jpg" alt="4"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/zdyac.jpg" alt="ww"></p><p>想要找出当前窗口里面的<strong>最大值</strong>，自然而然的想法就是<strong>遍历窗口中的所有元素</strong>，从中选出最大值，这样的复杂度是 <code>O（k*n）</code> 级别，复杂度有点高。</p><p>首先滑动窗口滑过所有的元素必然要经历 <code>O(n)</code> 的时间，这没法调整，所以可以优化的方向在于<strong>获取当前窗口的最大值</strong>，即想办法从 <code>O(k)</code> 优化到 <code>O(logk）</code>或者直接优化到 <code>O(1)</code>。</p><p>使用<strong>双端队列</strong>！</p><p>让窗口移动的过程，维护好队列里面的元素，做到<strong>每次窗口移动后</strong>都能马上知道当前窗口的最大值，由于想要做到 <strong>O(1)</strong> 的级别拿到最大值，那么必须是它的<strong>队首始终是最大值</strong>，也就是说我们需要维护一个<strong>递减队列</strong>用来保存队列中 <strong>所有递减的元素</strong> 。</p><p>一开始，窗口中只有 1，队列中放入 1。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/bhbju.jpg" alt="wq"></p><p>窗口滑动，包含了 1 和 3，3 大于 1，如果直接放入队列，队列为 1 3，不是递减队列，所以需要先将 1 移除再放入 3 。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/kge6l.jpg" alt="we"></p><p>继续滑动，窗口元素为 1 3 -1 。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/6v3hl.jpg" alt="wx"></p><p>滑动窗口已经有三个元素，是合格的窗口，获取它的最大值只需要获取队列的<strong>队首</strong>元素就行.</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ua2gr.jpg" alt="wc"></p><p>同样的，窗口不断的向右移动，每次窗口都会增加新的元素，为了让队列中的<strong>队首</strong>元素始终是<strong>当前窗口</strong>的最大值，需要把队列中所有小于新元素值的那些元素移除。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/0scjx.jpg" alt="wv"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/n7x1j.jpg" alt="dvr"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/ia1zp.jpg" alt="wfr"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/o0qtc.jpg" alt="wewq"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/lc0g3.jpg" alt="2w"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/pdy68.jpg" alt="wad30"></p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 登录 AlgoMooc 官网获取更多算法图解</span><br><span class="hljs-comment">// https://www.algomooc.com</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// 边界情况</span><br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 构建双端队列</span><br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-comment">// 构建存储最大值的数组</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 一开始滑动窗口不包含 K 个元素，不是合格的滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// 在滑动过程中，维护好 deque，确保它是单调递减队列</span><br><br>            <span class="hljs-comment">// 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span><br>            <span class="hljs-comment">// 直到考察元素可以放入到队列中</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>                deque.removeLast();<br>            &#125;<br><br>            <span class="hljs-comment">// 考察元素可以放入到队列中</span><br>            deque.addLast(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 这个时候，滑动窗口刚刚好有 k 个元素，是合格的滑动窗口，那么最大值就是队列中的队首元素</span><br>        res[<span class="hljs-number">0</span>] = deque.peekFirst();<br><br><br>        <span class="hljs-comment">// 现在让滑动窗口滑动</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 滑动窗口已经装满了元素，向右移动会把窗口最左边的元素抛弃</span><br>            <span class="hljs-comment">// i - k 为滑动窗口的最左边</span><br>            <span class="hljs-comment">// 如果队列的队首元素和窗口最左边的元素相等，需要将队首元素抛出</span><br>            <span class="hljs-comment">// 如果不写这个判断，会导致队列中会包含非当前窗口的元素</span><br>            <span class="hljs-comment">// 比如窗口大小为 1，队列为 1 -1，此时窗口为 【 1 】,队列为 1，输出最大值 1，下一个窗口为 【 -1 】，准备移动的时候队列 1 和数组最左端元素一样，必须移除，否则队列中是 【 1，-1 】，输出的结果是 1，而 1 不在窗口 【 -1 】中</span><br>            <span class="hljs-keyword">if</span>(deque.peekFirst() == nums[i - k])&#123;<br>                deque.removeFirst();<br>            &#125;<br><br><br>            <span class="hljs-comment">// 反复判断，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span><br>            <span class="hljs-comment">// 直到考察元素可以放入到队列中</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>                deque.removeLast();<br>            &#125;<br><br>            <span class="hljs-comment">// 考察元素可以放入到队列中</span><br>            deque.addLast(nums[i]);<br>            <span class="hljs-comment">// 此时，结果数组的值就是队列的队首元素</span><br>            res[i - k + <span class="hljs-number">1</span>] = deque.peekFirst();<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回 res</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法9[力扣739]-每日温度</title>
    <link href="/2021/08/09/%E7%AE%97%E6%B3%959-%E5%8A%9B%E6%89%A3739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2021/08/09/%E7%AE%97%E6%B3%959-%E5%8A%9B%E6%89%A3739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：<code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>这道题目最 “难” 的一个点是题目的理解。</p><p>给定列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，为啥输出就是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code> ？</p><p>下面来一个个进行解释。</p><p>对于输入 73，它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第二天的时候，温度升高到 74 ，所以对应的结果是 1。</p><p>对于输入 74，它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第三天的时候，温度升高到 75 ，所以对应的结果是 1。</p><p>对于输入 75，它经过 1 天后发现温度是 71，没有超过它，继续等，一直 <strong>等了四天</strong>，在第七天才等到温度的升高，温度升高到 76 ，所以对应的结果是 4 。</p><p>对于输入 71，它经过 1 天后发现温度是 69，没有超过它，继续等，一直 <strong>等了两天</strong>，在第六天才等到温度的升高，温度升高到 72 ，所以对应的结果是 2 。</p><p>对于输入 69，它 <strong>经过一天</strong> 后发现温度是 72，已经超过它，所以对应的结果是 1 。</p><p>对于输入 72，它 <strong>经过一天</strong> 后发现温度是 76，已经超过它，所以对应的结果是 1 。</p><p>对于输入 76，后续 <strong>没有温度</strong> 可以超过它，所以对应的结果是 0 。</p><p>对于输入 73，后续 <strong>没有温度</strong> 可以超过它，所以对应的结果是 0 。</p><p>也就是说，这道题目就是<strong>给你一个值，让你找到右边第一个比它大的数，它们两则的下标差就是输出结果</strong>。</p><p>好了，理解了题意我们来思考如何求解：借助<strong>单独递增栈</strong>来处理。</p><p>具体操作如下：</p><p>遍历整个数组，如果栈不空，且<strong>当前数字大于栈顶元素</strong>，那么如果直接入栈的话就不是 <strong>递增栈</strong> ，所以需要取出栈顶元素，由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，直接求出下标差就是二者的距离。</p><p>继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，再将数字入栈，这样就可以一直保持递增栈，且每个数字和第一个大于它的数的距离也可以算出来。</p><h4 id="2-1放入元素"><a href="#2-1放入元素" class="headerlink" title="2.1放入元素"></a>2.1放入元素</h4><p>它需要 <strong>经过一天</strong> 才能等到温度的升高，也就是在第二天的时候，温度升高到 74 ，所以对应的结果是 1。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/402235a4f6f3238e10b82a01a95e963.png" alt="73"></p><p>替换掉73</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/e80828d7fa387bab730a1da6a94703b.png" alt="替换73"></p><p>放入的比原先在栈中的小时</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/b32d13d60898eabdf758947689fad4f.png" alt="小"></p><p>当放入76后替换</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/31fa09bbd04f5778f1a4003f379ee35.png" alt="76"></p><h3 id="三、代码演示"><a href="#三、代码演示" class="headerlink" title="三、代码演示"></a>三、代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 维护一个单调递增栈，栈内元素从栈底到栈顶依次减小</span><br><span class="hljs-comment">     * 入栈的元素要和当前栈内栈首元素进行比较</span><br><span class="hljs-comment">     * 如果大于栈首元素，说明温度比之前更高，那么它们的下标差就是栈首元素等了多少天等到的更高温度的结果</span><br><span class="hljs-comment">     * 如果小于栈首元素，说明温度比之前更低，说明还没有等到更高的温度，直接放入到栈中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br><br>        <span class="hljs-comment">// 构建一个栈,用来存放每日温度的下标</span><br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 构建一个数组，用来保存输出结果</span><br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br><br>        <span class="hljs-comment">// 从头开始遍历每天的温度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br><br>            <span class="hljs-comment">// 拿到当天的温度，需要和栈首元素进行比较</span><br>            <span class="hljs-comment">// 如果此时栈不为空并且当天的温度大于栈首元素</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br><br>                <span class="hljs-comment">// 首先获取栈首元素的值，并将元素从栈中移除</span><br>                <span class="hljs-keyword">int</span> preIndex = stack.pop();<br><br>                <span class="hljs-comment">// 它们的下标差就是栈首元素等了多少天等到的更高温度的结果，保存到输出数组 res 中</span><br>                res[preIndex] = i - preIndex;<br>            &#125;<br><br>            <span class="hljs-comment">// 再把当天的温度的下标值存放到栈中</span><br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-comment">// 最后输出 res 数组即可</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法8[力扣155]-最小栈</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%958-%E5%8A%9B%E6%89%A3155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%958-%E5%8A%9B%E6%89%A3155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>设计一个支持 push ，pop ，top 操作，并能在<strong>常数时间</strong>内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>由于需要在常数时间内找到最小的元素，那么说明肯定是不能使用遍历，因为遍历是 O(n) 级别的时间，那么只能使用辅助空间进行存储，这是一种<strong>空间换时间</strong>的思想。</p><p>这里我们设置两个栈：<strong>普通栈</strong>和<strong>辅助栈</strong>。</p><h4 id="1、push-操作"><a href="#1、push-操作" class="headerlink" title="1、push 操作"></a>1、push 操作</h4><p>普通栈：直接添加 push 进来的值</p><p>辅助栈：每次 push 一个新元素的时候，将普通栈中最小的元素 push 进辅助栈中</p><h4 id="2、pop-操作"><a href="#2、pop-操作" class="headerlink" title="2、pop 操作"></a>2、pop 操作</h4><p>普通栈：直接移除普通栈中的栈顶元素</p><p>辅助栈：判断<strong>普通栈</strong>中刚刚移除的栈顶元素值是否和此时<strong>辅助栈</strong>中的栈顶元素相同，如果是则将<strong>辅助栈</strong>中的栈顶元素移除，否则不执行操作，这样的目的是为了让<strong>辅助栈中的栈顶元素始终是普通栈中的最小值</strong>。</p><h4 id="3、top-操作"><a href="#3、top-操作" class="headerlink" title="3、top 操作"></a>3、top 操作</h4><p>普通栈：返回<strong>普通栈</strong>的栈顶元素</p><p>辅助栈：不执行操作</p><h4 id="4、getMin-操作"><a href="#4、getMin-操作" class="headerlink" title="4、getMin 操作"></a>4、getMin 操作</h4><p>普通栈：不执行操作</p><p>辅助栈：返回<strong>辅助栈</strong>的栈顶元素</p><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br>    <span class="hljs-comment">// 首先定义好两个栈</span><br><br>    <span class="hljs-comment">// 一个栈叫做 stack，负责栈的正常操作</span><br>    Stack&lt;Integer&gt; stack;<br>    <span class="hljs-comment">// 一个栈叫做 minStack，负责获取 stack 中的最小值，它等价于遍历 stack 中的所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈</span><br>    Stack&lt;Integer&gt; minStack;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 在这个函数中初始化两个栈，传入的参数为空，返回也为空</span><br><br>        <span class="hljs-comment">// 初始化 stack</span><br>        stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        <span class="hljs-comment">// 初始化 minStack</span><br>        minStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 新添加的元素添加到 stack 中</span><br>        stack.push(x);<br><br>        <span class="hljs-comment">// 判断 minStack 是否为空，如果为空，直接同时把新添加的元素添加到 minStack 中</span><br><br>        <span class="hljs-comment">// 如果 minStack 不为空</span><br>        <span class="hljs-keyword">if</span> (!minStack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 获取 minStack 的栈顶元素</span><br>            <span class="hljs-keyword">int</span> top = minStack.peek();<br>            <span class="hljs-comment">// 只有新添加的元素不大于 top 才允许添加到 minStack 中，目的是为了让 minStack 从栈底到栈顶是降序的</span><br>            <span class="hljs-keyword">if</span> (x &lt;= top) &#123;<br>                <span class="hljs-comment">// 此时，新添加的元素 x 小于 top，加入到 minStack 后依旧是从栈底到栈顶是降序的</span><br>                minStack.push(x);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 此时，minStack 中没有元素，所以直接把新添加的元素添加到 minStack 中</span><br>            minStack.push(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// 让 stack 执行正常的 pop 操作就行</span><br>        <span class="hljs-keyword">int</span> pop = stack.pop();<br><br>        <span class="hljs-comment">// 由于 minStack 中的所有元素都是来自于 stack 中，所以 stack 删除元素后，minStack 也要考虑是否需要删除元素</span><br>        <span class="hljs-comment">// 否则的话，minStack 有可能保存一个 stack 中不存在的元素</span><br><br>        <span class="hljs-comment">// 首先，获取 minStack 的栈顶元素</span><br>        <span class="hljs-keyword">int</span> top = minStack.peek();<br>        <span class="hljs-comment">// 再判断 top 这个栈顶元素是否和 stack 移除的元素相等，如果相等，那么需要把 minStack 中的栈顶元素一并移除 </span><br>        <span class="hljs-keyword">if</span> (pop == top) &#123;<br>            <span class="hljs-comment">// 移除 minStack 的栈顶元素</span><br>            minStack.pop();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回 stack 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回 minStack 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法7[力扣232]-用栈实现队列</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%957-%E5%8A%9B%E6%89%A3232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%957-%E5%8A%9B%E6%89%A3232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>请你仅使用两个栈实现先入先出队列。</p><p>队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><ul><li><code>void push(int x)</code>将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code>如果队列为空，返回 true ；否则，返回 false</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><h4 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h4><p>如果是栈的插入操作，那我们可以把元素都先插入到 stackIn 中，也就实现了队列的 <strong>入队操作</strong> 。</p><h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><ul><li>当 stackOut 中不为空时，直接操作，此时在 stackOut 中的栈顶元素是最先进入队列的元素，返回该元素即可；</li><li>如果 stackOut 为空且 stackIn 不为空，首先需要把 stackIn 中的元素逐个弹出并压入到 stackOut 中，然后返回 stackOut 的栈顶元素即可。</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 首先定义好两个栈</span><br><br>    <span class="hljs-comment">// 一个栈叫做 stackIn，负责进栈操作，相当于队列 queue 中的入队操作</span><br>    Stack&lt;Integer&gt; stackIn;<br>    <span class="hljs-comment">// 一个栈叫做 stackOut，负责出栈操作，相当于队列 queue 中的出队操作</span><br>    Stack&lt;Integer&gt; stackOut;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 在这个函数中初始化两个栈，传入的参数为空，返回也为空</span><br><br>        <span class="hljs-comment">// 初始化 stackIn</span><br>        stackIn = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-comment">// 初始化 stackOut</span><br>        stackOut = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 新添加的元素添加到 stackIn 中</span><br>        stackIn.push(x);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// 如果 stackOut 为空，首先需要将 stackIn 中的所有元素添加到 stackOut 中</span><br>        <span class="hljs-comment">// 注意 stackIn 是栈，栈的性质是先进后出，后进先出，所以是不断的将 stackIn 中的栈顶元素添加进 stackOut 中</span><br>        <span class="hljs-keyword">if</span> (stackOut.isEmpty()) &#123;<br>            <span class="hljs-comment">// 通过 while 循环将 stackIn 中的所有元素都取出</span><br>            <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>                <span class="hljs-comment">// stackOut 不断的添加 stackIn 的栈顶元素</span><br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 此时，stackIn 已经为空，直接「移除」 stackOut 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stackOut.pop();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-comment">// peek 和 pop 的区别在于是返回栈顶元素而非删除栈顶元素</span><br>        <span class="hljs-comment">// 如果 stackOut 为空，首先需要将 stackIn 中的所有元素添加到 stackOut 中</span><br>        <span class="hljs-comment">// 注意 stackIn 是栈，栈的性质是先进后出，后进先出，所以是不断的将 stackIn 中的栈顶元素添加进 stackOut 中</span><br>        <span class="hljs-keyword">if</span> (stackOut.isEmpty()) &#123;<br>            <span class="hljs-comment">// 通过 while 循环将 stackIn 中的所有元素都取出</span><br>            <span class="hljs-keyword">while</span> (!stackIn.isEmpty()) &#123;<br>                <span class="hljs-comment">// stackOut 不断的添加 stackIn 的栈顶元素</span><br>                stackOut.push(stackIn.pop());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// peek 和 pop 的区别在于是返回栈顶元素而非删除栈顶元素</span><br>        <span class="hljs-comment">// 此时，stackIn 已经为空，直接「返回」 stackOut 的栈顶元素</span><br>        <span class="hljs-keyword">return</span> stackOut.peek();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 队列是否为空，判断 stackIn 和 stackOut 是否同时不存在元素</span><br>        <span class="hljs-keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法6[力扣20]-有效的括号</title>
    <link href="/2021/08/05/%E7%AE%97%E6%B3%956-%E5%8A%9B%E6%89%A320-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2021/08/05/%E7%AE%97%E6%B3%956-%E5%8A%9B%E6%89%A320-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>1、左括号必须用相同类型的右括号闭合。</li><li>2、左括号必须以正确的顺序闭合。</li></ul><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>有效的括号满足以下几个条件：</p><ul><li>1、字符串的长度一定是偶数。</li><li>2、括号的匹配<strong>遵循右括号和最近的一个左括号进行匹配</strong>，它们匹配成功才有可能是有效的括号</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 当字符串长度为奇数的时候，属于无效情况，直接返回 false</span><br>        <span class="hljs-keyword">if</span> (s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-comment">// 无效情况，返回 false</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//构建一个栈，用来存储括号</span><br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<br><br>        <span class="hljs-comment">// 把字符串转换为数组的形式，方便获取字符串中的每个字符</span><br>        <span class="hljs-keyword">char</span> charArray[] = s.toCharArray();<br><br>        <span class="hljs-comment">// 遍历字符串数组中的所有元素</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; charArray.length ; i++)&#123;<br><br>            <span class="hljs-comment">// 获取此时的字符</span><br>            <span class="hljs-keyword">char</span> c = charArray[i];   <br><br>            <span class="hljs-comment">// 如果字符为左括号 ( ，那么就在栈中添加对左括号 （</span><br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对左括号 （</span><br>               stack.push(<span class="hljs-string">&#x27;(&#x27;</span>);<br><br>             <span class="hljs-comment">// 如果字符为左括号 [ ，那么就在栈中添加对左括号 [</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对应的右括号 ]</span><br>               stack.push(<span class="hljs-string">&#x27;[&#x27;</span>);<br><br>             <span class="hljs-comment">// 如果字符为左括号 &#123; ，那么就在栈中添加对左括号 &#123;</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br><br>               <span class="hljs-comment">// 添加对应的右括号 &#125;</span><br>               stack.push(<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br><br>               <span class="hljs-comment">// 否则的话，说明此时 c 是 ）] &#125; 这三种符号中的一种</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br><br>               <span class="hljs-comment">// 如果栈已经为空，而现在遍历的字符 c 是 ）] &#125; 这三种符号中的一种</span><br>               <span class="hljs-comment">// 找不到可以匹配的括号，返回 false</span><br>               <span class="hljs-comment">// 比如这种情况  &#125;&#123;，直接从右括号开始，此时栈为空</span><br>               <span class="hljs-keyword">if</span>(stack.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>               <span class="hljs-comment">// 如果栈不为空，获取栈顶元素</span><br>               <span class="hljs-keyword">char</span> top = stack.peek();<br><br>               <span class="hljs-comment">// 将栈顶元素和此时的元素 c 进行比较，如果相同，则将栈顶元素移除</span><br>               <span class="hljs-keyword">if</span>( top == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span> || top == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span> || top == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span> )&#123;<br>                   <span class="hljs-comment">// 移除栈顶元素</span><br>                   stack.pop();<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   <span class="hljs-comment">// 如果不相同，说明不匹配，返回 false</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>               &#125;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-comment">// 遍历完整个字符数组，判断栈是否为空</span><br>        <span class="hljs-comment">// 如果栈为空，说明字符数组中的所有括号都是闭合的</span><br>        <span class="hljs-comment">// 如果栈为空，说明有未闭合的括号</span><br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法5[力扣11]-盛最多水的容器</title>
    <link href="/2021/08/02/%E7%AE%97%E6%B3%955-%E5%8A%9B%E6%89%A311-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/08/02/%E7%AE%97%E6%B3%955-%E5%8A%9B%E6%89%A311-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>一开始，我们先去考虑<strong>相距最远</strong>的两个柱子所能容纳水的面积。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/0gwk7.jpg" alt="1"></p><p>接下来去思考，我们去移动哪根柱子会更加合适?</p><p>这里我们需要注意一点：<strong>无论移动哪根柱子，柱子之间的宽度都是变小的</strong>。</p><p><strong>移动右边那根更高的柱子？</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/94usx.jpg" alt="移动高柱子"></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/gzwnl.jpg" alt="移动高柱字2"></p><p>由于水面高度是由最短的柱子决定的，<strong>所以移动右边那根更高的柱子的时候，水面高度一定是不会增加，甚至有可能遇到更短的柱子而变小，而宽度有一定再减少，所以水的面积也一定减少</strong>。</p><p><strong>移动左边那根更短的柱子？</strong></p><p>这时候，水的高度是不确定的，那么面积也是不确定的，有可能比之前更大，也有可能更小或者相等。</p><p>所以，我们可以得出一个结论：<strong>移动两根柱子之间更短的那根柱子，才有可能在宽度一定变小的情况下，找到一个更高的水面，从而使得面积有可能更大</strong>。</p><p>那接下来这道题目的解法也就有了：</p><p>1、设置两个索引，分别指向容器的两侧，即索引 <code>left</code> 指向最左边的柱子，索引 <code>right</code> 指向最右边的柱子。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/opp73.jpg" alt="移动低柱子"></p><p>2、记录下此时的水的面积，可以定义为 res</p><p>3、<strong>观察需要向内移动哪根柱子</strong></p><ul><li>1）如果移动<strong>较高</strong>的柱子，由于水的宽度在变小，而水的高度一定不会增加，所以最终水的面积不会超过之前记录的水的面积 res</li><li>2）所以，只能移动较短的柱子，然后计算此时水的面积，再与之前记录的水的面积 res 进行比较，保存那个更大的值</li></ul><p>4、再去判断应该向内移动哪根柱子</p><p>5、直到 <code>left</code> 和 <code>right</code> 相遇为止</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br><br>       <span class="hljs-comment">// 设置两个索引，分别指向容器的两侧</span><br><br>       <span class="hljs-comment">// 索引 left 指向最左边的柱子</span><br>       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">// 索引 right 指向最右边的柱子</span><br>       <span class="hljs-keyword">int</span> right = height.length - <span class="hljs-number">1</span>;<br><br>       <span class="hljs-comment">// 设置一个变量用来保存当下水的最大面积</span><br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">// 移动 left 和 right，直到 left 和 right 相遇为止</span><br>       <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><br>           <span class="hljs-comment">// 水的宽度是 right - left</span><br>           <span class="hljs-keyword">int</span> width = right - left;<br><br>           <span class="hljs-comment">// 水的高度由两根柱子最短的那根决定</span><br>           <span class="hljs-keyword">int</span> h = Math.min(height[left],height[right]);<br><br>           <span class="hljs-comment">// 计算此时水的面积</span><br>           <span class="hljs-keyword">int</span> area = width * h;<br><br>           <span class="hljs-comment">// 如果此时水的面积大于了我们之前保存的那个值，我们需要更新一下</span><br>           <span class="hljs-keyword">if</span>(area &gt;= res)&#123;<br>               <span class="hljs-comment">// 更新 res 的值为 area，确保 res 一直都是最大的值</span><br>               res = area;<br>           &#125;<br><br>           <span class="hljs-comment">// 接下来去观察需要移动哪根柱子：必定是最短的那根柱子</span><br><br>           <span class="hljs-comment">// 如果左边的柱子更短，那么向内移动左边的柱子，因为只有这样，才有可能找到一个更高的水面</span><br>           <span class="hljs-comment">// 在宽度一定变小的情况下，水的面积才有可能增大</span><br>           <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>               <span class="hljs-comment">// 向内移动左边的柱子</span><br>               left++;<br><br>           <span class="hljs-comment">// 如果右边的柱子更短，那么向内移动右边的柱子，因为只有这样，才有可能找到一个更高的水面</span><br>           <span class="hljs-comment">// 在宽度一定变小的情况下，水的面积才有可能增大</span><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-comment">// 向内移动右边的柱子</span><br>               right--;<br>           &#125;<br><br>       &#125;<br><br>       <span class="hljs-comment">// 最后返回最大的面积 res 即可</span><br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法4[力扣977]-有序数组的平方</title>
    <link href="/2021/08/02/%E7%AE%97%E6%B3%954-%E5%8A%9B%E6%89%A3977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/2021/08/02/%E7%AE%97%E6%B3%954-%E5%8A%9B%E6%89%A3977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>数组本身是有序的，对于一堆正数来说，平方之后顺序不会发生改变；而对于一堆负数来说，平方之后顺序发生了反转。</p><p>对于夹杂着正数和负数的数组来说，里面的负数平方之后有可能变成最大数。</p><p>所以，数组平方的最大值<strong>在数组的两端</strong>，不是最左边（负数）就是最右边（正数），不可能是中间的数字。</p><p>这样，我们设置两个索引，分别指向数组的两端，比如 <code>left</code> 指向起始位置，<code>right</code> 指向终止位置。</p><p>同时在设置一个新数组 <code>result</code> 用来存放最终的输出结果，让 <code>index</code> 指向 <code>result</code> 数组的终止位置。</p><ul><li>如果 <code>A[left] * A[left] &lt; A[right] * A[right]</code>，说明右边数的平方大于左边数的平方，那么 <code>index</code> 存放的数字是更大的那个数 <code>A[right] * A[right]</code>，并且将 <code>right</code> 向内移动，此时，<code>index</code> 已经放置好了正确的数字，将它向前移动，判断接下来应该放那个数字</li><li>如果 <code>A[left] * A[left] &gt;= A[right] * A[right]</code>，说明左边数的平方大于右边数的平方，那么 <code>index</code> 存放的数字是更大的那个数 <code>A[left] * A[left]</code>，并且将 <code>left</code> 向内移动，此时，<code>index</code> 已经放置好了正确的数字，将它向前移动，判断接下来应该放那个数字</li><li>直到新数组 <code>result</code> 存放了所有的平方数</li></ul><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortedSquares(<span class="hljs-keyword">int</span>[] nums) &#123;<br><br>        <span class="hljs-comment">// 我们设置两个索引，分别指向数组的两端</span><br><br>        <span class="hljs-comment">// right 指向终止位置</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// left 指向起始位置</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置一个新数组 result 用来存放最终的输出结果</span><br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><br>        <span class="hljs-comment">// 让 index 指向 result 数组的终止位置，观察这个位置应该存放什么数字</span><br>        <span class="hljs-keyword">int</span> index = result.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// left 向右移动，right 向左移动，当 left 大于 right 时，说明已经观察遍历了 nums 数组中的所有元素，跳出循环</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><br>            <span class="hljs-comment">// 说明左边的平方数大于右边</span><br>            <span class="hljs-keyword">if</span> (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;<br><br>                <span class="hljs-comment">// result 数组中 index 位置要存放更大的那个数，即 nums[left] * nums[left]</span><br>                result[index] = nums[left] * nums[left];<br><br>                <span class="hljs-comment">// 由于相对较大的数是在 left 位置，上一行代码已经将它赋值到 index 位置</span><br>                <span class="hljs-comment">// 所以此时 left 位置的数已经失去作用，将它向后移动</span><br>                left++;<br><br>                <span class="hljs-comment">// 此时，index 位置已经存放好数，将它向前移动，观察下一个位置应该存放哪个数</span><br>                index--;<br><br>              <span class="hljs-comment">// 说明右边的平方数大于左边</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><br>                <span class="hljs-comment">// result 数组中 index 位置要存放更大的那个数，即 nums[right] * nums[right]</span><br>                result[index] = nums[right] * nums[right];<br><br>                <span class="hljs-comment">// 由于相对较大的数是在 right 位置，上一行代码已经将它赋值到 index 位置</span><br>                <span class="hljs-comment">// 所以此时 right 位置的数已经失去作用，将它向前移动</span><br>                right--;<br><br>                <span class="hljs-comment">// 此时，index 位置已经存放好数，将它向前移动，观察下一个位置应该存放哪个数</span><br>                index--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后返回我们设置的结果数组即可</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法3[力扣16.16]-部分排序</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%953-%E5%8A%9B%E6%89%A316-16-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%953-%E5%8A%9B%E6%89%A316-16-%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个整数数组，编写一个函数，找出索引 m 和 n ，只要将索引区间 [m,n] 的元素排好序，整个数组就是有序的。（默认是递增有序数组）</p><p>注意：n – m 尽量最小，也就是说，找出符合条件的最短序列。</p><p>函数返回值为 [m,n] ，若不存在这样的 m 和 n（例如整个数组是有序的），请返回 [-1,-1] 。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>对于元素 <code>a[i]</code> 来说，如果它左边存在大于 <code>a[i]</code> 的元素，那么 <code>a[i]</code> 是一定要加入到<strong>被排序的序列内</strong>。</p><p>如果它右边存在小于 <code>a[i] 的元素，那么</code>a[i]` 也要加入到<strong>被排序的序列内</strong>。</p><p>所以，我们的目的很明确。</p><p>1、寻找最靠右的那个数，即它的左边存在大于它的数</p><p>2、寻找最靠左的那个数，即它的右边存在小于它的数</p><p><strong>这两个数之间就是要排序的区间</strong>。</p><p>最靠右的数具备以下特征：</p><p>1、它的左边存在大于它的数</p><p>2、它的右边数都比它更大</p><p>3、相对于多个符合 1、2 要求的数，它是最靠右的</p><p>同样的，最靠左的数具备以下特征：</p><p>1、它的右边存在小于它的数</p><p>2、它的左边数都比它更小</p><p>3、相对于多个符合 1、2 要求的数，它是最靠左的</p><h4 id="2-1寻找最左边的数"><a href="#2-1寻找最左边的数" class="headerlink" title="2.1寻找最左边的数"></a>2.1寻找最左边的数</h4><p>它的右侧有一个比它小的时候，他一定在被排序数列中</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/1e2048bcc18dac9c192eb99bffcb39b.png" alt="最左边数"></p><p>此时m值变化，在被排序数列中，继续向左遍历</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/29a0db4fab7d533291ee1ef6ff39466.png" alt="左边的数"></p><p>此时m是最左边的数</p><h4 id="2-2寻找最右边的数"><a href="#2-2寻找最右边的数" class="headerlink" title="2.2寻找最右边的数"></a>2.2寻找最右边的数</h4><p>它左边的数有以一个比它大的时候，他也一定在被排序序列内</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c9837e5a6da0d573e3a91c9dde069f5.png" alt="最右边"></p><p>此时m值变化，继续向右遍历</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/bd3eb1ead543ce1ea6aa589c2981584.png" alt="最右边的数"></p><p>此时n是最右边的数</p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] subSort(<span class="hljs-keyword">int</span>[] array) &#123;<br><br>        <span class="hljs-comment">// 如果数组为空、或者数组没有元素、或者数组只有一个元素，找不出符合要求的序列，根据题目要求返回 [-1,-1]</span><br>        <span class="hljs-keyword">if</span>(array == <span class="hljs-keyword">null</span> || array.length == <span class="hljs-number">0</span> || array.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><br>        <span class="hljs-comment">// 正常来说，整个数组是递增有序的，比如 1 3 5 9 10 这种</span><br>        <span class="hljs-comment">// 如果某个元素的左边存在比它更大的元素，比如  1 10 5  </span><br>        <span class="hljs-comment">// 5 这个元素的左边存在 10 这个元素比它更大，一定 5 要参与到排序里去的</span><br><br>        <span class="hljs-comment">// 如果某个元素的右边存在比它更小的元素，比如  1 10 5  </span><br>        <span class="hljs-comment">// 10 这个元素的右边存在 5 这个元素比它更小，所以 10 一定要参与到排序里去的</span><br><br>        <span class="hljs-comment">// 所以我们只需要寻找最靠右的那个数（满足左边存在大于它的数）</span><br>        <span class="hljs-comment">// 和最靠左的那个数（满足右边存在小于它的数）</span><br>        <span class="hljs-comment">// 那么这两个数之间就是要排序的区间了</span><br><br>        <span class="hljs-comment">// 第一次遍历是从尾到头进行遍历，目的是为了找出最靠左的那个数，即满足右边存在小于它的数</span><br><br>        <span class="hljs-comment">// 一开始默认最右边的数为最小值</span><br>        <span class="hljs-keyword">int</span> min = array[array.length - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 默认找不到的情况下 m 为 -1</span><br>        <span class="hljs-keyword">int</span> m = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从尾到头进行遍历，直到遍历到数组的开始位置</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = array.length - <span class="hljs-number">2</span> ; j &gt;= <span class="hljs-number">0</span> ; j-- )&#123;<br>            <span class="hljs-comment">// 获取当前遍历的元素值</span><br>            <span class="hljs-keyword">int</span> cur = array[j] ;<br>            <span class="hljs-comment">// 如果此时当前的元素值小于等于最小值，需要更新最小值</span><br>            <span class="hljs-keyword">if</span>(cur &lt;= min)&#123;<br>                <span class="hljs-comment">// 更新最小值</span><br>                min = cur;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果当前元素大于了最小值，由于我们是从尾到头进行遍历，说明当前元素的右边存在小于它的数，这个元素需要加入到排序的区间</span><br>                <span class="hljs-comment">// 比如  10 9 7</span><br>                <span class="hljs-comment">// 最小值是 7 ，而 9 大于 7，所以 9 需要加入到排序的区间</span><br>                <span class="hljs-comment">// 因此更新 m 的值为 j，说明此时遍历的那些元素中 j 是最靠左的那个数</span><br>                m = j;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 第二次遍历是从尾到头进行遍历，目的是为了找出最靠右的那个数，即满足左边存在大于它的数</span><br><br>        <span class="hljs-comment">// 一开始默认最左边的数为最大值</span><br>        <span class="hljs-keyword">int</span> max = array[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 默认找不到的情况下 n 为 -1</span><br>        <span class="hljs-keyword">int</span> n = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从头进行遍历，直到遍历到数组的结束位置</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; array.length ; i++ )&#123;<br>            <span class="hljs-comment">// 获取当前遍历的元素值</span><br>            <span class="hljs-keyword">int</span> cur = array[i] ;<br>            <span class="hljs-comment">// 如果此时当前的元素值大于等于最大值，需要更新最大值</span><br>            <span class="hljs-keyword">if</span>(cur &gt;= max)&#123;<br>                <span class="hljs-comment">// 更新最大值</span><br>                max = array[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 如果当前元素小于了最大值，由于我们是从头到尾进行遍历，说明当前元素的左边存在大于它的数，这个元素需要加入到排序的区间</span><br>                <span class="hljs-comment">// 比如  10 9 7</span><br>                <span class="hljs-comment">// 最小值是 10 ，而 7 小于 10，所以 7 需要加入到排序的区间</span><br>                <span class="hljs-comment">// 因此更新 n 的值为 i，说明此时遍历的那些元素中 i 是最靠右的那个数</span><br>                n = i;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// m 和 n 这两个数之间就是要排序的区间，返回即可</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;m,n&#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法2[力扣75]-颜色分类</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%952-%E5%8A%9B%E6%89%A375-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%952-%E5%8A%9B%E6%89%A375-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<strong>原地对它们进行排序</strong>，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>设置 3 个索引，<code>left</code> 指向数组的开始位置，<code>right</code> 指向数组的结束位置，<code>index</code> 指向数组的开始位置。</p><p>我们让 <code>index</code> 从头开始向后移动，在移动的过程中，它指向的元素会出现三种情况：</p><ul><li>如果 <code>index</code>位置上的元素值为 0，则说明是红色，要放在<strong>最前面</strong>去，此时最前面的那个元素被 <code>left</code> 指着，所以让 <code>index</code> 指向的元素和 <code>left</code> 指向位置上的元素进行交换，<strong>交换完毕之后</strong>，说明 0 已经在它应该在的位置，即在整个数组的左区域，所以 <code>left</code> 可以向后移动，<code>index</code> 也向后移动</li><li>如果若 <code>index</code> 位置上的元素值为 1，则说明是白色，就应该放在中间，不用管它，继续移动 <code>index</code></li><li>如果 <code>index</code> 位置上的元素值为 2，则说明是蓝色，要放在<strong>最后面</strong>，此时<strong>最后面</strong>的那个元素被 <code>right</code> 指着，所以让 <code>index</code> 指向的元素和 <code>right</code> 指向位置上的元素进行交换，<strong>交换完毕之后</strong>，说明 2 已经在它改在的位置，即在整个数组的右区域，<code>right</code> 向前移动，但由于原先 <code>right</code> 指向的元素可能为 0、1、2 这三种的任何一种，到了 <code>index</code> 后，还需要继续观察一轮，所以 <code>index</code> 先不移动</li></ul><h3 id="三、参考代码"><a href="#三、参考代码" class="headerlink" title="三、参考代码"></a>三、参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-comment">// left  指向数组的开始的位置，它指向的位置左侧都是 0</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// right  指向数组的结束的位置，它指向的位置右侧都是 2</span><br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// index 指向数组的开始位置</span><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// index 向后移动，当它越过 right 时跳出循环，不需要再判断了</span><br>        <span class="hljs-comment">// 因为此时说明 index 右侧的都已经是 2</span><br>        <span class="hljs-keyword">while</span>(index &lt;= right)&#123;<br><br>            <span class="hljs-comment">// 获取当前的元素值</span><br>            <span class="hljs-keyword">int</span> cur = nums[index];<br><br>            <span class="hljs-comment">// 如果 index 位置上的元素值为 0</span><br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-comment">// 说明是红色，要放在最前面去</span><br>              <span class="hljs-comment">// 最前面的那个元素被 left 指着，所以让 index 指向的元素和 left 指向位置上的元素进行交换</span><br>              swap(nums,left,index);<br><br>              <span class="hljs-comment">// index 可以向后移动</span><br>              index++;<br>              <span class="hljs-comment">// left 可以向后移动，它的左侧区域都是 0</span><br>              left++;<br><br>              <span class="hljs-comment">// 如果 index 位置上的元素值为 1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// 说明是白色，就应该放在中间，不用管它，继续移动 index</span><br>                index++;<br><br>                <span class="hljs-comment">// 如果 index 位置上的元素值为 2</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">2</span>)&#123;<br><br>                <span class="hljs-comment">// 说明是蓝色，要放在最后面</span><br>                <span class="hljs-comment">// 所以让 index 指向的元素和 right 指向位置上的元素进行交换</span><br>                swap(nums,index,right);<br><br>                <span class="hljs-comment">// 由于原先 right 指向的元素可能为 0、1、2 这三种的任何一种</span><br>                <span class="hljs-comment">// 交换到了 index 后，还需要继续观察一轮，所以 index 先不移动</span><br>                right--;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 通过中间变量，交换两个元素的值</span><br>    <span class="hljs-comment">// nums[i] 的值变为了 nums[j] 的值 </span><br>    <span class="hljs-comment">// nums[j] 的值变为了 nums[i] 的值 </span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i ,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">// 使用临时变量 temp，保存 nums[i] 的值</span><br>        <span class="hljs-keyword">int</span> temp = nums[i];<br><br>        <span class="hljs-comment">// nums[i] 的值修改为 nums[j] 的值</span><br>        nums[i] = nums[j];<br><br>        <span class="hljs-comment">// nums[i] 的值修改为 temp 的值</span><br>        nums[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法1[力扣88]-合并两个有序数组</title>
    <link href="/2021/07/31/%E7%AE%97%E6%B3%951-%E5%8A%9B%E6%89%A388-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2021/07/31/%E7%AE%97%E6%B3%951-%E5%8A%9B%E6%89%A388-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>nums1</code> 成为一个<strong>有序数组</strong>。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 m 和 n 。</p><p>你可以假设 <code>nums1</code> 的空间大小等于 m + n，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><h3 id="二、题目解析"><a href="#二、题目解析" class="headerlink" title="二、题目解析"></a>二、题目解析</h3><p>设置两个索引 <code>i</code> 和 <code>j</code> 分别指向 nums1 和 nums2 的有效元素的尾部，从它们的尾部开始向前遍历，同时设置索引 <code>cur</code> 指向 <code>nums1</code> 的<strong>最末尾</strong>，在每次遍历过程中，比较 <code>i</code> 和 <code>j</code> 指向的元素值大小，把大的元素填充到 <code>cur</code> 的位置，填充完毕说明那个元素已经放置在它应该放置的位置，不需要在管它了，把 <code>cur</code> 向前移动，同时把 <code>i</code> 或者 <code>j</code> 向前移动，继续比较 <code>i</code> 和 <code>j</code> 指向的元素值大小，把大的元素填充到 <code>cur</code> 的位置。</p><h3 id="2-1初始化数组"><a href="#2-1初始化数组" class="headerlink" title="2.1初始化数组"></a>2.1初始化数组</h3><p>设置两个索引 <code>i</code> 和 <code>j</code> 分别指向 nums1 和 nums2 的有效元素的尾部，从它们的尾部开始向前遍历，同时设置索引 <code>cur</code> 指向 <code>nums1</code> 的<strong>最末尾</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c155109372f4e152dcc4a5ef6713396.png" alt="初始化数组"></p><h4 id="2-2比较索引值的大小"><a href="#2-2比较索引值的大小" class="headerlink" title="2.2比较索引值的大小"></a>2.2比较索引值的大小</h4><h5 id="Ⅰ-当i-lt-j时，将j的值赋值给cur，同时j–，cur–"><a href="#Ⅰ-当i-lt-j时，将j的值赋值给cur，同时j–，cur–" class="headerlink" title="Ⅰ.当i&lt;j时，将j的值赋值给cur，同时j–，cur–"></a>Ⅰ.当i&lt;j时，将j的值赋值给cur，同时j–，cur–</h5><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/c2b1a5e394e191456d23267e951b9fc.png" alt="i&lt;j"></p><h5 id="Ⅱ-当i-gt-j时，将i的值赋值给cur，同时i–，cur–"><a href="#Ⅱ-当i-gt-j时，将i的值赋值给cur，同时i–，cur–" class="headerlink" title="Ⅱ.当i &gt;j时，将i的值赋值给cur，同时i–，cur–"></a>Ⅱ.当i &gt;j时，将i的值赋值给cur，同时i–，cur–</h5><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/08/79097048f87a74ddd14e51d294249d5.png" alt="i&gt;j"></p><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 索引从有序数组 nums1 有效元素的末端开始</span><br>        <span class="hljs-comment">// 数组的下标索引从零开始计数</span><br>        <span class="hljs-comment">// 索引   0    1     2</span><br>        <span class="hljs-comment">// 数组 [ 1 ,  2  ,  3 ]</span><br>        <span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 索引从有序数组 nums2 的末端开始</span><br>        <span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 从有序数组 nums1 最末端的位置开始保存元素</span><br>        <span class="hljs-keyword">int</span> cur = nums1.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 通过循环把 num2 的元素都移动到 num1 中</span><br>        <span class="hljs-keyword">while</span>( j &gt;= <span class="hljs-number">0</span>  )&#123;<br><br>            <span class="hljs-comment">// 比较 num1 和 num2 中当前的元素大小</span><br><br>            <span class="hljs-comment">// 如果 num1 中的索引位置为 i 的元素大于 num2 中索引位置为 j 的元素</span><br>            <span class="hljs-comment">// 为了防止越界 i 必须是大于等于 0 </span><br>            <span class="hljs-keyword">if</span>( i &gt;=<span class="hljs-number">0</span> &amp;&amp; nums1[i] &gt; nums2[j] )&#123;<br><br>             <span class="hljs-comment">// 把 num1 中的索引位置为 i 的元素复制到索引为 cur 的位置</span><br>             <span class="hljs-comment">// 此时 cur 的元素已经确定下来</span><br>             nums1[cur] = nums1[i];<br><br>             <span class="hljs-comment">// 接下来去确定 cur 前面一个元素应该放什么数字</span><br>             cur--;<br>             <span class="hljs-comment">// 此时，索引 i 需要向前移动</span><br>             i--;<br>             <span class="hljs-comment">// 否则，如果 num1 中的索引位置为 i 的元素小于或者等于 num2 中索引位置为 j 的元素</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>             <span class="hljs-comment">// 把 num2 中的索引位置为 j 的元素复制到索引为 cur 的位置</span><br>             nums1[cur] = nums2[j];<br>             <span class="hljs-comment">// 接下来去确定 cur 前面一个元素应该放什么数字</span><br>             cur--;<br>             <span class="hljs-comment">// 此时，索引 j 需要向前移动</span><br>             j--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记2</title>
    <link href="/2021/06/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2021/06/29/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h3 id="一、直接内存"><a href="#一、直接内存" class="headerlink" title="一、直接内存"></a>一、直接内存</h3><h4 id="1-Direct-Memory"><a href="#1-Direct-Memory" class="headerlink" title="1.Direct Memory"></a>1.Direct Memory</h4><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-直接内存的基本使用"><a href="#2-直接内存的基本使用" class="headerlink" title="2.直接内存的基本使用"></a>2.直接内存的基本使用</h4><p><strong>文件读写流程：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210629101348239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="文件读写流程"></p><p>java本身不具备磁盘读写的能力，需要调用操作系统的本地方法(用户态——&gt;内核态)。转换到内核态之后读取磁盘文件，会在系统内存中创建一个缓存区，将数据读到内存缓存区，最后再将系统缓存区数据复制到java堆内存中。</p><p>这个缺点是数据存储了两份，在系统内存中有一份，java堆内存中有一份，造成了不必要的复制。</p><p><strong>使用DirectBuffer文件读取流程</strong></p><p><img src="https://img-blog.csdnimg.cn/20210629101710200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="DirectBuffer读取文件"></p><p>在调用directbuffer的allocateDirect方法时，会在操作系统里划出一个缓冲区(direct memory)，能够使操作系统和java代码共享访问，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h4 id="3-直接内存回收原理"><a href="#3-直接内存回收原理" class="headerlink" title="3.直接内存回收原理"></a>3.直接内存回收原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectMemory</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1GB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException </span>&#123;<br><span class="hljs-comment">//        method();</span><br>        method1();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 直接内存 是被 unsafe 创建与回收</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException </span>&#123;<br><br>        Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        Unsafe unsafe = (Unsafe)field.get(Unsafe.class);<br><br>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1GB);<br>        unsafe.setMemory(base,_1GB, (<span class="hljs-keyword">byte</span>)<span class="hljs-number">0</span>);<br>        System.in.read();<br><br>        unsafe.freeMemory(base);<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 直接内存被 释放</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 手动 gc</span><br>        System.in.read();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>直接内存的回收不是通过JVM的垃圾回收来释放的，而是要通过unsafe的freeMemory方法来手动释放。</strong></p><p>第一步：allocateDirect的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>底层创建了一个DirectByteBuffer对象</p><p>第二步：DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">// 申请内存</span><br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span><br>    att = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个 Cleaner 的 create 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是 DirectByteBuffer ）被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 都用函数的 run 方法, 释放内存</span><br>               <span class="hljs-keyword">this</span>.thunk.run();<br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();<br>                       &#125;<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   &#125;<br>               &#125;);<br>           &#125;<br><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到关键的一行代码， this.thunk.run()，thunk 是 Runnable 对象。run 方法就是回调 Deallocator 中的 run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-comment">// Paranoia</span><br>              <span class="hljs-keyword">return</span>;<br>          &#125;<br>          <span class="hljs-comment">// 释放内存</span><br>          unsafe.freeMemory(address);<br>          address = <span class="hljs-number">0</span>;<br>          Bits.unreserveMemory(size, capacity);<br>      &#125;<br></code></pre></td></tr></table></figure><p> <strong>直接内存的回收机制总结</strong></p><ul><li>使用了unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner(虚引用)来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler（守护线程）来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p><strong>注意</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * -XX:+DisableExplicitGC 显示的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);<br>        System.out.println(<span class="hljs-string">&quot;分配完毕&quot;</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;开始释放&quot;</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 手动 gc 失效</span><br>        System.in.read();<br>    &#125;<br></code></pre></td></tr></table></figure><p>一般用jvm调优时，会加上下面的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+DisableExplicitGC  <span class="hljs-comment">// 静止显示的 GC</span><br></code></pre></td></tr></table></figure><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p><h3 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h3><h4 id="1-判断对象是否可以回收"><a href="#1-判断对象是否可以回收" class="headerlink" title="1.判断对象是否可以回收"></a>1.判断对象是否可以回收</h4><p><strong>1.1引用计数法</strong></p><p>当一个对象被引用一次时，将计数加一，如果不在引用了，则让计数减一。当对象的引用计数为0时，可以被垃圾对象回收。</p><p>但是这种方法有一个弊端，循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。造成内存泄露</p><p><img src="https://img-blog.csdnimg.cn/20210629145523179.png" alt="引用计数法弊端"></p><p><strong>1.2可达性分析算法</strong></p><ul><li>JVM中的垃圾回收器通过可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象作为起点的引用链接找到该对象，如果找不到，则表示可以回收</li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native的方法）引用的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;b&quot;</span>);<br>        list.add(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-number">1</span>);<br>        System.in.read();<br><br>        list = <span class="hljs-keyword">null</span>;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以使用如下命令将堆内存信息转储成一个文件，然后使用<br>Eclipse Memory Analyzer 工具进行分析。</p><p>1.使用jps命令，查看程序的进程</p><p><img src="https://img-blog.csdnimg.cn/20210209111015399.png" alt="1.jps"></p><p>2.</p><p><img src="https://img-blog.csdnimg.cn/20210209111229838.png" alt="2"></p><p>使用 jmap -dump:format=b,live,file=1.bin 16104 命令转储文件<br>dump：转储文件<br>format=b：二进制文件<br>file：文件名<br>16104：进程的id</p><p>3.打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析。</p><p><img src="https://img-blog.csdnimg.cn/20210209111656952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="3"></p><p>分析的 gc root，找到了 ArrayList 对象，然后将 list 置为null，再次转储，那么 list 对象就会被回收。</p><p><strong>1.3四种引用</strong></p><p>1）强引用</p><p>2）软引用</p><p>3）弱引用</p><p>4）虚引用</p><p>5）终结器引用</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/ee9e00ff99fecf43b55497950fc6b88.png" alt="四种引用"></p><p>1.强引用</p><p>只要所有的GC Root对象都不通过<strong>强引用</strong>引用该对象，该对象才能被垃圾回收</p><p>2.软引用</p><p><strong>没有直接的被强引用引用时，当垃圾回收后，内存不够时</strong>会再次垃圾回收，回收软引用对象</p><p>可以配合引用队列来释放引用对象</p><p>3.弱引用</p><p><strong>没有直接的被强引用引用时，只要发生了垃圾回收，无论内存是否充足</strong>，都会回收弱引用对象</p><p>可以配合引用队列来释放引用对象</p><p>4.虚引用</p><p>主要配合ByteBuffer使用，被引用对象回收时，会将虚引用进入引用队列，在由Reference Handler线程调用虚引用相关方法释放直接内存</p><p><strong>必须配合队列引用队列使用</strong></p><p>5.终结器引用</p><p><strong>无需手动编码，其内部配合引用队列使用</strong>，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalize线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象。</p><h6 id="演示软引用"><a href="#演示软引用" class="headerlink" title="演示软引用"></a>演示软引用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoSoft</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        method2();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 -Xmx20m , 演示堆内存不足,</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>        &#125;<br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 软引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;循环结束：&quot;</span> + list.size());<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>method1方法:</p><p>先设置一个堆内存的大小为20m，然后运行 mehtod1 方法，会抛异常，堆内存不足，因为 mehtod1 中的 list 都是强引用。</p><p><img src="https://img-blog.csdnimg.cn/20210209125537878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="强引用"></p><p>method2方法:</p><p>在 list 集合中存放了 软引用对象，当内存不足时，会触发 full gc，将软引用的对象回收。细节如图：</p><p><img src="https://img-blog.csdnimg.cn/20210209130334776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="软引用对象"></p><p>当软引用引用的对象被回收了，但是软引用还存在，所以，一般软引用需要搭配一个引用队列一起使用</p><p>修改method2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 演示 软引用 搭配引用队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 关联了引用队列，当软引用所关联的 byte[] 被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br>        <span class="hljs-keyword">for</span>(SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) &#123;<br>            System.out.println(ref.get());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210209140627985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="结果"></p><h6 id="弱引用演示"><a href="#弱引用演示" class="headerlink" title="弱引用演示"></a>弱引用演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_09_WeakReferenceTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        method1();</span><br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> *<span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// 演示 弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(weakReference);<br><br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 演示 弱引用搭配 引用队列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            list.add(weakReference);<br>            <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>                System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===========================================&quot;</span>);<br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span> (poll != <span class="hljs-keyword">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; wake : list) &#123;<br>            System.out.print(wake.get() + <span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h4><p><strong>2.1标记清除</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/fe4c2ccf00be3e57ee83dd295024627.png" alt="标记清除"></p><p>优点</p><ul><li>速度较快</li></ul><p>缺点</p><ul><li>会产生内存碎片</li></ul><p><strong>2.2标记整理</strong></p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/008510919468859c938504cf17749f7.png" alt="标记整理"></p><p>优点</p><ul><li>没有内存片</li></ul><p>缺点</p><ul><li>速度慢</li></ul><p><strong>2.3复制</strong></p><p><img src="https://img-blog.csdnimg.cn/20210209144026784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt=" 复制"></p><p>优点</p><ul><li>不会有内存碎片</li></ul><p>缺点</p><ul><li>需要占用两倍内存空间</li></ul><h4 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h4><p><img src="https://img-blog.csdnimg.cn/20210209161407621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="分代回收"></p><p>机制</p><ul><li>新创建的对象分配到伊甸园（Eden）区</li><li>当新生代空间不足时，会触发minor gc，伊甸园区（Eden）和幸存区中的from区存活的对象使用<strong>复制</strong>方法复制到幸存区中的to区中，存货对象年龄加一，然后再交换from和to区位置</li><li>minor gc会引发stop the world，暂停其他线程，等待垃圾回收结束后，在恢复线程运行</li><li>当幸存区中的对象年龄超过阈值时（最大为15 （4bit）），会晋升为老年代</li><li>当老年代空间不足时，会先触发minor gc，如果空间仍然不足，则触发full gc，但STW停止的时间更长。</li></ul><p><strong>3.1相关JVM参数</strong></p><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center">-Xms</td></tr><tr><td align="center">堆最大大小</td><td align="center">-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td align="center">新生代大小</td><td align="center">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td align="center">幸存区比例（动态）</td><td align="center">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td align="center">幸存区比例</td><td align="center">-XX:SurvivorRatio=ratio</td></tr><tr><td align="center">晋升阈值</td><td align="center">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td align="center">晋升详情</td><td align="center">-XX:+PrintTenuringDistribution</td></tr><tr><td align="center">GC详情</td><td align="center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td align="center">FullGC 前 MinorGC</td><td align="center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><p><strong>3.2gc分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_10_GCTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _512KB = <span class="hljs-number">512</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _6MB = <span class="hljs-number">6</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _7MB = <span class="hljs-number">7</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _8MB = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">// -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;<span class="hljs-keyword">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_512KB]);<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_6MB]);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，给 list 分配内存，来观察 新生代和老年代的情况，什么时候触发 minor gc，什么时候触发 full gc 等情况，使用前需要设置 jvm 参数。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="/2021/06/10/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/10/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、JVM是什么"><a href="#一、JVM是什么" class="headerlink" title="一、JVM是什么"></a>一、JVM是什么</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>Java Virtual Machine ，Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）。</p><h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h4><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h4 id="3-JVM、JDK、JRE的关系"><a href="#3-JVM、JDK、JRE的关系" class="headerlink" title="3.JVM、JDK、JRE的关系"></a>3.JVM、JDK、JRE的关系</h4><p><img src="https://img-blog.csdnimg.cn/20210207154634171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="JVM、JDK、JRE的关系"></p><h4 id="4-学习路线"><a href="#4-学习路线" class="headerlink" title="4.学习路线"></a>4.学习路线</h4><p><img src="https://img-blog.csdnimg.cn/20210207155820178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" alt="学习路线"></p><ul><li>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</li><li>Method Area：类是放在方法区中。</li><li>Heap：类的实例对象。</li></ul><p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p><h3 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h3><h4 id="Ⅰ-程序计数器"><a href="#Ⅰ-程序计数器" class="headerlink" title="Ⅰ.程序计数器"></a>Ⅰ.程序计数器</h4><p>Program Counter Register 程序计数器（寄存器）</p><p><strong>作用</strong> 记录下一条jvm指令的执行地址行号</p><p><strong>特点</strong> </p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">0: getstatic #20 // PrintStream out = System.out; <br><span class="hljs-number">3</span>: astore_1 <span class="hljs-comment">// -- </span><br><span class="hljs-number">4</span>: aload_1 <span class="hljs-comment">// out.println(1); </span><br><span class="hljs-number">5</span>: iconst_1 <span class="hljs-comment">// -- </span><br>6: invokevirtual #26 // -- <br><span class="hljs-number">9</span>: aload_1 <span class="hljs-comment">// out.println(2); </span><br><span class="hljs-number">10</span>: iconst_2 <span class="hljs-comment">// -- </span><br>11: invokevirtual #26 // -- <br><span class="hljs-number">14</span>: aload_1 <span class="hljs-comment">// out.println(3); </span><br><span class="hljs-number">15</span>: iconst_3 <span class="hljs-comment">// -- </span><br>16: invokevirtual #26 // -- <br><span class="hljs-number">19</span>: aload_1 <span class="hljs-comment">// out.println(4); </span><br><span class="hljs-number">20</span>: iconst_4 <span class="hljs-comment">// -- </span><br>21: invokevirtual #26 // -- <br><span class="hljs-number">24</span>: aload_1 <span class="hljs-comment">// out.println(5); </span><br><span class="hljs-number">25</span>: iconst_5 <span class="hljs-comment">// -- </span><br>26: invokevirtual #26 // -- <br><span class="hljs-number">29</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</li></ul><h4 id="Ⅱ-虚拟机栈"><a href="#Ⅱ-虚拟机栈" class="headerlink" title="Ⅱ.虚拟机栈"></a>Ⅱ.虚拟机栈</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><p><img src="https://img-blog.csdnimg.cn/2021062110122114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="栈"></p><h5 id="2-代码演示"><a href="#2-代码演示" class="headerlink" title="2.代码演示"></a>2.代码演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        method1();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        method2(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = a + b;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>演示效果</p><p><img src="https://img-blog.csdnimg.cn/20210610175334410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>问题解析</strong></p><ol><li><p>垃圾回收是否涉及栈内存？</p><ul><li>不会，栈内存是方法调用产生的，方法调用结束后会自动弹出栈。</li></ul></li><li><p>栈内存分配越大越好吗？</p><ul><li>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。例如物理内存500M 一个线程占用1M 可以运行500个线程，如果改为2M，则运行250个线程。</li></ul></li><li><p>方法内的局部变量是否线程安全？</p><ul><li><p><strong>如果方法内局部变量没用逃离方法的作用访问，它是线程安全的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>StringBuilder是线程内的一个局部变量，属于每个线程私有的，其他线程不能同时访问</li></ul></li><li><p><strong>如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(StringBuilder sb)</span></span>&#123;<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>StringBuilder对象是作为方法的参数传递进来，有可能有其他的线程能访问到他。需要改成StringBuffer来保证线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>&#123;<br>  StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>  sb.append(<span class="hljs-number">1</span>);<br>  sb.append(<span class="hljs-number">2</span>);<br>  sb.append(<span class="hljs-number">3</span>);<br>  System.out.println(sb.toString());<br>  <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虽然SrtingBuilder是方法内的局部变量，但是把它当初返回结果返回了，这就意味着其他线程可能会拿到这个对象的引用。</li></ul></li></ul></li></ol><h5 id="3-栈内存溢出"><a href="#3-栈内存溢出" class="headerlink" title="3.栈内存溢出"></a>3.栈内存溢出</h5><ol><li>栈帧过多导致内存溢出（递归调用太多）</li></ol><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/49MBC%25%60QS%7BYDUK%7EZ822J%7BQH.png" alt="栈内存溢出1"></p><ol start="2"><li><p>栈帧过大导致内存溢出</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/05/06/B6EFD%5DJ6XL1S%5DFF184YQK%281.png" alt="栈内存溢出2"></p><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小</p><h4 id="4-线程运行诊断"><a href="#4-线程运行诊断" class="headerlink" title="4.线程运行诊断"></a>4.线程运行诊断</h4><p>[案例1]：CPU占用太多</p><p>Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><p><strong>解决方法</strong></p><ul><li>top 命令，查看是哪个进程占用 CPU 过高</li><li>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</li><li>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</li></ul><p>[案例2]：程序运行很长时间没有结果</p><p>多个线程发生死锁</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/P%5DYL2PNK%25WQ0W4D_8%5D%60%28%29FT.png" alt="死锁"></p><p>​</p></li></ol><h4 id="Ⅲ-本地方法栈"><a href="#Ⅲ-本地方法栈" class="headerlink" title="Ⅲ.本地方法栈"></a>Ⅲ.本地方法栈</h4><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h4 id="Ⅳ-堆"><a href="#Ⅳ-堆" class="headerlink" title="Ⅳ.堆"></a>Ⅳ.堆</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>Heap 堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li></ul><p><strong>特点</strong></p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h5 id="2-堆内存溢出"><a href="#2-堆内存溢出" class="headerlink" title="2.堆内存溢出"></a>2.堆内存溢出</h5><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出，可以使用 -Xmx8m 来指定堆内存大小。</p><h5 id="3-堆内存诊断"><a href="#3-堆内存诊断" class="headerlink" title="3.堆内存诊断"></a>3.堆内存诊断</h5><ul><li>jps工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li>jmap工具<ul><li>查看堆内存占用情况 jmap - heap 进程id</li></ul></li><li>jconsole工具<ul><li>图形界面的，多功能的检测工具，可以连续监测</li></ul></li><li>jvisualvm 工具</li></ul><h4 id="Ⅴ-方法区"><a href="#Ⅴ-方法区" class="headerlink" title="Ⅴ.方法区"></a>Ⅴ.方法区</h4><h5 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h5><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p><h5 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h5><p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/G9%2817Z%2462XV0JK5RNTC3GL7.png" alt="Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图"></p><h5 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h5><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h5 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h5><p>二进制字节码包含（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）<br>首先看看常量池是什么，编译如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用javap -v Hello.class 命令反编译查看结果。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/53Q%281%609K_UN%7D%29%24RTS%7BF%28R%7DA.png" alt="编译结果"></p><p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p><p><img src="https://leonde.oss-cn-beijing.aliyuncs.com/2021/06/%5DK13P%7E3%24RJJ%40XWT01NFNSL0.png" alt="常量池"></p><ul><li><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li><li><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul><h5 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h5><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><p><strong>intern方法 1.8</strong><br>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li><p>如果串池中没有该字符串对象，则放入成功</p></li><li><p>如果有该字符串对象，则放入失败</p><p>无论放入是否成功，都会返回串池中的字符串对象</p></li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p>[案例1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span><br>String st2 = str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>[案例2]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span><br>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span><br>String str2 = str.intern();<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">// true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试案例题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// ab</span><br>        String s4 = s1 + s2; <span class="hljs-comment">// new String(&quot;ab&quot;)</span><br>        String s5 = <span class="hljs-string">&quot;ab&quot;</span>;<br>        String s6 = s4.intern();<br><br>        <span class="hljs-comment">//=====================问======================//</span><br>        System.out.println(s3 == s4); <span class="hljs-comment">//false</span><br>        System.out.println(s3 == s5); <span class="hljs-comment">//true</span><br>        System.out.println(s3 == s6); <span class="hljs-comment">//true</span><br><br><br>        String x2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;d&quot;</span>);<br>        String x1 = <span class="hljs-string">&quot;cd&quot;</span>;<br>        x2.intern();<br><br>        <span class="hljs-comment">//=======问 如果调换x1，x2位置?,如果是jdk1.6?======//</span><br>        System.out.println(x1 == x2); <span class="hljs-comment">//false</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>s3为常量字符串拼接，在编译器优化为ab，此时常量池没有ab，会入池。s4为两个变量的拼接，在运行期间通过StringBulider进行拼接，最后产生新的字符串放在堆中(new String(“ab”))。 </p><p><strong>String Table的位置</strong></p><p>jdk1.6中 String Table在永久代中，jdk1.8 String Table在堆中</p><p><strong>String Table垃圾回收</strong></p><ul><li>Xmx10m –&gt; 指定堆内存大小</li><li>XX:+PrintStringTableStatistics –&gt;打印字符串常量池信息</li><li>XX:+PrintGCDetails</li><li>verbose:gc –&gt;打印 gc 的次数，耗费时间等信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_05_StringTableTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123; <span class="hljs-comment">// j = 100, j = 10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>String Table内存调优</strong></p><p>因为String Table是HashTable实现的，可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</p><p>-XX:StringTableSize=桶个数（最少设置为 1009 以上）</p><ul><li>考虑是否需要将字符串对象入池，可以通过 intern 方法减少重复入池</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记5 集合类的一些常见问题</title>
    <link href="/2021/04/27/Java%E7%AC%94%E8%AE%B05-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/27/Java%E7%AC%94%E8%AE%B05-%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="headerlink" title="使用集合框架的好处"></a>使用集合框架的好处</h3><ol><li>容量自增长</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="java集合的快速失败机制“fail-fast”？"><a href="#java集合的快速失败机制“fail-fast”？" class="headerlink" title="java集合的快速失败机制“fail-fast”？"></a>java集合的快速失败机制“fail-fast”？</h3><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变操作时，有可能会产生fail-fast机制</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p><strong>原因</strong>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发送变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>解决办法</strong></p><ol><li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized</li><li>使用CopyOnWriteArrayList来替换ArrayList</li></ol><h3 id="怎么确保一个集合不能被修改"><a href="#怎么确保一个集合不能被修改" class="headerlink" title="怎么确保一个集合不能被修改"></a>怎么确保一个集合不能被修改</h3><p>可以使用Collections.unmodifiableCollection(Collection c)方法来创建一个只读集合，这样改变集合的任何操作都会抛出Java.lang.UnsupportedOperationException异常</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;x&quot;</span>);<br>Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);<br>clist.add(<span class="hljs-string">&quot;y&quot;</span>);<span class="hljs-comment">//运行此行时报错</span><br>System.out.println(list.size());<br></code></pre></td></tr></table></figure><h3 id="迭代器Iterator是什么"><a href="#迭代器Iterator是什么" class="headerlink" title="迭代器Iterator是什么"></a>迭代器Iterator是什么</h3><p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration，迭代器允许调用者在迭代过程中移除元素</p><h4 id="1-Iterator怎么使用，有什么特点"><a href="#1-Iterator怎么使用，有什么特点" class="headerlink" title="1.Iterator怎么使用，有什么特点"></a>1.Iterator怎么使用，有什么特点</h4><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  String obj = it.next();<br>  System.out.println(obj)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><p>Iterator的特点是只能单向遍历，但是更加安全，它可以确保在当前遍历的集合元素被更改的时候，会抛出 ConcurrentModificationException 异常。</p><h4 id="2-Iterator和Listiterator有什么区别"><a href="#2-Iterator和Listiterator有什么区别" class="headerlink" title="2.Iterator和Listiterator有什么区别"></a>2.Iterator和Listiterator有什么区别</h4><ul><li>Iterator可以遍历Set和List集合，而ListIterator只能遍历List</li><li>Iterator只能单向遍历，而ListIterator可以双向遍历（向前/向后遍历）</li><li>ListIterator实现Iterator接口，然后添加了一些额外的功能，比如添加一个元素，替换一个元素，获取前面或后面元素的索引位置。</li></ul><h3 id="如何边遍历边移除Collection中的元素"><a href="#如何边遍历边移除Collection中的元素" class="headerlink" title="如何边遍历边移除Collection中的元素"></a>如何边遍历边移除Collection中的元素</h3><p>边遍历边修改Collection的唯一正确方式是使用Iterator.remove()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>  <span class="hljs-comment">//do something</span><br>  it.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Integer i : list)&#123;<br>  list.remove(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><h3 id="遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么"><a href="#遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么" class="headerlink" title="遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么"></a>遍历一个List有哪些不同的方式？每种方法的实现原理是什么？Java中遍历的最佳实践是什么</h3><p><strong>遍历方式有以下几种：</strong></p><ol><li>for循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每个位置的元素，当读取到最后一个元素后停止</li><li>迭代器遍历，Iterator。Iterator是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。java在Collections中支持了Iterator模式</li><li>foreach循环遍历。foreach内部也是采用了Iterator的方式实现，使用时不需要显式声明Iterator或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合、例如删除、替换</li></ol><p><strong>最佳实践</strong></p><p>Java Collections框架中提供了一个RandomAccess接口，用来标记List实现是否支持RandomAccess</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持Random Access，按位置读取元素的平均时间复杂度为O(1)，如ArrayList</li><li>如果没有实现该接口，表示不支持Random Access，如LinkedList</li></ul><p>推荐做法是，支持Random Access的列表可用for遍历循环，否则建议用Iterator或foreach遍历。</p><h3 id="如何实现数组和List之间的转换"><a href="#如何实现数组和List之间的转换" class="headerlink" title="如何实现数组和List之间的转换"></a>如何实现数组和List之间的转换</h3><ul><li>数组转list：使用Arrays.asList(array)进行转换</li><li>List转数组：使用List自带的toArray()方法</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//list to array</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>lsit.add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.toArray();<br><br><span class="hljs-comment">//array to list</span><br>String[] array = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;213&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>&#125;;<br>Arrays.asList(array);<br></code></pre></td></tr></table></figure><h3 id="多线程场景下如何使用ArrayList"><a href="#多线程场景下如何使用ArrayList" class="headerlink" title="多线程场景下如何使用ArrayList"></a>多线程场景下如何使用ArrayList</h3><p>ArrayList不是线程安全的，如果遇到多线程场景，可以通过Collections的synchronizedList方法将其转换成线程安全的容器后在使用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);<br>synchronizedList.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>synchronizedList.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; synchronizedList.size();i++)&#123;<br>  System.out.println(synchronizedList.get(i));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么ArrayList的elementData加上transient修饰"><a href="#为什么ArrayList的elementData加上transient修饰" class="headerlink" title="为什么ArrayList的elementData加上transient修饰"></a>为什么ArrayList的elementData加上transient修饰</h3><p>ArrayList中的数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData;<br></code></pre></td></tr></table></figure><p>ArrayList的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;,<span class="hljs-title">RandomAccess</span>,<span class="hljs-title">Cloneable</span>,<span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></table></figure><p>可以看到ArrayList实现了Serializable接口，这意味着ArrayList支持序列化。transient的作用是说不希望elementData数组被序列化，重写了writeObject实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span> <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;<br>    *<span class="hljs-comment">// Write out element count, and any hidden stuff*</span><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;<br>    s.defaultWriteObject();<br>    *<span class="hljs-comment">// Write out array length*</span><br>        s.writeInt(elementData.length);<br>    *<span class="hljs-comment">// Write out all elements in the proper order.*</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>            s.writeObject(elementData[i]);<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>每次序列化时，先调用defaultWriteObject()方法序列化ArrayList中的非transient元素，然后遍历elementData，只序列化已存入的元素，这样即加快了序列化的速度，又减小了序列化之后的文件大小</p><h3 id="HashSet的实现原理"><a href="#HashSet的实现原理" class="headerlink" title="HashSet的实现原理"></a>HashSet的实现原理</h3><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h4 id="1-HashSet如何检查重复，HashSet是如何保证数据不重复的？"><a href="#1-HashSet如何检查重复，HashSet是如何保证数据不重复的？" class="headerlink" title="1.HashSet如何检查重复，HashSet是如何保证数据不重复的？"></a>1.HashSet如何检查重复，HashSet是如何保证数据不重复的？</h4><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。<br>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p>HashSet部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>hashCode()与equals()相关规定</strong></p><ol><li>如果两个对象相等，则hashCode一定是相同的</li><li>两个对象相等，对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashcode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同的</li><li>==是指对内存地址进行比较，equals是对字符串的内容进行比较</li><li>==指引用是否相同，equals指的是值是否相同</li></ol><h4 id="2-HashSet与HashMap的区别"><a href="#2-HashSet与HashMap的区别" class="headerlink" title="2.HashSet与HashMap的区别"></a>2.HashSet与HashMap的区别</h4><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用put()向map中添加元素</td><td align="center">调用add()方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用(Key)计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，如果两个对象来说hashcode可能相同，所以equals方法用来判断对象的相等性，如果两个对象不同的话，返回false</td></tr><tr><td align="center">HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td align="center">HashSet较HashMap来说比较慢</td></tr></tbody></table><h3 id="BlockingQueue是什么"><a href="#BlockingQueue是什么" class="headerlink" title="BlockingQueue是什么"></a>BlockingQueue是什么</h3><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><h4 id="在Queue中poll和remove有什么区别"><a href="#在Queue中poll和remove有什么区别" class="headerlink" title="在Queue中poll和remove有什么区别"></a>在Queue中poll和remove有什么区别</h4><ul><li>相同点：都是返回与第一个元素，并在队列中删除返回的对象</li><li>不同点：如果没有元素poll()会返回null，而remove()会直接抛出NoSuchElementException异常</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>queue. offer(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// add</span><br>System. out. println(queue. poll());<br>System. out. println(queue. remove());<br>System. out. println(queue. size());<br></code></pre></td></tr></table></figure><h3 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h3><p>当我们put的时候，首先计算key的hash值，这里调用了hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以hash函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标<strong>index = (table.length - 1)&amp;hash</strong>,如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p>putVal方法执行流程图</p><p><img src="https://img-blog.csdnimg.cn/20191214222552803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="putVal方法执行流程图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//实现Map.put和相关方法</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 步骤①：tab为空则创建 </span><br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 步骤②：计算index，并对null做处理  </span><br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 步骤③：节点key存在，直接覆盖value </span><br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// 步骤④：判断该链为红黑树 </span><br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 步骤⑤：该链为链表 </span><br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <br>                <span class="hljs-comment">//判断该链表尾部指针是不是空的</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        <span class="hljs-comment">//链表结构转树形结构</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 步骤⑥：超过最大容量就扩容 </span><br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h3 id="HashMap的扩容操作是怎么实现的"><a href="#HashMap的扩容操作是怎么实现的" class="headerlink" title="HashMap的扩容操作是怎么实现的"></a>HashMap的扩容操作是怎么实现的</h3><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阈值时或者初始化时，就调用resize方法进行扩容</li><li>每次扩展的时候，都是扩展2倍</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab指向hash桶数组</span><br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果oldCap不为空的话，就是hash桶数组不为空</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于最大容量了，就赋值为整数最大的阀值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<span class="hljs-comment">//返回</span><br>        &#125;<span class="hljs-comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold 双倍扩容阀值threshold</span><br>    &#125;<br>    <span class="hljs-comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span><br>    <span class="hljs-comment">// 直接将该值赋给新的容量</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-comment">// 新的threshold = 新的cap * 0.75</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 计算出新的数组长度后赋给当前成员变量table</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<span class="hljs-comment">//新建hash桶数组</span><br>    table = newTab;<span class="hljs-comment">//将新数组的值复制给旧的hash桶数组</span><br>    <span class="hljs-comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历新数组的所有桶下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    <span class="hljs-comment">// 用同样的hash映射算法把该元素加入新的数组</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    <span class="hljs-comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 遍历链表</span><br>                    <span class="hljs-keyword">do</span> &#123;             <br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br>                                <span class="hljs-comment">// 代表下标保持不变的链表的头元素</span><br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span>                                <br>                                <span class="hljs-comment">// loTail.next指向当前e</span><br>                                loTail.next = e;<br>                            <span class="hljs-comment">// loTail指向当前的元素e</span><br>                            <span class="hljs-comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br>                            <span class="hljs-comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br>                            <span class="hljs-comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br>                            loTail = e;                           <br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                <span class="hljs-comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h3><ul><li>在解决问题之前需要先知道<strong>什么是哈希冲突</strong>，在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</li></ul><h4 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h4><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong></p><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</p><h4 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h4><ol><li><strong>使用链地址法（使用散列表）来链接拥有相同hash值的数据</strong></li><li><strong>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong> </li><li><strong>引入红黑树进一步降低遍历的时间复杂度，使得遍历的更快。</strong> </li></ol><h3 id="能否使用任何类作为Map的key？"><a href="#能否使用任何类作为Map的key？" class="headerlink" title="能否使用任何类作为Map的key？"></a>能否使用任何类作为Map的key？</h3><p>可以使用任何类作为Map的key，但需要注意这几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h3 id="为什么HashMap中String、Integer这样的包装类适合作为Key？"><a href="#为什么HashMap中String、Integer这样的包装类适合作为Key？" class="headerlink" title="为什么HashMap中String、Integer这样的包装类适合作为Key？"></a>为什么HashMap中String、Integer这样的包装类适合作为Key？</h3><ul><li>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少hash碰撞的几率</li></ul><ol><li>都是final类型，既不可变性、保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals(),hashCode()等方法，遵守了HashMap内部的规范，不容易出现Hash值计算错误的情况</li></ol><h3 id="如果使用Object作为HashMap的Key，应该怎么办？"><a href="#如果使用Object作为HashMap的Key，应该怎么办？" class="headerlink" title="如果使用Object作为HashMap的Key，应该怎么办？"></a>如果使用Object作为HashMap的Key，应该怎么办？</h3><ul><li>重写hashCode()和equals方法</li></ul><ol><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性；</strong></li></ol><h3 id="HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标"><a href="#HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标" class="headerlink" title="HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标"></a>HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标</h3><ul><li>hashCode()方法返回的是int整数类型，其范围为-(2 [^ 31])<del>(2[^ 31]  - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2[^30] ，HashMap()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置。</li></ul><p><strong>怎么解决</strong></p><ol><li>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p><p>这个算法应该如何设计呢？</p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p>那为什么是两次扰动呢？</p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h3 id="comparable和comparator的区别"><a href="#comparable和comparator的区别" class="headerlink" title="comparable和comparator的区别"></a>comparable和comparator的区别</h3><ul><li>comparable接口实际上是出自java.lang包，他有一个comparaTo(Object object)方法来排序</li><li>comparator接口实际上是出自java.util包，他有一个compare(Object obj1，Object obj2)方法用来排序</li></ul><h3 id="Collection和Collections有什么区别"><a href="#Collection和Collections有什么区别" class="headerlink" title="Collection和Collections有什么区别"></a>Collection和Collections有什么区别</h3><ul><li>java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记4 集合类</title>
    <link href="/2021/04/27/Java%E7%AC%94%E8%AE%B04-%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2021/04/27/Java%E7%AC%94%E8%AE%B04-%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、集合与数组的区别"><a href="#一、集合与数组的区别" class="headerlink" title="一、集合与数组的区别"></a>一、集合与数组的区别</h3><ul><li>长度区别：集合长度可变，数组长度不可变</li><li>内容区别：集合可以存储不同类型元素，数组只能存储单一元素类型</li><li>元素区别：集合只能存储引用类型元素，数组可存储引用类型，也可以存储基本类型</li></ul><h4 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1.集合概述"></a>1.集合概述</h4><p>java结构图：</p><p><img src="https://img-blog.csdnimg.cn/20210409193629391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU1OTU3NA==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>粉色框为接口，紫色框是实现类</strong></p><ul><li>Java集合有两大接口，Collection和Map，他们为同一个层次。</li><li><strong>Collection</strong> 接口被<strong>List</strong>接口和<strong>Set</strong>接口继承</li><li>List接口有三个实现类，<strong>ArrayList，LinkedList，Vector</strong></li><li>Set接口被<strong>HashSet</strong>类实现，被<strong>SortedSet接口</strong>继承，同时TreeSet类实现SortedSet接口，<strong>LinkedHashSet类</strong>继承HashSet类</li></ul><ul><li><strong>Map</strong>接口有两个实现类，HashMap，HashTable，同时<strong>Properties类</strong>继承HashTable</li><li>Map接口被SortedMap接口继承，同时TreeMap类实现了SortedMap接口</li></ul><h3 id="二、详述"><a href="#二、详述" class="headerlink" title="二、详述"></a>二、详述</h3><h4 id="1-Collection接口（单列集合）"><a href="#1-Collection接口（单列集合）" class="headerlink" title="1.Collection接口（单列集合）"></a>1.Collection接口（单列集合）</h4><p>Collection接口是<strong>（单列集合）</strong>的最顶层接口，定义了一些通用的方法</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">add(E e)</td><td align="center">添加元素</td></tr><tr><td align="center">clear()</td><td align="center">清空元素</td></tr><tr><td align="center">remove(E e)</td><td align="center">移除元素</td></tr><tr><td align="center">size()</td><td align="center">元素数量</td></tr><tr><td align="center">toArray()</td><td align="center">集合转数组</td></tr><tr><td align="center">contain(E e)</td><td align="center">判断元素是否存在</td></tr><tr><td align="center">isEmpty()</td><td align="center">判断集合是否为空</td></tr></tbody></table><h5 id="1-1-List接口"><a href="#1-1-List接口" class="headerlink" title="1.1 List接口"></a>1.1 List接口</h5><p>特点：</p><ul><li>有索引，精准操作元素</li><li>元素有序，存储及取出时顺序一致</li><li>元素<strong>可重复</strong>， 通过.equals()比较是否重复</li><li>它利用索引（index），定义了一些方法：</li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">get(int index,E e)</td><td align="center">获取指定位置的元素</td></tr><tr><td align="center">remove(int index)</td><td align="center">移除指定位置的元素</td></tr><tr><td align="center">add(int index,E e)</td><td align="center">将元素添加到指定位置</td></tr><tr><td align="center">set(int index,E e)</td><td align="center">用元素替换指定位置的元素</td></tr></tbody></table><h6 id="1-1-1ArrayList实现类"><a href="#1-1-1ArrayList实现类" class="headerlink" title="1.1.1ArrayList实现类"></a>1.1.1ArrayList实现类</h6><p>数据结构：数组</p><p><strong>特点：</strong> <strong>查询快，增删慢，主要用于查询遍历数据，为常用集合之一；</strong></p><p>底层分析：数组结构是有序的元素序列，在内存中开辟一段连续的空间，在空间中存放元素，每个空间都有编号，通过编号可以快速找到相应的元素，因此查询快；数组初始化时长度是固定的，要想增删元素，必须创建一个新数组，把原数组的元素复制过来，随后原数组销毁，耗时长，因此增删慢。</p><h6 id="1-1-2LinkedList实现类"><a href="#1-1-2LinkedList实现类" class="headerlink" title="1.1.2LinkedList实现类"></a>1.1.2LinkedList实现类</h6><p>数据结构：双向链表</p><p><strong>特点：查询慢，增删快。</strong></p><p>底层分析：链表分为单向和双向，就是一条链子和两条链子的区别；多出的那条链子记录了元素的顺序，因此单向链表结构无序，双向链表结构有序；链表结构没有索引，因此查询慢；链表的增删只需在原有的基础上连上或切断</p><p>链子，因此增删快。</p><p>特有方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">getFirst()</td><td align="center">返回头元素</td></tr><tr><td align="center">getLast()</td><td align="center">返回结尾元素</td></tr><tr><td align="center">pop()</td><td align="center">从所在堆栈中获取一个元素</td></tr><tr><td align="center">push(E e)</td><td align="center">将元素推入所在堆栈</td></tr><tr><td align="center">addFirst(E e)</td><td align="center">添加元素到开头，头插</td></tr><tr><td align="center">addLast(E e)</td><td align="center">添加元素到结尾，尾插</td></tr></tbody></table><h6 id="1-1-3Vector实现类（基本不用）"><a href="#1-1-3Vector实现类（基本不用）" class="headerlink" title="1.1.3Vector实现类（基本不用）"></a>1.1.3Vector实现类（基本不用）</h6><p>数据结构：数组</p><p><strong>特点：查询快，增删慢</strong></p><p>底层分析：和ArrayList一样，都是数组的实现，因此具有相似的特征，他们之间的区别在于Vector是线程安全的，效率低，ArrayList是线程不安全的，但效率高。</p><h5 id="1-2Set接口"><a href="#1-2Set接口" class="headerlink" title="1.2Set接口"></a>1.2Set接口</h5><p>特点：</p><ul><li>元素<strong>不可重复</strong></li><li>元素<strong>无序</strong>，存储及取出时顺序不一样</li><li>没有索引，因此<strong>不能</strong>使用普通的For循环遍历</li></ul><p>Set与Collection接口中的方法基本一致，b不需进行功能上的补充。</p><h6 id="1-2-1HashSet实现类"><a href="#1-2-1HashSet实现类" class="headerlink" title="1.2.1HashSet实现类"></a>1.2.1HashSet实现类</h6><p>数据结构：JDK1.8前：哈希表（数组+单向链表）；JDK1.8后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素无序，元素不可重复，没有索引</strong></p><p>底层分析：HashSet 是基于 HashMap 实现的，哈希表底层数组+单向链表实现，即使用链表处理冲突，同一Hash的值的元素都存储在一个链表里，但是当位于一个链表中的元素较多，即hash值相等的元素较多，通过key值依次查找的效率降低。JDK1.8之后，哈希表底层采用数据+单向链表+红黑树实现，当链表长度超过阈值（8）时，链表将转换为红黑树，极大缩短查询时间。</p><p><em>哈希值是一个十进制的整数，是对象的地址值，是一个逻辑地址，不是实际存储的物理地址，由系统随机给出。Object类的int hashCode()方法，可以获取对象的哈希值</em>。</p><h6 id="1-2-2LinkedHashSet实现类"><a href="#1-2-2LinkedHashSet实现类" class="headerlink" title="1.2.2LinkedHashSet实现类"></a>1.2.2LinkedHashSet实现类</h6><p>数据结构：JDK1.8前：哈希表（数组+双向链表）；JDK1.8后：哈希表（数组+双向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素有序，元素不可重复，没有索引；</strong></p><p>底层分析：作为HashSet的子类，只是比它多了一条链表，这条链表用来记录元素顺序，因此LinkedHashSet其中的元素有序。</p><h6 id="1-2-3TreeSet实现类"><a href="#1-2-3TreeSet实现类" class="headerlink" title="1.2.3TreeSet实现类"></a>1.2.3TreeSet实现类</h6><p>数据结构：红黑树</p><p><strong>特点：查询快，元素有序，元素不可重复，没有索引；</strong></p><p>底层分析：TreeSet实现了继承于Set接口的SortedSet接口，它支持两种排序方法，自然排序和定制排序，自然排序的意思就是放入元素“a”，“b“，a会自然地排在b前面，其中还有几种特有方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">first()</td><td align="center">返回第一个元素</td></tr><tr><td align="center">last()</td><td align="center">返回最后一个元素</td></tr><tr><td align="center">comparator()</td><td align="center">返回排序比较器</td></tr></tbody></table><h4 id="2-Map接口（双列集合）"><a href="#2-Map接口（双列集合）" class="headerlink" title="2.Map接口（双列集合）"></a>2.Map接口（双列集合）</h4><p>特点：</p><ul><li>元素包含两个值（key,value）即键值对，key不允许重复，value可以重复，key与value是一一对应的。</li><li>元素无序</li></ul><p>Map接口是<strong>双列集合</strong>的最顶层接口，定义了一些通用的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">put(key,value)</td><td align="center">添加元素</td></tr><tr><td align="center">remove(key)</td><td align="center">删除key元素</td></tr><tr><td align="center">containKey(key)</td><td align="center">判断是否存在key对应的元素</td></tr><tr><td align="center">get(key)</td><td align="center">获取key对应的元素</td></tr><tr><td align="center">KeySet()</td><td align="center">获取所有的key，存到Set集合中</td></tr><tr><td align="center">entrySet()</td><td align="center">获取所有的元素，存到Set集合中</td></tr></tbody></table><p><em>Map集合必须保证<strong>key唯一</strong>，作为key，必须重写hashCode方法和equals方法，以保证key唯一。</em></p><h5 id="2-1HashMap实现类"><a href="#2-1HashMap实现类" class="headerlink" title="2.1HashMap实现类"></a>2.1HashMap实现类</h5><p>数据结构：JDK1.8之前：哈希表（数组+单向链表）；JDK1.8之后：哈希表（数组+单向链表+红黑树），当链表长度超过阈值（8）时，链表将转换为红黑树。</p><p><strong>特点：查询快，元素无序，key不允许重复但可以为null，value可以重复</strong></p><p>底层分析：和HashSet底层类似。</p><h5 id="2-2HashTable实现类（基本不用）"><a href="#2-2HashTable实现类（基本不用）" class="headerlink" title="2.2HashTable实现类（基本不用）"></a>2.2HashTable实现类（基本不用）</h5><p>数据结构：哈希表</p><p><strong>特点：查询快，元素无序，key不允许重复并且不可以为null，value可以重复</strong></p><p>底层分析：HashTable和Vector一样是古老的集合，有遗留缺陷，在JDK1.2后，被更先进的集合取代，HashTable是线程安全的，速度慢，HashMap是线程不安全的，速度快；</p><p><em>HashTable的子类properties现在依然活跃，properties集合是一个唯一和IO流结合的集合。</em></p><h5 id="2-3TreeMap实现类"><a href="#2-3TreeMap实现类" class="headerlink" title="2.3TreeMap实现类"></a>2.3TreeMap实现类</h5><p>数据结构：红黑树</p><p><strong>特点：查询快，元素有序，key不允许重复并且不可以为null，value可以重复。</strong></p><p>底层分析：和TreeSet底层类似。</p><hr><p>学习文章：<a href="https://blog.csdn.net/weixin_42559574/article/details/108203595">https://blog.csdn.net/weixin_42559574/article/details/108203595</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记3 多线程常见问题</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是多线程"><a href="#一、什么是多线程" class="headerlink" title="一、什么是多线程"></a>一、什么是多线程</h3><p>线程是指程序在运行的过程中，能够执行程序代码的一个执行单元。</p><p>java语言中，线程有五种状态：新建、就绪、运行、阻塞、死亡。</p><p><img src="http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg" alt="img"></p><h3 id="二、进程与线程的区别？"><a href="#二、进程与线程的区别？" class="headerlink" title="二、进程与线程的区别？"></a>二、进程与线程的区别？</h3><p>进程是指一段正在执行的程序。而线程有时也被成为轻量级的进程，它是程序执行的最小单元，一个进程可以有多个线程。各个线程之间共享程序的内存空间（代码段、数据段、堆空间）及一些进程级的文件（列如：打开的文件），但是各个线程拥有自己的栈空间。在操作系统级别上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行。 </p><h3 id="三、为什么要使用多线程？"><a href="#三、为什么要使用多线程？" class="headerlink" title="三、为什么要使用多线程？"></a>三、为什么要使用多线程？</h3><ul><li><strong>提高执行效率，减少程序的响应时间。</strong>因为单线程执行的过程只有一个有效的操作序列，如果某个操作很耗时（或等待网络响应），此时程序就不会响应鼠标和键盘等操作，如果使用多线程，就可以将耗时的线程分配到一个单独的线程上执行，从而使程序具备更好的交互性。</li><li>与进程相比，线程的创建和切换开销更小。因开启一个新的进程需要分配独立的地址空间，建立许多数据结构来维护代码块等信息，而运行于同一个进程内的线程共享代码段、数据段、线程的启动和切换的开销比进程要少很多。同时<strong>多线程在数据共享方面效率非常高。</strong></li><li>目前市场上服务器配置大多数都是多CPU或多核计算机等，它们本身而言就具有执行多线程的能力，如果使用单个线程，就无法重复利用计算机资源，造成资源浪费。因此在多CPU计算机上<strong>使用多线程能提高CPU的利用率。</strong></li><li><strong>利用多线程能简化程序程序的结构，是程序便于理解和维护。</strong>一个非常复杂的进程可以分成多个线程来执行。</li></ul><h3 id="四、同步与异步有什么区别"><a href="#四、同步与异步有什么区别" class="headerlink" title="四、同步与异步有什么区别"></a>四、同步与异步有什么区别</h3><ul><li><p><strong>同步</strong>，<strong>可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</strong>。  </p></li><li><p><strong>异步</strong>，**执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 **</p><p>在多线程的环境中，通常会遇到数据共享问题，为了确保共享资源的正确性和安全性，就必须对共享数据进行同步处理（也就是锁机制）。对共享数据进行同步操作（增删改），就必须要获得每个线程对象的锁（this锁），这样可以保证同一时刻只有一个线程对其操作，其他线程要想对其操作需要排队等候并获取锁。当然在等候队列中优先级最高的线程才能获得该锁，从而进入共享代码区。</p><p>Java语言在同步机制中提供了语言级的支持，可以通过使用<strong>synchronize</strong>关键字来实现同步，但该方法是以很大的系统开销作为代价的，有时候甚至可能造成死锁，所以，同步控制并不是越多越好，要避免所谓的同步控制。实现同步的方法有两种：<strong>①同步方法（this锁）。②同步代码块（this锁或者自定义锁）</strong>当使用this锁时，就与同步方法共享同一锁，只有当①释放，②才可以使用。同时，同步代码块的范围也小于同步方法，建议使用，相比之下能够提高性能。 </p></li></ul><h3 id="五、如何实现java多线程"><a href="#五、如何实现java多线程" class="headerlink" title="五、如何实现java多线程"></a>五、如何实现java多线程</h3><p>在Java语言中实现多线程的方法有三种，其中前两种为常用方法：</p><ol><li><strong>继承Thread类，重写run()方法</strong></li></ol><p>  ​ Thread本质上也是实现了Runnable接口的一个实例，它表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()方法，start()方法是一个本地（native）方法，它将启动一个新的线程，并执行run()方法（执行的是自己重写了Thread类的run()方法），同时调用start()方法并不是执行多线程代码，而是使得该线程变为可运行状态（Runnable）,什么时候运行多线程代码由操作系统决定。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">//创建线程类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<span class="hljs-comment">//线程的函数体</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread thread = <span class="hljs-keyword">new</span> Thread<br>     thread.run();<span class="hljs-comment">//开启线程</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实现Runnable接口，并实现该结构的run()方法</strong></li></ol><ul><li>自定义实现Runnable接口，实现run()方法。</li><li>创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象。</li><li>调用Thread的start()方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>   <span class="hljs-function">pulic <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Thread Body&quot;</span>);<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     MyThread myThread = <span class="hljs-keyword">new</span> MyThread;<br>     Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);<br>     thread.start();<span class="hljs-comment">//启动线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>不管是哪种方法，最终都是通过Thread类的API来控制线程。</em></p><ol start="3"><li><p><strong>实现Callable接口，重写call()方法</strong></p><p>Callable接口实际是属于Executor框架中的功能类，Callable结构与Runnable接口的功能类似，但提供了比Runnable更强大的功能，主要体现在如下三点：</p><ol><li>Callable在任务结束后可以提供一个返回值，Runnable无法提供该功能。</li><li>Callable中的call()方法可以跑出异常，而Runnable中的run()不能跑出异常。</li><li>运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供能了检查计算是否完成的方法。由于线程输入异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监控目标线程来调用call()方法的情况，当调用Future的get()方法以获取结果时，当前线程会阻塞，直到目标线程的call()方法结束返回结果。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableAndFuture</span></span>&#123;<br>   <span class="hljs-comment">//创建线程类</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>     &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>     ExecutorService threadPool = Executors.newSingleThreadExecutor();<br>     Future&lt;String&gt; future = threadPool.submit(<span class="hljs-keyword">new</span> CallableTest());<br>     <span class="hljs-keyword">try</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;waiting thread to finish&quot;</span>);<br>          System.out.println(future.get());<br>        &#125;<span class="hljs-keyword">catch</span>&#123;Exception e&#125;&#123;<br>          e.printStackTrace<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    建议：当需要实现多线程时，一般推荐使用Runnable接口方式，因为Thread类定义了多种方法可以被派生类使用或重写，但是只有run()方法必须被重写，在run()方法中实现这个线程的主要功能，这当然也是实现Runnable接口所需的方法。再者，我们很多时候继承一个类是为了去加强和修改这个类才去继承的。因此，如果我们没有必要重写Thread类中的其他方法，那么通过继承Thread类和实现Runnable接口的效果是相同的，这样的话最好还是使用Runnable接口来创建线程。 </p></li></ol><h3 id="六、run方法与start方法的区别"><a href="#六、run方法与start方法的区别" class="headerlink" title="六、run方法与start方法的区别"></a>六、run方法与start方法的区别</h3><p>通常，系统通过调用线程类的start()方法启动一个线程，此时该线程处于就绪状态，而非运行状态，也就意味着这个线程可以别JVM调用执行，执行的过程中，JVM通过调用想成类的run()方法来完成实际的操作，当run()方法结束后，线程也就会终止。<br>如果直接调用线程类的run()方法，就会被当做一个普通函数调用，程序中仍然只有一个主程序，也就是说start()方法能够异步调用run()方法，但是直接调用run()方法却是同步的，也就无法达到多线程的目的。</p><h3 id="七、多线程数据同步实现的方法有哪些"><a href="#七、多线程数据同步实现的方法有哪些" class="headerlink" title="七、多线程数据同步实现的方法有哪些"></a>七、多线程数据同步实现的方法有哪些</h3><p>当使用多线程访问同一数据时，非常容易出现线程安全问题，因此采用同步机制解决。Java提供了三种方法：</p><ol><li><p><strong>synchronized关键字</strong></p><p> 在Java语言中，每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，当一个线程调用对象的synchronize代码时，需要先获取这个锁，然后再去执行相应的代码，执行结束后，释放锁。</p><p>synchronize关键字主要有两种用法（synchronize方法和synchronize代码块）</p><ul><li><p>synchronized方法：在方法的声明前加synchronize关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> synchronize <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>将需要对同步资源的操作放入test()方法中，就能保证此资源在同一时刻只能被一个线程调用，从而保证资源的安全性。然而当此方法体规模非常大时，会影响系统的效率。</p></li><li><p>synchronized块：既可以把任意的代码段声明为synchronized，也可以指定上锁的对象，有非常高的灵活性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(syncObject)&#123;<br>    <span class="hljs-comment">//访问syncObject的代码块</span><br>   &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>wait()方法与notify()方法</strong></p><p>当使用synchronized来修饰某个共享资源时，如果线程A1在执行synchronized代码，线程A2也要执行同一对象的统同一synchronize的代码，线程A2将要等到线程A1执行完后执行，这种情况可以使用wai()和notify()。必须是统一把锁，才生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberPrint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;  <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span> res[];  <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumberPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number, <span class="hljs-keyword">byte</span> a[])</span></span>&#123;  <br>           <span class="hljs-keyword">this</span>.number = number;  <br>           res = a;  <br>       &#125;  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;  <br>           <span class="hljs-keyword">synchronized</span> (res)&#123;  <br>               <span class="hljs-keyword">while</span>(count-- &gt; <span class="hljs-number">0</span>)&#123;  <br>                   <span class="hljs-keyword">try</span> &#123;  <br>                       res.notify();<span class="hljs-comment">//唤醒等待res资源的线程，把锁交给线程（该同步锁执行完毕自动释放锁）  </span><br>                       System.out.println(<span class="hljs-string">&quot; &quot;</span>+number);  <br>                       res.wait();<span class="hljs-comment">//释放CPU控制权，释放res的锁，本线程阻塞，等待被唤醒。  </span><br>                       System.out.println(<span class="hljs-string">&quot;------线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;获得锁，wait()后的代码继续运行：&quot;</span>+number);  <br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                       <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>                       e.printStackTrace();  <br>                   &#125;  <br>               &#125;<span class="hljs-comment">//end of while  </span><br>               <span class="hljs-keyword">return</span>;  <br>           &#125;<span class="hljs-comment">//synchronized  </span><br>             <br>       &#125;  <br>   &#125;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;  <br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> a[] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//以该对象为共享资源  </span><br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">1</span>),a),<span class="hljs-string">&quot;1&quot;</span>).start();  <br>           <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NumberPrint((<span class="hljs-number">2</span>),a),<span class="hljs-string">&quot;2&quot;</span>).start();  <br>       &#125;  <br>   &#125;  <br><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong> </p><p><img src="https://img-blog.csdnimg.cn/20210426222413506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p><strong>lock</strong></p><ul><li>lock()：以阻塞的方式获取锁，也就是说，如果获取到了锁，就会执行，其他线程需要等待，unlock()锁后别的线程才能执行，如果别的线程持有锁，当前线程等待，直到获取锁后返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span>(ProdLine.size() == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;队列是空的，请稍候&quot;</span>);<br>                empty.await();<br>            &#125;<br>            m = ProdLine.removeFirst();<br>            full.signal(); <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>tryLock()。以非阻塞的方式获取锁。只是尝试性地去获取一下锁，如果获取到锁，立即返回true，否则，返回false。</li><li>tryLock(long timeout,TimeUnit unit)。在给定的时间单元内，获取到了锁返回true，否则false。</li><li>lockInterruptibly().如果获取了锁，立即返回；如果没有锁，当前线程处于休眠状态，直到获取锁，或者当前线程被中断（会收到InterruptedException异常）。它与lock()方法最大的区别在于如果()方法获取不到锁，就会一直处于阻塞状态，且会忽略Interrupt()方法。</li></ul></li></ol><h3 id="八、sleep方法与wait方法有什么区别"><a href="#八、sleep方法与wait方法有什么区别" class="headerlink" title="八、sleep方法与wait方法有什么区别"></a>八、sleep方法与wait方法有什么区别</h3><p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法，直到被唤醒或等待时间超时。</p><p><strong>区别：</strong></p><ul><li><p>原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到时间一到，此线程会自动“苏醒”。</p><p>wait()方法是Object类的方法，用于线程间通讯，这个方法会使当前线程拥有该对象锁的进程等待，直到其他线程调用notify()方法（或notifyAll方法）时才“醒”来，不过开发人员可可以给它指定一个时间，自动“醒”来。与wait()方法配套的方法还有notify()和notifyAll()方法。</p></li><li><p>对锁的处理机制不同。由于sleep()方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，不涉及线程间的通讯，因此，调用sleep()方法并不会释放锁。而wait()方法则不同，调用后会释放掉他所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。</p></li><li><p>使用区域不同，由于wait()的特殊意义，因此它必须放在同步控制方法或者同步代码块中使用，而sleep()则可以放在任何地方使用。</p></li><li><p>sleep()方法 必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。</p><p> sleep不会释放“锁标志”，容易导致死锁问题的发生，因此，一般情况下，不推荐使用sleep()方法。而推荐使用wait()方法。</p></li></ul><h3 id="九、sleep与yield区别"><a href="#九、sleep与yield区别" class="headerlink" title="九、sleep与yield区别"></a>九、sleep与yield区别</h3><ul><li>sleep()给其他线程运行机会时，不考虑线程的优先级，因此会给低优先级的线程以运行的机会，而yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</li><li>sleep()方法会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程很可能在进入到可执行状态后马上又被执行。</li></ul><h3 id="十、终止线程的方法有哪些"><a href="#十、终止线程的方法有哪些" class="headerlink" title="十、终止线程的方法有哪些"></a>十、终止线程的方法有哪些</h3><ul><li><p>stop()方法，它会释放已经锁定的所有监视资源，如果当前任何一个受监视资源保护的对象处于一个不一致的状态（执行了一部分），其他线程线程将会获取到修改了的部分值，这个时候就可能导致程序执行结果的不确定性，并且这种问题很难被定位。</p></li><li><p>suspend()方法，容易发生死锁。因为调用suspend()方法不会释放锁，这就会导致此线程挂起。</p><p>以上两种方法的不安全性，Java语言已经不建议使用以上两种方法来终止线程了。</p></li><li><p>一般建议采用的方法是让线程自行结束进入Dead状态。一个线程进入Dead状态，既执行完run()方法，也就是说提供一种能够自动让run()方法结束的方式，在实际中，我们可以通过flag标志来控制循环是否执行，从而使线程离开run方法终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Boolean flag;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>     flag=<span class="hljs-keyword">false</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(flag);<span class="hljs-comment">//do something</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述通过stop()方法虽然可以终止线程，但同样也存在问题；当线程处于阻塞状态时（sleep()被调用或wait()方法被调用或当被I/O阻塞时）,上面介绍的方法就不可用了。此时使用interrupt()方法来打破阻塞的情况，当interrupt()方法被调用时，会跑出interruptedException异常，可以通过在run()方法中捕获这个异常来让线程安全退出。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;thread go to sleep&quot;</span>);<br>       <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//用休眠来模拟线程被阻塞</span><br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;thread finish&quot;</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;thread is interrupted!);</span><br><span class="hljs-string">           &#125;</span><br><span class="hljs-string">     &#125; </span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">thread.start();</span><br><span class="hljs-string">therad.interrupt();</span><br></code></pre></td></tr></table></figure><p><strong>程序运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">thread go to sleep<br>thread is interrupted!<br></code></pre></td></tr></table></figure><p>如果I/0停滞，进入非运行状态，基本上要等到I/O完成才能离开这个状态。或者通过出发异常，使用readLine()方法在等待网络上的一个信息，此时线程处于阻塞状态，让程序离开run()就出发close()方法来关闭流，这个时候就会跑出IOException异常，通过捕获此异常就可以离开run()。</p></li></ul><h3 id="十一、-synchronized与Lock有什么异同"><a href="#十一、-synchronized与Lock有什么异同" class="headerlink" title="十一、 synchronized与Lock有什么异同"></a>十一、 synchronized与Lock有什么异同</h3><p>Java语言中提供了两种锁机制的实现对某个共享资源的同步；synchronized和Lock。其中synchronized使用Object类对象本身的notify()、wait()、notifyAll()调度机制，而Lock使用condition包进行线程之间的调度，完成synchronized实现的所有功能</p><ul><li><p><strong>用法不一样。</strong>synchronized既可以加在方法上，也可以加在特定的代码块中，括号中表示需要的锁对象。而Lock需要显式的指定起始位置和终止位置。synchronized是托管给JVM执行的，而Lock的锁定是通过代码实现，他有比synchronized更精确的线程语义。</p></li><li><p><strong>性能不一样。</strong>在JDK5中增加了一个Lock接口的实现类ReentrantLock。它不仅拥有和synchronized相同的并发性和内存语义、还多了锁投票、定时锁、等候锁和中断锁。它们的性能在不同的情况下会有所不同；在资源竞争不激烈的情况下，synchronized的性能要优于RenntrantLock，但是资源竞争激烈的情况下，synchronized性能会下降的非常快，而ReentrantLock的性能基本保持不变。</p></li><li><p><strong>锁机制不一样。</strong>synchronized获得锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且自动解锁，而condition中的await()、signal()、signalAll()能够指定要释放的锁。不会因为异常而导致锁没有被释放从而引发死锁的问题。而Lock则需要开发人员手动释放，并且必须放在finally块中释放，否则会引起死锁问题。此外，Lock还提供了更强大的功能，他的tryLock()方法可以采用非阻塞的方式去获取锁。</p><p>虽然synchronized与Lock都可以实现多线程的同步，但是最好不要同时使用这两种同步机制给统一共享资源加锁（不起作用），因为ReentrantLock与synchronized所使用的机制不同，所以它们运行时独立的，相当于两个种类的锁，在使用的时候互不影响。</p></li></ul><p><strong>面试题</strong></p><ol><li>当一个线程进入一个对象的synchronized()方法后，其他线程是否能够进入此对象的其他方法？</li></ol><ul><li>其他线程可进入此对象的非synchronized修饰的方法。如果其他方法有synchronized修饰，都用的是同一对象锁，就不能访问。</li></ul><ol start="2"><li>如果其他方法是静态方法，且被synchronized修饰，是否可以访问？</li></ol><ul><li>可以的，因为static修饰的方法，它用的锁是当前类的字节码，而非静态方法使用的是this，因此可以调用。</li></ul><h3 id="十二、什么是线程守护"><a href="#十二、什么是线程守护" class="headerlink" title="十二、什么是线程守护"></a>十二、什么是线程守护</h3><p> Java提供了两种线程：<strong>守护线程和用户线程</strong>。守护线程又被称为“服务进程”、“精灵线程”、“后台线程”，是指在程序运行时在后台提供一种通用服务的线程，这种线程并不属于程序中不可或缺的部分，通俗点讲，每一个守护线程都是JVM中非守护线程的“保姆”。典型例子就是“垃圾回收器”。只要JVM启动，它始终在运行，实时监控和管理系统中可以被回收的资源。</p><p>用户线程和守护线程几乎一样，唯一的不同就在于如果用户线程已经全部退出运行，只剩下守护线程运行，JVM也就退出了因为当所有非守护线程结束时，没有了守护者，守护线程就没有工作可做，也就没有继续运行程序的必要了，程序也就终止了，同时会“杀死”所有的守护线程。也就是说，只要有任何非守护线程运行，程序就不会终止。</p><p>Java语言中，守护线程优先级都较低，它并非只有JVM内部提供，用户也可以自己设置守护线程，方法就是在调用线程的start()方法之前，设置setDaemon(true)方法，若将参数设置为false,则表示用户进程模式。需要注意的是，守护线程中产生的其它线程都是守护线程，用户线程也是如此。</p><p><strong>线程类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span>;i++) &#123;<br>System.out.println(getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>守护线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sunhui.Thread;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public final void setDaemon(boolean on)：是否设置为守护进程。true：是；false：否</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDaemonTest</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ThreadDaemon td1 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>ThreadDaemon td2 = <span class="hljs-keyword">new</span> ThreadDaemon ();<br>td1.setName(<span class="hljs-string">&quot;A&quot;</span>);<br>td2.setName(<span class="hljs-string">&quot;B&quot;</span>);<br> <br><span class="hljs-comment">//添加守护线程</span><br>td1.setDaemon(<span class="hljs-keyword">true</span>);<br>td2.setDaemon(<span class="hljs-keyword">true</span>);<br><br>td1.start();<br>td2.start();<br><br>Thread.currentThread().setName(<span class="hljs-string">&quot;C&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>A线程和B线程均设置为守护线程，C线程为用户进程。这三个线程均随机抢占CPU的使用权，当C抢占并且运行完毕之后，A和B这两个线程将在某一时间死亡，切记并不是立刻死亡，而是A线程执行完毕的一段时间后。</p><h3 id="十三、join方法作用"><a href="#十三、join方法作用" class="headerlink" title="十三、join方法作用"></a>十三、join方法作用</h3><p>在Java语言中，join()方法的作用是让调用该方法的线程在执行完run()方法后，再执行join方法后面的代码。简单点说就是将两个线程合并，并实现同步功能。具体而言，可以通过线程A的join()方法来等待线程A的结束，或者使用线程A的join(2000)方法来等待线程A的结束，但最多只等2s。示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Begin ThreadImp&quot;</span>);<br>       Thread.sleep(<span class="hljs-number">5000</span>);<br>       System.out.println(<span class="hljs-string">&quot;End ThreadImp&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadImp());<br>    t.start();<br>    <span class="hljs-keyword">try</span>&#123;<br>         t.join(<span class="hljs-number">1000</span>);<span class="hljs-comment">//主线程等待1s</span><br>         <span class="hljs-keyword">if</span>（t.isAlive())&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has not finished&quot;</span>);<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;t has finished&quot;</span>);<br>         &#125;<br>       System.out.println(<span class="hljs-string">&quot;joinFinish&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedExcetion e)&#123;<br>       e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426224744450.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记2 线程池学习</title>
    <link href="/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/26/Java%E7%AC%94%E8%AE%B02-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程池"><a href="#一、线程池" class="headerlink" title="一、线程池"></a>一、线程池</h3><p>在java.util.concurrent.Executors提供了一个java.util.concurrent.Executor接口的实现用于创建线程池。</p><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p><p>假设一个服务器完成一项任务所需时间为：T1创建线程池时间，T2在线程中执行任务的时间，T3销毁线程时间。</p><p>如果：T1+T3&gt;&gt;T2,则可以采用线程池，提高服务器性能。</p><h3 id="二、线程池的优势"><a href="#二、线程池的优势" class="headerlink" title="二、线程池的优势"></a>二、线程池的优势</h3><ul><li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的损耗。</li><li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限创建，不仅会损耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。</li></ul><h3 id="三、线程池的使用"><a href="#三、线程池的使用" class="headerlink" title="三、线程池的使用"></a>三、线程池的使用</h3><p>线程池的真正实现类是<strong>ThreadPoolExecutor</strong>， 其构造方法有4种。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         threadFactory, defaultHandler);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), handler);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可看到，需要这几个参数：</p><ul><li><strong>corePoolSize</strong> (必需)：核心线程数。默认情况下，核心线程数会一直存货，但是当将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>maxmumPoolsize</strong> (必需)：线程池所能容纳的最大线程数。当活跃线程数到该数值后，后续的新任务将会阻塞。</li><li><strong>keepAliveTime</strong>(必需)：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。 如果将<strong>allowCoreThreadTimeout</strong> 设置为true时，核心线程也会超时回收。</li><li><strong>unit</strong> （必需）：指定keepAliveTime参数的时间单位。常用的有：<strong>TimeUnit.MILLISECONDS</strong> （毫秒）、<strong>TimeUnit.SECONDS</strong> （秒）、<strong>TimeUnit.MINUTES</strong> （分）</li><li><strong>Queue</strong> （必需）：任务队列。通过线程池的execute()方法提交的Runnable对象将存储在该参数中。其采用阻塞队列实现。</li><li><strong>threadFactory</strong> （可选）：线程工厂。用于指定为线程池创建新线程的方式。</li><li><strong>handler</strong> （可选）：拒绝策略。当达到最大线程数时需要执行的包和策略。</li></ul><p>线程池的使用流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br>ThreadPoolExecutor threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,<br>                                             MAXIMUM_POOL_SIZE,<br>                                             KEEP_ALIVE,<br>                                             TimeUnit.SECONDS,<br>                                             sPoolWorkQueue,<br>                                             sThreadFactory);<br><span class="hljs-comment">// 向线程池提交任务</span><br>threadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        ... <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 关闭线程池</span><br>threadPool.shutdown(); <span class="hljs-comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span><br>threadPool.shutdownNow(); <span class="hljs-comment">// 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span><br></code></pre></td></tr></table></figure><h3 id="三、线程池的工作原理"><a href="#三、线程池的工作原理" class="headerlink" title="三、线程池的工作原理"></a>三、线程池的工作原理</h3><p>工作流程图：</p><p><img src="https://img-blog.csdnimg.cn/20210426193522921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="四、线程池的参数"><a href="#四、线程池的参数" class="headerlink" title="四、线程池的参数"></a>四、线程池的参数</h3><h4 id="1-任务队列（workqueue）"><a href="#1-任务队列（workqueue）" class="headerlink" title="1.任务队列（workqueue）"></a>1.任务队列（workqueue）</h4><p><img src="https://img-blog.csdnimg.cn/20210426202610254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在java中需要实现<strong>BlockingQueue</strong> 接口。但java已经提供了7种阻塞队列的实现：</p><ol><li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）</li><li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为<strong>Integer.MAX_VALUE</strong>。</li><li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排列的无界阻塞队列，对元素没有要求，可以实现<strong>Comparable</strong> 接口也可以提供Comparator来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</li><li><strong>DelayQueue</strong> ：类似于<strong>PriorityBlockingQueue</strong> ，是二叉堆实现的无界优先级阻塞队列。要求元素都实现<strong>Delayed</strong> 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</li><li><strong>SynchronousQueue</strong>： 一个不存储元素的阻塞队列，消费者线程调用take()方法的时候就会发送阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用put()方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</li><li><strong>LinkedBlockingDeque</strong>： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样FIFO（先进先出），也可以像栈一个FILO（先进后出）</li><li><strong>LinkedTransferQueue：</strong> 他是<strong>ConcurrentLinkedQueue</strong>、**LinkedBlockingQueue **和 **SynchronousQueue **的结合体，但是把它用在 ThreadPoolExecutor 中，和 **LinkedBlockingQueue **行为一致，但是是无界的阻塞队列。</li></ol><p><strong>注意有界队列和无界队列的区别：</strong> <em>如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</em> </p><h4 id="2-线程工厂（theadFactory）"><a href="#2-线程工厂（theadFactory）" class="headerlink" title="2.线程工厂（theadFactory）"></a>2.线程工厂（theadFactory）</h4><p>线程工厂指定创建线程的方式，需要实现 **ThreadFactory **接口，并实现 **newThread(Runnable r) **方法。该参数可以不用指定，Executors 框架已经为我们实现了一个默认的线程工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicInteger poolNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger threadNumber = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br> <br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>                              Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                      poolNumber.getAndIncrement() +<br>                     <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(group, r,<br>                              namePrefix + threadNumber.getAndIncrement(),<br>                              <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-拒绝策略（handler）"><a href="#3-拒绝策略（handler）" class="headerlink" title="3.拒绝策略（handler）"></a>3.拒绝策略（handler）</h4><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现<strong>RejectedExecutionHanlder</strong>接口，并实现 **rejectedExecution(Runnabler, ThreadPoolExecutor executor) **方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p><ol><li><strong>AbortPolicy（默认）</strong>：丢弃任务并抛出 **RejectedExecutionException **异常。</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li><li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li></ol><h3 id="五、功能线程池"><a href="#五、功能线程池" class="headerlink" title="五、功能线程池"></a>五、功能线程池</h3><p>Executors已经为我们封装好了 4 种常见的功能线程池，如下：</p><ul><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool ）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ul><h4 id="1-定长线程池（FixedThreadPool）"><a href="#1-定长线程池（FixedThreadPool）" class="headerlink" title="1.定长线程池（FixedThreadPool）"></a>1.定长线程池（FixedThreadPool）</h4><p>创建方法源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 只有核心教程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 控制线程最大并发数。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3</span><br>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>fixedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="2-定时线程池（ScheduledThreadPool）"><a href="#2-定时线程池（ScheduledThreadPool）" class="headerlink" title="2.定时线程池（ScheduledThreadPool）"></a>2.定时线程池（ScheduledThreadPool）</h4><p>创建方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DEFAULT_KEEPALIVE_MILLIS = <span class="hljs-number">10L</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue());<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE,<br>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>          <span class="hljs-keyword">new</span> DelayedWorkQueue(), threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。</li><li><strong>应用场景</strong>： 执行定时或周期性的任务。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5</span><br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>scheduledThreadPool.schedule(task, <span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 延迟1s后执行任务</span><br>scheduledThreadPool.scheduleAtFixedRate(task,<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS);<span class="hljs-comment">// 延迟10ms后、每隔1000ms执行任务</span><br></code></pre></td></tr></table></figure><h4 id="3-可缓存线程池（CachedThreadPool）"><a href="#3-可缓存线程池（CachedThreadPool）" class="headerlink" title="3.可缓存线程池（CachedThreadPool）"></a>3.可缓存线程池（CachedThreadPool）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),<br>                                  threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong>： 无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。</li><li><strong>应用场景</strong> ： 执行大量，耗时少的任务</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建可缓存线程池对象</span><br>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>cachedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-单线程化线程池（SingleThreadExecutor）"><a href="#5-单线程化线程池（SingleThreadExecutor）" class="headerlink" title="5.单线程化线程池（SingleThreadExecutor）"></a>5.单线程化线程池（SingleThreadExecutor）</h4><p>创建方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>特点</strong> ： 只有一个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>： 不合适并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建单线程化线程池</span><br>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br>Runnable task =<span class="hljs-keyword">new</span> Runnable()&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>singleThreadExecutor.execute(task);<br></code></pre></td></tr></table></figure><h4 id="5-对比"><a href="#5-对比" class="headerlink" title="5.对比"></a>5.对比</h4><p><img src="https://img-blog.csdnimg.cn/20210426201526725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p> Executors 的 4 个功能线程有如下弊端：</p><ul><li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：主要问题是堆积的请求处理队列均采用 <strong>LinkedBlockingQueue</strong>，可能会耗费非常大的内存，甚至 OOM。</li><li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><hr><p>学习文章：<a href="https://blog.csdn.net/u013541140/article/details/95225769">https://blog.csdn.net/u013541140/article/details/95225769</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记1 多线程学习</title>
    <link href="/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/25/Java%E7%AC%94%E8%AE%B01-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、线程和进程的区别"><a href="#一、线程和进程的区别" class="headerlink" title="一、线程和进程的区别"></a>一、线程和进程的区别</h3><p><strong>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1~n个线程。（进程是资源分配的最小单位）</strong></p><p><strong>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（PC），线程切换开销小。（线程是cpu调度的最小单位）</strong></p><p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止</p><p>多线程指在同一个程序中有多个顺序流在执行，在操作系统能同时运行多个任务（程序）</p><ul><li>在java中要实现多线程有三种方式，Thread类，实现Runable接口，Callable接口</li></ul><h3 id="二、扩展java-lang-Thread类"><a href="#二、扩展java-lang-Thread类" class="headerlink" title="二、扩展java.lang.Thread类"></a>二、扩展java.lang.Thread类</h3><p>​    继承thread类的方法是常用的一种，如果说要起一条线程可以使用thread</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行  :  &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads mTh2=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;B&quot;</span>);<br>        mTh1.start();<br>        mTh2.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042517010912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>程序在启动运行main时，java虚拟机启动一个进程，主线程main在main()调用时被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</li><li>start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</li><li>多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</li><li>Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。</li></ul><p><em>所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。但是start方法重复调用的话会出现<strong>java.lang.IllegalThreadStateException</strong>异常。</em></p><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Threads mTh1=<span class="hljs-keyword">new</span> Threads(<span class="hljs-string">&quot;A&quot;</span>);<br>Threads mTh2=mTh1;<br>mTh1.start();<br>mTh2.start();<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425171539746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="二、实现java-lang-Runnable接口"><a href="#二、实现java-lang-Runnable接口" class="headerlink" title="二、实现java.lang.Runnable接口"></a>二、实现java.lang.Runnable接口</h3><p>只需将run方法重写就行</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads1</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(name+<span class="hljs-string">&quot;运行 : &quot;</span>+i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep((<span class="hljs-keyword">int</span>) Math.random() * <span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;C&quot;</span>)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Threads1(<span class="hljs-string">&quot;D&quot;</span>)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210425172441669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>Threads1类通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个约定。所有多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</li><li>在启动多线程时，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码</li><li>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</li></ul><h3 id="三、Thread和Runnable的区别"><a href="#三、Thread和Runnable的区别" class="headerlink" title="三、Thread和Runnable的区别"></a>三、Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。</p><p><strong>实现Runnable接口比继承Thread类具有的优势：</strong></p><ul><li>适合多个相同的程序代码的线程去处理同一个资源</li><li>可以避免java中的单继承限制</li><li>增加程序的健壮性、代码可以被多个线程共享，代码和数据独立</li><li>线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类</li></ul><p>==注意：main方法也是一个线程，在java中所以的线程都是同时启动的，至于什么0候，哪个先执行，完全看谁先得到CPU的资源。==</p><p>==在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实习在就是在操作系统中启动了一个进程。==</p><h3 id="四、线程状态转换"><a href="#四、线程状态转换" class="headerlink" title="四、线程状态转换"></a>四、线程状态转换</h3><p><img src="https://img-blog.csdnimg.cn/20210425174938348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>新建状态：新创建一个线程对象</li><li>就绪状态：线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权</li><li>运行状态：就绪状态的线程获取了CPU，执行程序代码</li><li>阻塞状态：因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。<ul><li>阻塞状态三种情况<ul><li>等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待池中（wait会释放持有的锁）</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中</li><li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep状态超时，join等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li><li>死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul></li></ul><h3 id="五、线程调度"><a href="#五、线程调度" class="headerlink" title="五、线程调度"></a>五、线程调度</h3><h4 id="1-线程优先级"><a href="#1-线程优先级" class="headerlink" title="1.线程优先级"></a>1.线程优先级</h4><ul><li><p>java线程优先级高的会获得更多的运行机会</p></li><li><p>Java线程的优先级用整数表示，取值在1~10，Thread类有以下三个静态常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_PRIORITY <span class="hljs-comment">//线程可以具有的最高优先级，取值为10。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MIN_PRIORITY <span class="hljs-comment">//线程可以具有的最低优先级，取值为1。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NORM_PRIORITY <span class="hljs-comment">//分配给线程的默认优先级，取值为5。</span><br></code></pre></td></tr></table></figure><p><strong>用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread4 t1 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t1&quot;</span>);<br>Thread4 t2 = <span class="hljs-keyword">new</span> Thread4(<span class="hljs-string">&quot;t2&quot;</span>);<br>t1.setPriority(Thread.MAX_PRIORITY);<br>t2.setPriority(Thread.MIN_PRIORITY);<br></code></pre></td></tr></table></figure></li><li><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有优先级，主线程优先级默认为Thread.NORM_PRIORITY。</p></li><li><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p></li></ul><h4 id="2-线程睡眠"><a href="#2-线程睡眠" class="headerlink" title="2.线程睡眠"></a>2.线程睡眠</h4><p>Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><h4 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3.线程等待"></a>3.线程等待</h4><p> Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><h4 id="4-线程让步"><a href="#4-线程让步" class="headerlink" title="4.线程让步"></a>4.线程让步</h4><p>Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><h4 id="5-线程加入"><a href="#5-线程加入" class="headerlink" title="5.线程加入"></a>5.线程加入</h4><p>join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><h4 id="6-线程唤醒"><a href="#6-线程唤醒" class="headerlink" title="6.线程唤醒"></a>6.线程唤醒</h4><p>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><h3 id="六、常用函数"><a href="#六、常用函数" class="headerlink" title="六、常用函数"></a>六、常用函数</h3><ul><li><p><strong>sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</strong> sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</p><p>leep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</p><p>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。</p></li><li><p><strong>join():指等待t线程终止。</strong></p><ul><li>join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> AThread(); t.start(); t.join();<br></code></pre></td></tr></table></figure></li></ul><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p><strong>不加join情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426091527321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程比子线程结束早</p><p><strong>加上join方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads2</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程&quot;</span>+name+<span class="hljs-string">&quot;运行:&quot;</span>+i);<br>            <span class="hljs-keyword">try</span>&#123;<br>                sleep((<span class="hljs-keyword">int</span>) Math.random()*<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(Threads.currentThread().getName()+<span class="hljs-string">&quot;主线程运行开始&quot;</span>);<br>        Threads2 thread1 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;A&quot;</span>);<br>        Threads2 thread2 = <span class="hljs-keyword">new</span> Threads2(<span class="hljs-string">&quot;B&quot;</span>);<br>        thread1.start();<br>        thread2.start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            thread1.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            thread2.join();<br>        &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Threads2.currentThread().getName()+<span class="hljs-string">&quot;主线程运行结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20210426092435399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主线程会等待子线程结束之后在结束。</p><ul><li><p><strong>yield():暂停当前正在执行的线程对象，并执行其他线程</strong></p><p>Thread.yield()方法作用：暂停当前正在执行的线程对象，并执行其他线程。</p><p><strong>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。</strong> 所以，使用yield方法的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p><strong>yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果</strong> </p></li></ul><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadYield</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadYield</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">50</span>; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">&quot;------&quot;</span>+i);<br>            <span class="hljs-comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">30</span>)&#123;<br>                <span class="hljs-keyword">this</span>.yield();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadYield yield1 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;A&quot;</span>);<br>        ThreadYield yield2 = <span class="hljs-keyword">new</span> ThreadYield(<span class="hljs-string">&quot;B&quot;</span>);<br>        yield1.start();<br>        yield2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><ol><li><p>当A线程运行到30时，CPU让掉，这时A线程再次抢到CPU时间并执行</p><p><img src="https://img-blog.csdnimg.cn/20210426094258763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>当A线程运行到30时，CPU让掉，这时B线程抢到CPU时间并执行。</p></li></ol><h4 id="sleep-和yield-区别"><a href="#sleep-和yield-区别" class="headerlink" title="sleep()和yield()区别"></a>sleep()和yield()区别</h4><ol><li>sleep()使当前线程进入停滞状态, 所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</li><li>sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程</li><li>sleep 方法允许较低优先级的线程获得运行机会,但 yield()  方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</li></ol><ul><li><p>interrupt():不是中断某个线程， 只是线程发送一个中断信号，让线程 在无限等待时（如死锁）能够抛出，从而结束线程。</p></li><li><p>wait(): Obj.wait()与Obj.notify()必须要与synchronized一起使用，也就是针对已获取了Obj锁进行操作，从语法角度说必须放在synchronized(Obj){…}语句块内。</p><p>从功能上wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其他线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。</p><p>notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，不是马上就释放对象锁，而是在相应的synchronized(){}语句块执行结束后，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。</p><p>Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p><strong>案例：</strong></p><p><strong>建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。</strong> </p><p><strong>案例实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadText</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Object prev;<br>    <span class="hljs-keyword">private</span> Object self;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadText</span><span class="hljs-params">(String name,Object prev,Object self)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.self = self;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (prev)&#123;<br>                <span class="hljs-keyword">synchronized</span> (self)&#123;<br>                    System.out.println(name);<br>                    count -- ;<br>                    self.notify();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    prev.wait();<br>                &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Object a = <span class="hljs-keyword">new</span> Object();<br>        Object b = <span class="hljs-keyword">new</span> Object();<br>        Object c = <span class="hljs-keyword">new</span> Object();<br>        ThreadText pa = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;A&quot;</span>,c,a);<br>        ThreadText pb = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;B&quot;</span>,a,b);<br>        ThreadText pc = <span class="hljs-keyword">new</span> ThreadText(<span class="hljs-string">&quot;C&quot;</span>,b,c);<br><br>        <span class="hljs-keyword">new</span> Thread(pa).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pb).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">new</span> Thread(pc).start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021042610344056.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>案例分析</strong></p><p>该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。</p><p>为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。</p><p>可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p></li><li><p>wait()方法：wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</p><p>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</p></li></ul><h4 id="wait和sleep区别"><a href="#wait和sleep区别" class="headerlink" title="wait和sleep区别"></a>wait和sleep区别</h4><p><strong>相同点</strong></p><ol><li><p> 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。</p></li><li><p>wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException。</p><p>如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p><p>InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。</p></li></ol><p><strong>不同点</strong></p><ol><li><p>Thread类的方法：sleep(),yield()等。</p><p>Object类的方法：wait()和notify等。</p></li><li><p>每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。</p><p>sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p></li><li><p>wait，notify和notifyAll()只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用，<strong>所以sleep和wait最大的区别是：</strong></p><p><strong>sleep()睡眠时，保持对象锁，仍然占有该锁；</strong></p><p><strong>wait()睡眠时，释放对象锁</strong></p><p><strong>但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。</strong></p></li></ol><h3 id="七、常见线程名词解释"><a href="#七、常见线程名词解释" class="headerlink" title="七、常见线程名词解释"></a>七、常见线程名词解释</h3><p>主线程：JVM调用程序main()所产生的线程</p><p>当前线程：一般指通过Thread.currentThread()来获取进程</p><p>后台进程：指为其他线程提供服务的线程，也成为守护线程。JVM的垃圾回收线程就是一个后台线程。<strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p><p>前台线程：指接受后台线程服务的线程，其实前台后台线程是联系在一起，像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。</p><p><strong>线程类的一些常用方法：</strong> </p><p>　　<strong>sleep(): 强迫一个线程睡眠Ｎ毫秒。</strong> <br>　　<strong>isAlive(): 判断一个线程是否存活。</strong> <br>　　<strong>join(): 等待线程终止。</strong> <br>　　<strong>activeCount(): 程序中活跃的线程数。</strong> <br>　　<strong>enumerate(): 枚举程序中的线程。</strong> <br>    <strong>currentThread(): 得到当前线程。</strong> <br>　　<strong>isDaemon(): 一个线程是否为守护线程。</strong> <br>　　<strong>setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)</strong> <br>　　<strong>setName(): 为线程设置一个名称。</strong> <br>　　<strong>wait(): 强迫一个线程等待。</strong> <br>　　<strong>notify(): 通知一个线程继续运行。</strong> <br>　　<strong>setPriority(): 设置一个线程的优先级。</strong></p><h3 id="八、线程同步"><a href="#八、线程同步" class="headerlink" title="八、线程同步"></a>八、线程同步</h3><ul><li><strong>synchronized关键字的作用域有两种</strong> </li></ul><ol><li>是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法；</li><li>是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</li></ol><ul><li><strong>除了除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</strong> 用法是: synchronized(this){/<em>区块</em>/}，它的作用域是当前对象；</li><li><strong>synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。</strong>继承类需要你显式的指定它的某个方法为synchronized方法；</li></ul><p>总的说来，synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</p><p>在进一步阐述之前，我们需要明确几点：</p><p>A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p><p>B．每个对象只有一个锁（lock）与之相关联。</p><p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>接着来讨论synchronized用到不同地方对代码产生的影响：</p><p>假设P1、P2是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2就都可以调用它们。</p><ol><li><p>把synchronized当作函数修饰符时，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是同步方法，那这时synchronized锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象P1在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。</p><p>上边的示例代码等同于如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)  <span class="hljs-comment">//(1)&#123;</span><br>    <span class="hljs-comment">//..</span><br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p> (1)处的this指的是什么呢？它指的就是调用这个方法的对象，如P1。可见同步方法实质是将synchronized作用于object reference。――那个拿到了P1对象锁的线程，才可以调用P1的同步方法，而对P2而言，P1这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱</p></li><li><p>同步块，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(SomeObject so)</span></span>&#123;<br>  <span class="hljs-keyword">synchronized</span>(so)&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时，锁就是so这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] lock = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>      <span class="hljs-comment">//..</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>==注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。==</p></li><li><p>将synchronized作用于static 函数，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodAA</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodBB</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Foo.class) <span class="hljs-comment">//class literal(类名称字面常量)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><p>记得在《Effective Java》一书中看到过将 Foo.class和 P1.getClass()用于作同步锁还不一样，不能用P1.getClass()来达到锁这个Class的目的。P1指的是由Foo类产生的对象。</p><p>可以推断：如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class。</p></li></ol><p><strong>总结</strong></p><ol><li>线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</li><li>线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法</li><li>对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</li><li>对于同步，要时刻清醒在哪个对象上同步，这是关键。</li><li>编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</li><li>当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</li><li>死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真但是，一旦程序发生死锁，程序将死掉。</li></ol><h3 id="九、线程数据传递"><a href="#九、线程数据传递" class="headerlink" title="九、线程数据传递"></a>九、线程数据传递</h3><h4 id="1-通过构造方法传递数据"><a href="#1-通过构造方法传递数据" class="headerlink" title="1.通过构造方法传递数据"></a>1.通过构造方法传递数据</h4><p>在创建线程时，必须要建立一个Thread类的或其子类的实例。因此，我们不难想到在调用start方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用。下面的代码演示了如何通过构造方法来传递数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreads</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreads</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Thread thread = <span class="hljs-keyword">new</span> MyThreads(<span class="hljs-string">&quot;word&quot;</span>);<br>    thread.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。 </p><h4 id="2-通过变量和方法传递数据"><a href="#2-通过变量和方法传递数据" class="headerlink" title="2.通过变量和方法传递数据"></a>2.通过变量和方法传递数据</h4><p>向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的public的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对MyThread1类的改版，使用了一个setName方法来设置 name变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Threads3 threads3 = <span class="hljs-keyword">new</span> Threads3();<br>        threads3.setName(<span class="hljs-string">&quot;world&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(threads3);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-通过回调函数传递数据"><a href="#3-通过回调函数传递数据" class="headerlink" title="3.通过回调函数传递数据"></a>3.通过回调函数传递数据</h4><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个 value是无法事先就传入线程类的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Data data,Integer ... num)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : num)&#123;<br>            data.value += n;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Threads4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Work work;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Threads4</span><span class="hljs-params">(Work work)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.work = work;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        Data data = <span class="hljs-keyword">new</span> Data();<br>        <span class="hljs-keyword">int</span> n1 = random.nextInt(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">int</span> n2 = random.nextInt(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">int</span> n3 = random.nextInt(<span class="hljs-number">3000</span>);<br>        work.process(data,n1,n2,n3);<br>        System.out.println(String.valueOf(n1) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n2) + <span class="hljs-string">&quot;+&quot;</span> + String.valueOf(n3) + <span class="hljs-string">&quot;=&quot;</span> + data.value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Threads4(<span class="hljs-keyword">new</span> Work());<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>学习文章链接:<a href="http://blog.csdn.net/evankaka">http://blog.csdn.net/evankaka</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记10 事务与事务锁</title>
    <link href="/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/"/>
    <url>/2021/04/23/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一、事务简介"><a href="#一、事务简介" class="headerlink" title="一、事务简介"></a>一、事务简介</h3><p>Redis执行命令过程中，多条连续执行的指令被干扰，打断，插队</p><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>redis事务就是一个命令执行的队列，将一系列预定命令包装成一个整体（一个队列）。当执行时，按照添加顺序依次执行，中间不会被打断或者干扰。</p><p>一个队列中，一次性，顺序性，排他性的执行一系列命令</p><h3 id="二、事务的基本操作"><a href="#二、事务的基本操作" class="headerlink" title="二、事务的基本操作"></a>二、事务的基本操作</h3><ul><li><p>开启事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multi<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li><p>执行事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec<br></code></pre></td></tr></table></figure><ul><li>作用：设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</li></ul></li></ul><p><em>注意：</em> <strong>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行。</strong></p><ul><li><p>取消事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">discard<br></code></pre></td></tr></table></figure><ul><li>作用：终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul><h3 id="三、事物的工作流程"><a href="#三、事物的工作流程" class="headerlink" title="三、事物的工作流程"></a>三、事物的工作流程</h3><ul><li><p>未开启事务前的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423145755640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>创建事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150112123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的set指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150227995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>开启事务后的del指令</p><p><img src="https://img-blog.csdnimg.cn/20210423150354629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>关闭事务队列</p><p><img src="https://img-blog.csdnimg.cn/20210423150515144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>取消事务</p><p><img src="https://img-blog.csdnimg.cn/2021042315064864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="四、事物的注意事项"><a href="#四、事物的注意事项" class="headerlink" title="四、事物的注意事项"></a>四、事物的注意事项</h3><h4 id="定义事务的过程中，命令格式输入错误怎么办？"><a href="#定义事务的过程中，命令格式输入错误怎么办？" class="headerlink" title="定义事务的过程中，命令格式输入错误怎么办？"></a>定义事务的过程中，命令格式输入错误怎么办？</h4><ul><li><p>语法错误</p><p>指命令书写格式有误</p></li><li><p>处理结果</p><p>如果定义的事务中所包含的命令存在语法错误，整体事务中所以命令均不会执行。包括那些语法正确的命令。</p></li></ul><h4 id="定义事务的过程中，命令执行出现错误怎么办？"><a href="#定义事务的过程中，命令执行出现错误怎么办？" class="headerlink" title="定义事务的过程中，命令执行出现错误怎么办？"></a>定义事务的过程中，命令执行出现错误怎么办？</h4><ul><li><p>运行错误</p><p>指命令格式正确，但是无法正确的执行，列如对list进行incr操作</p></li><li><p>处理结果</p><p>能够正确运行的命令会执行，运行错误的命令不会执行</p></li></ul><p><em>注意：</em> <strong>已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</strong></p><h4 id="手动进行事务回滚"><a href="#手动进行事务回滚" class="headerlink" title="手动进行事务回滚"></a>手动进行事务回滚</h4><ul><li>记录操作过程中被影响的数据之前的状态<ul><li>单数据：string</li><li>多数据：hash、list、set、zset</li></ul></li><li>设置指令恢复所有的被修改的项<ul><li>单数据：直接set（注意周边属性，列如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ul></li></ul><h3 id="五、锁"><a href="#五、锁" class="headerlink" title="五、锁"></a>五、锁</h3><h4 id="基于特定条件的事务执行——锁"><a href="#基于特定条件的事务执行——锁" class="headerlink" title="基于特定条件的事务执行——锁"></a>基于特定条件的事务执行——锁</h4><p><strong>业务场景1</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423160652713.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>多个客户端有可能同时操作同一组数据，并且该数据一旦被操纵修改后，将不适用于继续操作</li><li>在操作之前锁定要操作的数据，一旦发生变化，终止当前操作</li></ul><p><strong>解决方案</strong></p><ul><li><p>对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">watch key1 [key2...]<br></code></pre></td></tr></table></figure></li><li><p>取消对所有key的监视</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unwatch<br></code></pre></td></tr></table></figure></li><li><p>redis应用基于状态控制的批量任务执行</p></li></ul><h4 id="基于特定条件的事务执行——分布式锁"><a href="#基于特定条件的事务执行——分布式锁" class="headerlink" title="基于特定条件的事务执行——分布式锁"></a>基于特定条件的事务执行——分布式锁</h4><p><strong>业务场景2</strong></p><p><img src="https://img-blog.csdnimg.cn/20210423161241863.png" alt="img"></p><p><strong>业务分析</strong></p><ul><li>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</li><li>虽然redis是单线程的，但是多个客户端对同一个数据同时操作时，如何避免不被同时修改？</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用setnx设置一个公共锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p><ul><li>对于返回设置成功时，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul></li><li><p>操作完毕通过del操作释放锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del lock-key<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em> ： 上述解决方案是一种设计概念，依赖规范保障，具有风险性</p><ul><li>redis应有基于分布式对应的场景控制</li></ul><h4 id="基于特定条件的事务执行——分布式锁改良"><a href="#基于特定条件的事务执行——分布式锁改良" class="headerlink" title="基于特定条件的事务执行——分布式锁改良"></a>基于特定条件的事务执行——分布式锁改良</h4><p><strong>业务场景</strong></p><p>依赖分布式锁的机制，某个用户操作时对应客户机宕机，并且此时已经获取到锁，如何解决？</p><p><strong>业务分析</strong></p><ul><li>由于锁操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险</li><li>需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案</li></ul><p><strong>解决方案</strong></p><ul><li><p>使用expire为锁key添加时间限定，到时不释放，放弃锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire lock-key second<br>pexpire lock-key millseconds<br></code></pre></td></tr></table></figure><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms</li><li>测试百万次最长执行时间对应命令的最大消耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时* 120%+平均网络延迟*110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记9 Redis持久化之AOF</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、AOF概念"><a href="#一、AOF概念" class="headerlink" title="一、AOF概念"></a>一、AOF概念</h3><ul><li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令，达到恢复数据的目的。与RDB相比可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></li><li>AOF的主要作用时解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li></ul><h3 id="二、AOF写数据过程"><a href="#二、AOF写数据过程" class="headerlink" title="二、AOF写数据过程"></a>二、AOF写数据过程</h3><p><img src="https://img-blog.csdnimg.cn/20210422194954247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="三、AOF写数据三种策略（appendfsync）"><a href="#三、AOF写数据三种策略（appendfsync）" class="headerlink" title="三、AOF写数据三种策略（appendfsync）"></a>三、AOF写数据三种策略（appendfsync）</h3><ul><li><p>always（每次）</p><p>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong></p></li><li><p>everysec（每秒）</p><p>每次将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高</strong>，在系统突然宕机的情况下丢失1秒内的数据（建议使用，也是默认配置）</p></li><li><p>no（系统控制）</p><p>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></p><p>​</p></li></ul><h3 id="四、AOF功能开启"><a href="#四、AOF功能开启" class="headerlink" title="四、AOF功能开启"></a>四、AOF功能开启</h3><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendonly yes|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>是否开启AOF持久化功能，默认为不开启状态</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfsync always|everysec|no<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF写数据策略</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">appendfilename filename<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p></li></ul></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dir<br></code></pre></td></tr></table></figure><ul><li><p>作用</p><p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li></ul><h3 id="五、AOF写数据遇到的问题"><a href="#五、AOF写数据遇到的问题" class="headerlink" title="五、AOF写数据遇到的问题"></a>五、AOF写数据遇到的问题</h3><p><strong>如果连续执行如下指令该如何处理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042220280729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p>AOF重写</p><h3 id="六、AOF重写"><a href="#六、AOF重写" class="headerlink" title="六、AOF重写"></a>六、AOF重写</h3><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是<strong>将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。</strong></p><h4 id="AOF重写作用"><a href="#AOF重写作用" class="headerlink" title="AOF重写作用"></a>AOF重写作用</h4><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h4 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h4><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令，如del key1、hdel key2、srem key3、set key4 123、set key4 222等</p></li><li><p>对同一数据的多条写命令合并为一条命令，如lpush list1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c。</p><p>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型、每条指令最多写入64个元素</p></li></ul><h4 id="AOF重写方式（手动重写）"><a href="#AOF重写方式（手动重写）" class="headerlink" title="AOF重写方式（手动重写）"></a>AOF重写方式（手动重写）</h4><ul><li><p>手动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgrewriteaof<br></code></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percentage<br></code></pre></td></tr></table></figure></li></ul><h4 id="AOF手动重写——bgrewriteaof指令工作原理"><a href="#AOF手动重写——bgrewriteaof指令工作原理" class="headerlink" title="AOF手动重写——bgrewriteaof指令工作原理"></a>AOF手动重写——bgrewriteaof指令工作原理</h4><p><img src="https://img-blog.csdnimg.cn/20210422204256378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写方式（自动重写）"><a href="#AOF重写方式（自动重写）" class="headerlink" title="AOF重写方式（自动重写）"></a>AOF重写方式（自动重写）</h4><ul><li><p>自动重写触发条件格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">auto-aof-rewrite-min-size size<br>auto-aof-rewrite-percentage percent<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发对比参数（运行指令info Persistence获取具体信息）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">aof_current_size<br>aof_base_size<br></code></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><img src="https://img-blog.csdnimg.cn/20210422205637212.png" alt="img"></p><h4 id="AOF工作流程"><a href="#AOF工作流程" class="headerlink" title="AOF工作流程"></a>AOF工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210052662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h4><p><img src="https://img-blog.csdnimg.cn/20210422210223933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210422210336449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>AOF缓冲区同步文件策略，由参数appendfsync控制</li></ul><p><strong>系统调用write和fsync说明：</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422210709540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="七、RDB与AOF区别"><a href="#七、RDB与AOF区别" class="headerlink" title="七、RDB与AOF区别"></a>七、RDB与AOF区别</h3><p><img src="https://img-blog.csdnimg.cn/20210422210809864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB与AOF选择之惑</strong></p><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用erverysecond，每秒钟fsync一次。该策略redis任然可以保持很好的处理性能，当出现问题时，最多丢失0-1秒中的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复数据较慢</li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人工手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降得很低</li></ul></li><li>综合对比<ol><li>RDB与AOF得选择实际上是在做一种权衡，每种都有利弊</li><li>如不能承受数分钟以内得数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内数据丢失，且追求大数据集得恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启RDB和AOF，重启后，Redis优先使用AOF来恢复数据，降低丢失数据的量</li></ol></li></ul><p><strong>持久化应用场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422211202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记8 Redis持久化之RDB</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、持久化简介"><a href="#一、持久化简介" class="headerlink" title="一、持久化简介"></a>一、持久化简介</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1.什么是持久化"></a>1.什么是持久化</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><h3 id="2-为什么要进行持久化"><a href="#2-为什么要进行持久化" class="headerlink" title="2.为什么要进行持久化"></a>2.为什么要进行持久化</h3><p>防止数据的意外丢失，确保数据安全性</p><h3 id="3-持久化过程保存什么"><a href="#3-持久化过程保存什么" class="headerlink" title="3.持久化过程保存什么"></a>3.持久化过程保存什么</h3><ul><li><p>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据。</p></li><li><p>将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程。</p><p><img src="https://img-blog.csdnimg.cn/2021042215521812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><h2 id="二、RDB"><a href="#二、RDB" class="headerlink" title="二、RDB"></a>二、RDB</h2><h3 id="1-RDB启动方式（手动执行）"><a href="#1-RDB启动方式（手动执行）" class="headerlink" title="1.RDB启动方式（手动执行）"></a>1.RDB启动方式（手动执行）</h3><p><strong>命令执行</strong></p><ul><li>谁：redis操作者（用户）</li><li>什么时间：即使（随时进行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save指令</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><p><strong>RDB启动方式——save指令相关配置</strong></p><ul><li><p>dbfilename dump.rdb</p><p>说明 : 设置本地数据库文件名，默认值为dump.rdb</p><p>经验 : 通常设置为<strong>dump-端口号.rdb</strong></p></li><li><p>dir</p><p>说明 : 设置存储.rdb文件路径</p><p>经验 : 通常设置成存储空间较大的目录 , 目录名称为data</p></li><li><p>rdbcompression yes</p><p>说明 : 设置存储至本地数据库时是否压缩数据 , 默认为yes , 采用LZF压缩</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节省CPU运行时间 , 但会使存储的文件变大(巨大)</p></li><li><p>rdbchecksum yes</p><p>说明 : 设置是否进行RDB文件格式校验 , 该校验过程在写文件个读文件过程均进行</p><p>经验 : 通常默认为开启状态 , 如果设置为no , 可以节约读写性过程约10%时间消耗 , 但是存储一定的数据损坏风险</p></li></ul><p><strong>RDB启动方式——save指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422160844486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> <strong>Redis是单线程的</strong>，所有命令都会在类似队列中排好队，不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成位置，有可能会造成长时间阻塞，<strong>线上环境不建议使用</strong></p><h3 id="2-RDB启动方式（后台执行）"><a href="#2-RDB启动方式（后台执行）" class="headerlink" title="2.RDB启动方式（后台执行）"></a>2.RDB启动方式（后台执行）</h3><p><strong>后台执行</strong></p><ul><li>谁：redis操作者（用户）发起指令；redis服务器控制指令执行</li><li>什么时间：即使（发起）；合理时间（执行）</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——bgsave</strong></p><ul><li><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bgsave<br></code></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但不是立即执行</p></li></ul><p><strong>RDB启动方式——bgsave指令工作原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422161702164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em>bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用</p><p><strong>RDB启动方式——bgsave指令相关配置</strong></p><ul><li><p>stop-writes-on-bgsave-error yes</p><p>说明：后台存储过程中如果出现错误现象，是否停止保存操作</p><p>经验：默认为开启</p></li></ul><h3 id="3-RDB启动方式（自动执行）"><a href="#3-RDB启动方式（自动执行）" class="headerlink" title="3.RDB启动方式（自动执行）"></a>3.RDB启动方式（自动执行）</h3><p><strong>自动执行</strong></p><ul><li>谁：redis服务器发起指令（基于条件）</li><li>什么时间：满足条件</li><li>干什么事情：保存数据</li></ul><p><strong>RDB启动方式——save配置</strong></p><ul><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save second changes<br></code></pre></td></tr></table></figure></li><li><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数</p><p>second：监控时间范围</p><p>changes：监控key的变化量</p></li><li><p>位置</p><p>conf文件中配置</p></li><li><p>范例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 900 1<br>save 300 10<br>save 60 10000<br></code></pre></td></tr></table></figure></li></ul><p><strong>RDB启动方式——save配置原理</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042216312487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><em>注意：</em> </p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li>save配置启动后执行的是bgsave操作</li></ul><p><strong>RDB三种启动方式对比</strong></p><ul><li>save配置启动后由于执行的还是bgsave操作所以不在进行对比。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210422163458239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>RDB特殊启动方式</strong></p><ul><li><p>全量复制</p><p>在主从复制中详细介绍</p></li><li><p>服务器运行过程中重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debug reload<br></code></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown<br></code></pre></td></tr></table></figure><ul><li>默认情况下执行shutdown命令时，自动执行bgsave（如果没有开启AOF持久化功能）</li></ul></li></ul><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><ul><li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li><li>RDB内部存储的是redis在某个<strong>时间点</strong>的数据快照，非常适合用于数据备份，全量复制等场景</li><li>RDB恢复数据的速度要比AOF快很多</li><li>应用：服务器中每x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</li></ul><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ul><li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li><li>redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务器之间数据格式无法兼容现象</li></ul><h3 id="RDB存储的弊端"><a href="#RDB存储的弊端" class="headerlink" title="RDB存储的弊端"></a>RDB存储的弊端</h3><ul><li>存储数据量大，效率较低<ul><li>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</li></ul></li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机带来的数据丢失风险</li></ul><p><strong>解决思路</strong></p><ul><li>不写全数据，仅记录部分数据</li><li>降低区分数据是否改变的难度，改记录数据为记录操作过程</li><li>对所有操作均进行记录，排除丢失数据的风险</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记7 Jedis连接并操作Redis</title>
    <link href="/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/"/>
    <url>/2021/04/22/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Jedis%E8%BF%9E%E6%8E%A5%E5%B9%B6%E6%93%8D%E4%BD%9CRedis/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Jedis简介"><a href="#一、Jedis简介" class="headerlink" title="一、Jedis简介"></a>一、Jedis简介</h3><p><strong>编程语言与redis</strong></p><ul><li><p>Java语言连接redis服务</p><p>Jedis</p><p>SpringData Redis</p><p>Lettuce</p><p>​</p></li></ul><h3 id="二、Jedis操作Redis"><a href="#二、Jedis操作Redis" class="headerlink" title="二、Jedis操作Redis"></a>二、Jedis操作Redis</h3><p><strong>准备工作</strong></p><ul><li><p>基于maven导入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>连接redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>)<br></code></pre></td></tr></table></figure></li><li><p>操作redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>);<br>jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>关闭redis连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.close();<br></code></pre></td></tr></table></figure></li><li><p>API文档</p><p><a href="https://xetorthio.github.io/jedis/">https://xetorthio.github.io/jedis/</a></p></li></ul><h4 id="Jedis简易工具类开发"><a href="#Jedis简易工具类开发" class="headerlink" title="Jedis简易工具类开发"></a>Jedis简易工具类开发</h4><p><strong>基于连接池获取数据</strong></p><ul><li><p>JedisPool：Jedis提供的连接池技术</p><p>​    poolConfig：连接池配置对象</p><p>​    host：redis服务地址</p><p>​    port：redis服务端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JedisPool</span> <span class="hljs-params">(GenericObjectPoolConfig poolConfig, String host, <span class="hljs-keyword">int</span> port)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>(poolConfig, host, port, <span class="hljs-number">2000</span>, (String)<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, (String)<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>封装连接参数</strong></p><ul><li><p>jedis.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">jedis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">jedis.prot</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">jedis.maxTotal</span>=<span class="hljs-string">30</span><br><span class="hljs-meta">jedis.maxIdle</span>=<span class="hljs-string">10</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>加载配置信息</strong></p><ul><li><p>静态代码块初始化资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<br>    <span class="hljs-keyword">static</span> &#123;<br>        JedisPoolConfig jpc=<span class="hljs-keyword">new</span> JedisPoolConfig();<br>        ResourceBundle rb=ResourceBundle.getBundle(<span class="hljs-string">&quot;redis&quot;</span>);<br>        host=rb.getString(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        port=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        maxTotal=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxTotal&quot;</span>));<br>        maxIdle=Integer.parseInt(rb.getString(<span class="hljs-string">&quot;redis.maxIdle&quot;</span>));<br>        jpc.setMaxTotal(maxTotal);<br>        jpc.setMaxIdle(maxIdle);<br>        jp=<span class="hljs-keyword">new</span> JedisPool(jpc,host,port);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>对外访问外接口，提供jedis连接对象，连接从连接池获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> jp.getResource();<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="三、Jedis读写redis数据"><a href="#三、Jedis读写redis数据" class="headerlink" title="三、Jedis读写redis数据"></a>三、Jedis读写redis数据</h3><p><strong>案例实现</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101849577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>需求分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20210422101957835.png" alt="img"></p><p><strong>实现步骤</strong></p><ul><li><p>1.设定业务方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">(String id, <span class="hljs-keyword">long</span> num)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;业务发起调用&quot;</span>,<span class="hljs-string">&quot;当前第&quot;</span>+num+<span class="hljs-string">&quot;次&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>2.设定多线类，模拟用户调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(ture)&#123;<br>    jd.service(id);<br>    <span class="hljs-comment">//模拟调用间隔，设定为1.x秒</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Random r = <span class="hljs-keyword">new</span> Random();<br>      Thread.sleep(<span class="hljs-number">1000</span>+r.nextInt(<span class="hljs-number">200</span>));<br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>3.设计redis控制方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(String id)</span></span>&#123;<br>  Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">6379</span>);<br>  String value = jedis.get(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>  <span class="hljs-comment">//判定是否具有调用计数控制，利用异常进行控制处理</span><br>  <span class="hljs-keyword">if</span>(value==<span class="hljs-keyword">null</span>)&#123;<br>    jedis.setex(<span class="hljs-string">&quot;compid:&quot;</span>+id,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;&quot;</span>+(Long.MAX_VALUE-<span class="hljs-number">10</span>));<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//有控制，自增，并调用业务</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      Long val = redis.incr(<span class="hljs-string">&quot;compid:&quot;</span>+id);<br>      business(id,<span class="hljs-number">10</span>+val-Long.MAX_VALUE);<br>    &#125;<span class="hljs-keyword">catch</span>(JedisDataExpection e)&#123;<br>      System.out.println(<span class="hljs-string">&quot;用户&quot;</span>+id+<span class="hljs-string">&quot;使用次数到达上线&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      jedis.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设计启动主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[],args)</span></span>&#123;<br>  MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;初级用户&quot;</span>);<br>  t1.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记6 key和数据库通用指令</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-key%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、key通用操作"><a href="#一、key通用操作" class="headerlink" title="一、key通用操作"></a>一、key通用操作</h2><h3 id="1-key特征"><a href="#1-key特征" class="headerlink" title="1.key特征"></a>1.key特征</h3><ul><li>key是一个字符串，通过key获取redis中保存的数据</li></ul><h3 id="2-key设计的操作"><a href="#2-key设计的操作" class="headerlink" title="2.key设计的操作"></a>2.key设计的操作</h3><ul><li>对于key自身状态的相关操作，例如：删除，判定存在，获取类型等</li><li>对于key有效性控制相关操作，例如：有效期设定，判定是否有效，有效状态的切换等</li><li>对于key快速查询操作，例如：按指定策略查询key</li></ul><h3 id="3-key基本操作"><a href="#3-key基本操作" class="headerlink" title="3.key基本操作"></a>3.key基本操作</h3><ul><li><p>删除指定key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>获取key是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exists key<br></code></pre></td></tr></table></figure></li><li><p>获取key的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">type key<br></code></pre></td></tr></table></figure><p><strong>key扩展操作（时效性控制）</strong></p></li><li><p>为指定key设置有效期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">expire key seconds     #设置秒<br>pexpire key milliseconds #设置毫秒<br>expireat key timestamp   #秒时间戳<br>pexpireat key milliseconds-timestamp  #毫秒时间戳<br></code></pre></td></tr></table></figure></li><li><p>获取key的有效时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ttl key<br>pttl key<br></code></pre></td></tr></table></figure><ul><li>ttl命令下，如果返回值为-2则是key不存在；如果返回值是-1，则是key存在且没有设置有效期；如果key设置有效期，则返回当前剩余的有效时常。</li></ul></li><li><p>切换key从时效性到永久性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">persist key  <br></code></pre></td></tr></table></figure><p><strong>key扩展操作（查询模式）</strong></p></li><li><p>查询key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys pattern<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421210222191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="4-key其他操作"><a href="#4-key其他操作" class="headerlink" title="4.key其他操作"></a>4.key其他操作</h3><ul><li><p>为key改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rename key newkey<br>renamenx key newkey  #如果key不存在，就改名<br></code></pre></td></tr></table></figure></li><li><p>对所有key排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort<br></code></pre></td></tr></table></figure></li><li><p>其他key通用操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help @generic<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、数据库通用操作"><a href="#二、数据库通用操作" class="headerlink" title="二、数据库通用操作"></a>二、数据库通用操作</h2><p><strong>key的重复问题</strong></p><ul><li>key是由程序员定义的</li><li>redis在使用过程中，伴随着操作数据量的增加，会出现大量的数据以及对应的key</li><li>数据不区分种类，类别混杂在一起，极易出现重复或冲突</li></ul><p><strong>解决方案</strong></p><ul><li>redis为每个服务器提供有16个数据库，编号从0-15</li><li>每个数据库之间的数据互相独立</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421210716812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="1-db基本操作"><a href="#1-db基本操作" class="headerlink" title="1.db基本操作"></a>1.db基本操作</h3><ul><li><p>切换数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select index<br></code></pre></td></tr></table></figure></li><li><p>其他操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">quit<br>ping<br>echo message<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-db相关操作"><a href="#2-db相关操作" class="headerlink" title="2.db相关操作"></a>2.db相关操作</h3><ul><li><p>数据移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">move key db<br></code></pre></td></tr></table></figure></li><li><p>数据清除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">dbsize   #查看当前库中key的总数量<br>flushdb  #清除当前库中所有的key<br>flushall #清除所有库中的key<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记5 sorted_set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-sorted-set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="sorted-set类型"><a href="#sorted-set类型" class="headerlink" title="sorted_set类型"></a>sorted_set类型</h2><ul><li>新的存储需求：数据排序有利于数据的有效显示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要的存储结构：新的存储模型，可以保存可排序的数据</li><li>sorted_set类型：在set的存储结构基础上添加可排序字段</li></ul><p><img src="https://img-blog.csdnimg.cn/20210421164359468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="sorted-set类型数据的基本操作"><a href="#sorted-set类型数据的基本操作" class="headerlink" title="sorted_set类型数据的基本操作"></a>sorted_set类型数据的基本操作</h2><ul><li><p>添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd key score1 member1 [score2 member2]<br><br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrange key start stop [WITHSCORES]<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrem key member [member1 ...]<br></code></pre></td></tr></table></figure></li><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrangebyscore key min max [WITHSCORES] [LIMIT]<br>zrevrangebyscore key max min [WITHSCORES] #逆排序<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421165618285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul><ul><li><p>按条件获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zremrangebyrank key start stop   #按索引删除<br>zremrangebyscore key min max<br></code></pre></td></tr></table></figure></li></ul><p><em>注意</em>：</p><ul><li><em>min与max用于限定搜索查询的条件</em></li><li><em>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</em></li><li><em>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</em></li></ul><p>​    </p><ul><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">zcard key<br>zcount key min max<br><br></code></pre></td></tr></table></figure></li><li><p>集合交、并操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zinterstore destination numkeys key [key ...]<br>zunionstore destination numkeys key [key ...]<br></code></pre></td></tr></table></figure></li></ul><h2 id="sorted-set类型数据的扩展操作"><a href="#sorted-set类型数据的扩展操作" class="headerlink" title="sorted_set类型数据的扩展操作"></a>sorted_set类型数据的扩展操作</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171218699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>获取数据对应的索引（排名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zrank key member<br>zrevrank key member<br></code></pre></td></tr></table></figure></li><li><p>score 值获取与修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zscore key member<br>zincrby key increment member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421171509850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于计数器组合排序功能对应的排名</p></li></ul><h2 id="sorted-set类型数据操作的注意事项"><a href="#sorted-set类型数据操作的注意事项" class="headerlink" title="sorted_set类型数据操作的注意事项"></a>sorted_set类型数据操作的注意事项</h2><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时侯要慎重</li><li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421171846808.png" alt="img"></p><p> <strong>解决方案</strong></p><ul><li><p>对于基于时间线限定的任务处理，将处理时间记录位score值，利用排序功能区分处理的先后顺序</p></li><li><p>记录下一个要处理的事件，当到期后处理对应的任务，移除redis中的记录，并记录下一个要处理的时间</p></li><li><p>当新任务加入时，判定并更新当前下一个要处理的任务时间</p></li><li><p>为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set.例如1小时内，1天内，年度等，操作时逐渐提升，将即将操作的若干个任务纳入到1小时内处理队列中</p></li><li><p>获取当前系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">time<br></code></pre></td></tr></table></figure><ul><li>redis应用于定时任务顺序管理或任务过期管理</li></ul></li></ul><p><strong>业务场景（任务/消息权重设定应用）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421172226972.png" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/2021042117234594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><p>带有权重的任务，优先处理权重高的任务，采用score记录权重即可</p><p><img src="https://img-blog.csdnimg.cn/20210421172537332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记4 Set数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Set%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的。</p><p><img src="https://img-blog.csdnimg.cn/20210421154631120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2021042115482653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h2 id="set类型数据的基本操作"><a href="#set类型数据的基本操作" class="headerlink" title="set类型数据的基本操作"></a>set类型数据的基本操作</h2><ul><li><p>添加书籍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取全部数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smembers key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srem key member1 [member2]<br></code></pre></td></tr></table></figure></li><li><p>获取集合数据总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scard key<br></code></pre></td></tr></table></figure></li><li><p> 判断集合中是否包含指定数据</p></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sismember key member<br></code></pre></td></tr></table></figure><h2 id="set类型数据的扩展操作1"><a href="#set类型数据的扩展操作1" class="headerlink" title="set类型数据的扩展操作1"></a>set类型数据的扩展操作1</h2><p><strong>业务操作</strong></p><p>每位用户首次使用进入头条时候会设置3项爱好的内容，但是后期为了增加用户的活跃度，兴趣点，必须让用户对其他信息类别逐渐产生兴趣，增加客户留存度，如何实现？</p><p><strong>业务分析</strong></p><ul><li>系统分析出各个分类的最新或最热点信息条目并组织成set集合</li><li>随机挑选其中部分信息</li><li>配合用户关注信息分类中的热点信息组织展示的全信息集合</li></ul><p><strong>解决方案</strong></p><ul><li><p>随机获取集合中指定数量的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">srandmember key [count]<br></code></pre></td></tr></table></figure></li><li><p>随机获取集合中的某个数据并将该数据移除集合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">spop key<br></code></pre></td></tr></table></figure></li><li><p>redis应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热点旅游线路，应用APP推荐，大V推荐等</p></li></ul><h2 id="set类型数据的扩展操作2"><a href="#set类型数据的扩展操作2" class="headerlink" title="set类型数据的扩展操作2"></a>set类型数据的扩展操作2</h2><ul><li><p>求两个集合的交、并、差集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinter key [key2]<br></code></pre></td></tr></table></figure></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sinterstore destination key1 [key2]<br>sunionstore destination key1 [key2]<br>sdiffstore destination key1 [key2]<br><br></code></pre></td></tr></table></figure></li><li><p>将指定数据从原始集合中移动到目标集合中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smove source destination member<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421162116514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>redis应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</p></li><li><p>显示共同关注（一度）</p></li><li><p>显示共同好友（一度）</p></li><li><p>由用户A出发，获取到好友用户B的好友信息列表（一度）</p></li><li><p>由用户A出发，获取到好友用户B的购物清单列表（二度）</p></li><li><p>由用户A出发，获取到好友用户B的游戏充值列表（二度）</p></li></ul><h2 id="set类型数据操作的注意事项"><a href="#set类型数据操作的注意事项" class="headerlink" title="set类型数据操作的注意事项"></a>set类型数据操作的注意事项</h2><ul><li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li><li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li></ul><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421162650651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>依赖set集合数据不重复的特征，依赖set集合hash存储结构特征完成数据过滤与快速查询</li><li>根据用户id获取用户所有角色</li><li>根据用户所有角色获取用户所有操作权限放入set集合</li><li>根据用户所有觉得获取用户所有数据全选放入set集合</li></ul><p><strong>校验工作</strong>：</p><p>​    redis提供基础数据还是提供校验结果</p><ul><li>redis应用于同类型不重复数据的合并操作</li></ul><h2 id="set类型应用场景"><a href="#set类型应用场景" class="headerlink" title="set类型应用场景"></a>set类型应用场景</h2><p><strong>业务场景</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163055810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li>利用set集合的数据去重特征，记录各种访问数据</li><li>建立string类型数据，利用incr统计日访问量（PV)</li><li>建立set模型，记录不同cookie数量（UV)</li><li>建立set模型，记录不用IP数量（IP)</li></ul><p><strong>业务场景（黑白名单）</strong></p><p><img src="https://img-blog.csdnimg.cn/20210421163311178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><ul><li><p>基于经营战略设定问题用户发现、鉴别规则</p></li><li><p>周期性更行满足规则的用户黑名单，加入set集合</p></li><li><p>用户行为信息达到后与黑名单进行比比对，确认行为去向</p></li><li><p>黑名单过滤IP地址：应用于开放游客访问权限的信息源</p></li><li><p>黑名单过滤设备信息：应用于限定访问设备的信息源</p></li><li><p>黑名单过滤用户：应用于基于访问权限的信息源</p></li><li><p>redis应用于基于黑名单与白名单设定的服务控制</p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记3 List数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用双向链表存储结构实现</p><p><img src="https://img-blog.csdnimg.cn/20210421145318123.png" alt="img"></p></li></ul><h2 id="list类型数据基本操作"><a href="#list类型数据基本操作" class="headerlink" title="list类型数据基本操作"></a>list类型数据基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush key value [value2]...   #在key对应的list头部添加元素<br>rpush key value [value2]...   #在key对应的list尾部添加元素<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrange key start stop    <br>lindex key index<br>llen key<br><br></code></pre></td></tr></table></figure></li><li><p>获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpop key                      #在key对应的list头部删除元素<br>rpop key                      #在key对应的list尾部删除元素<br></code></pre></td></tr></table></figure></li><li><p>规定时间内获取并移除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">blpop key1 [key2] timeout<br>brpop key1 [key2] timeout<br></code></pre></td></tr></table></figure><p>阻塞式获取，获取值如果还没有的时候等待，如果有值就获取。</p></li></ul><h2 id="list类型数据扩展操作"><a href="#list类型数据扩展操作" class="headerlink" title="list类型数据扩展操作"></a>list类型数据扩展操作</h2><p><strong>业务场景</strong></p><p>微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息</p><p><img src="https://img-blog.csdnimg.cn/20210421151850933.png" alt="img"></p><p><strong>解决方案</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lrem key count value<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210421152228925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>redis 应用于具有操作先后顺序的数据控制</li></ul><h2 id="list类型数据操作注意事项"><a href="#list类型数据操作注意事项" class="headerlink" title="list类型数据操作注意事项"></a>list类型数据操作注意事项</h2><ul><li>list保存的数据都是string类型，数据总容量有限，最多2[^32]-1个元素。</li><li>list具有索引概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式入栈出栈操作</li><li>获取全部数据操作结束索引设置为-1</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第二页及更多的信息通过数据库的形式加载</li></ul><h2 id="list类型应用场景"><a href="#list类型应用场景" class="headerlink" title="list类型应用场景"></a>list类型应用场景</h2><p><strong>业务场景</strong></p><ol><li>twitter、新浪微博、腾讯微博中个人用于的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最近关注的粉丝列在前面</li><li>新闻、资讯类网站如何将最新的新闻或资讯按照发生的事件顺序展示</li><li>企业运营过程中，系统将产生出大量的运营数据，如何保障堕胎服务器操作日志的统一顺序输出？</li></ol><p><strong>解决方案</strong></p><ul><li>依赖list的数据具有顺序的特征对信息进行管理</li><li>使用队列模型解决多路信息汇总合并的问题</li><li>使用栈模型解决最新消息的问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记2 Hash数据类型</title>
    <link href="/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/21/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Hash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、hash类型"><a href="#一、hash类型" class="headerlink" title="一、hash类型"></a>一、hash类型</h2><ul><li><p>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息。</p></li><li><p>需要的存储结构：一个存储空间保存多个键值对数据</p></li><li><p>hash类型：底层使用哈希表结构实现数据存储。</p><p><img src="https://img-blog.csdnimg.cn/20210413221436565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><p><strong>hash存储结构优化</strong></p><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul><h2 id="二、hash类型数据的基本操作"><a href="#二、hash类型数据的基本操作" class="headerlink" title="二、hash类型数据的基本操作"></a>二、hash类型数据的基本操作</h2><ul><li>添加/修改数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset key field value<br></code></pre></td></tr></table></figure></li><li>获取数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hget key field<br>hgetall key<br></code></pre></td></tr></table></figure></li><li>删除数据<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hdel key field1 [field2]<br></code></pre></td></tr></table></figure></li><li>获取哈希表中是否存在指定的字段<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexists key field<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、hash类型数据拓展操作"><a href="#三、hash类型数据拓展操作" class="headerlink" title="三、hash类型数据拓展操作"></a>三、hash类型数据拓展操作</h2><ul><li>获取哈希表中所有的字段名或字段值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hkeys key<br></code></pre></td></tr></table></figure></li><li>设定指定字段的数值数据增加指定范围的值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby key field increment<br>hincrbyfloat key field increment<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、hash类型数据操作的注意事项"><a href="#四、hash类型数据操作的注意事项" class="headerlink" title="四、hash类型数据操作的注意事项"></a>四、hash类型数据操作的注意事项</h2><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li><li>每个hash可以存储2的32次方-1个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，不可滥用，不能将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈。</li></ul><h2 id="五、hash类型的应用场景"><a href="#五、hash类型的应用场景" class="headerlink" title="五、hash类型的应用场景"></a>五、hash类型的应用场景</h2><p><strong>业务场景1</strong></p><p>电商网站购物车的实现</p><p><img src="https://img-blog.csdnimg.cn/20210414104649492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>业务分析</strong></p><ul><li>仅分析购物车的redis存储模型（添加、浏览、更改数量、删除、清空</li><li>购物车与数据库间持久化同步</li><li>购物车与订单间关系（提交购物车：读取数据生成订单 商家临时价格调整：隶属于订单级别）</li><li>未登录用户购物车信息存储（cookie存储）</li></ul><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414110019950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210414110917809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>当前设计是否加速了购物车的呈现</strong><br>当前仅仅是将数据存储到reids中，并没有起到加速的作用，商品还需要二次查询数据库</p><ul><li>每条购物车中的商品记录保存成两条field</li><li>field1专用于保存购买数量<br> 命名格式：商品id：nums<pre><code> 保存数据：数值</code></pre></li><li>field2专用于保存购物车中的显示信息，包含文字描述，图片地址，所属商家信息等<br>命名格式：商品id：info<br>保存数据：json</li></ul><p><strong>我们可以把field2作为独立hash，来减少数据的重复</strong><br><font color=#999AAA>创建数据，如果已存在数据则创建失败，如果没有则创建成功</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hsetnx key field value<br></code></pre></td></tr></table></figure><p><strong>业务场景2</strong></p><p>抢购活动</p><p><img src="https://img-blog.csdnimg.cn/20210414111343238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>解决方案</strong></p><p><img src="https://img-blog.csdnimg.cn/20210414111420146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><font color=#999AAA>创建id为00001的商铺，货物1 25个，货物2 100个。</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hmset shopping:id:00001 good1 25 good2 100<br></code></pre></td></tr></table></figure><p><font color=#999AAA>店铺货物1被抢走了10个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hincrby shopping:id:00001 good1 -10<br></code></pre></td></tr></table></figure><hr><p>学习链接:<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记1 String数据类型</title>
    <link href="/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/04/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-数据类型"><a href="#redis-数据类型" class="headerlink" title="redis 数据类型"></a>redis 数据类型</h1><ol><li>String</li><li>Hash</li><li>list</li><li>set</li><li>sorted_set</li></ol><h1 id="String数据类型"><a href="#String数据类型" class="headerlink" title="String数据类型"></a>String数据类型</h1><h2 id="1-redis-数据存储格式"><a href="#1-redis-数据存储格式" class="headerlink" title="1.redis 数据存储格式"></a>1.redis 数据存储格式</h2><ul><li><p> redis自身是一个Map，其中所有的数据类型都是采用key：value的形式存储。</p></li><li><p>数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串。</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>name</td><td>Ruby</td></tr><tr><td>age</td><td>17</td></tr></tbody></table></li></ul><h2 id="2-string类型"><a href="#2-string类型" class="headerlink" title="2.string类型"></a>2.string类型</h2><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</li><li>-存储数据的格式：一个存储空间保存一个数据</li><li>存储内容：通常使用字符串，如果字符串以整数形式展示，可作为数字操作使用。</li></ul><h2 id="3-string类型数据的基本操作"><a href="#3-string类型数据的基本操作" class="headerlink" title="3.string类型数据的基本操作"></a>3.string类型数据的基本操作</h2><ul><li><p>添加/修改数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key value<br></code></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">get key<br></code></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">del key<br></code></pre></td></tr></table></figure></li><li><p>添加/修改多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mset key1 value1 key2 value2 ...<br></code></pre></td></tr></table></figure></li><li><p>获取多个数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mget key<br></code></pre></td></tr></table></figure></li><li><p>获取数据字符串个数（字符串长度）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">strlen key<br></code></pre></td></tr></table></figure></li><li><p>追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">append key value<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-string类型数据的拓展操作"><a href="#4-string类型数据的拓展操作" class="headerlink" title="4.string类型数据的拓展操作"></a>4.string类型数据的拓展操作</h2><ul><li><p>设置数据具有指定的生命周期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set key seconds value<br>psetex key milliseconds value<br></code></pre></td></tr></table></figure><p><em>设置user时效为5s，超出5秒则无法获取。</em></p><p><img src="https://img-blog.csdnimg.cn/20210413204021597.png" alt="img"></p></li><li><p>redis控制数据的生命周期，通过数据是否失效控制业务，适用于所有具有时效性限定控制的操作</p></li></ul><h2 id="5-string类型数据操作的注意事项"><a href="#5-string类型数据操作的注意事项" class="headerlink" title="5.string类型数据操作的注意事项"></a>5.string类型数据操作的注意事项</h2><pre><code>1. 表示运行结果是否成功 （integer）0 → false 失败 （integer）1 → true 成功</code></pre><ol start="2"><li>表示运行结果值<br>（integer） 3 → 3 3个<br> （integer） 1 →1 1个</li><li>数据未获取<br>（nil）== null</li><li>数据最大存储量<br>512MB</li><li>数据计算最大范围（java中的long的最大值）<br>9223372036854775807</li></ol><h2 id="6-业务场景"><a href="#6-业务场景" class="headerlink" title="6.业务场景"></a>6.业务场景</h2><ul><li>主页高频访问信息显示控制，列如新浪微博大V主页显示粉丝数于微博数量</li></ul><p><strong>解决方案</strong> </p><ul><li>在redis中为大v用户设定用户信息，以用户主键和属性值为key，后台设定定时刷新策略。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210413210057424.png" alt="img"></p><ul><li><p>在redis中以json格式存储大v用户，定时刷新</p><p><img src="https://img-blog.csdnimg.cn/20210413210832666.png" alt="img"></p></li></ul><h2 id="7-key的设置约定"><a href="#7-key的设置约定" class="headerlink" title="7.key的设置约定"></a>7.key的设置约定</h2><ul><li><p>热点数据key命名管理</p><p><img src="https://img-blog.csdnimg.cn/20210413211455137.png" alt="img"></p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的网站推荐</title>
    <link href="/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2021/04/19/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<p>一些我平常使用的网站，个人觉得还都挺不错的，就写在上面推荐一下。</p><h2 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h2><h3 id="1-Canva"><a href="#1-Canva" class="headerlink" title="1.Canva"></a>1.Canva</h3><p>网址：<a href="https://www.canva.cn/">https://www.canva.cn</a></p><p>这是一个在线设计的网站。各种实用模板，包括海报，PPT、微信公众号封面，LOGI等。还有一些不同的图片素材。</p><p><img src="https://img-blog.csdnimg.cn/20210420210755800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Pexels"><a href="#2-Pexels" class="headerlink" title="2.Pexels"></a>2.Pexels</h3><p>网址：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></p><p>具有很丰富的高质量图片网站，不光可以免费下载高清图片，而且还可以下载视频，没有版权。</p><p><img src="https://img-blog.csdnimg.cn/20210420211431755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="3-Pixabay"><a href="#3-Pixabay" class="headerlink" title="3.Pixabay"></a>3.Pixabay</h2><p>网址：<a href="https://pixabay.com/">https://pixabay.com/</a></p><p>拥有很多创意向，高清的图片，可以免费下载。</p><p><img src="https://img-blog.csdnimg.cn/20210420212000239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="4-wallhaven"><a href="#4-wallhaven" class="headerlink" title="4.wallhaven"></a>4.wallhaven</h2><p>网址：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p><p>有很多不同种类的图片，分辨率非常高，适合用来当作壁纸或各种背景图。</p><p><img src="https://img-blog.csdnimg.cn/20210420212653446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="5-Iconfont"><a href="#5-Iconfont" class="headerlink" title="5.Iconfont"></a>5.Iconfont</h2><p>网址：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p>这是国内第一个最大功能最全的矢量图标库，由阿里巴巴团队稻造的，拥有大量不同的图标，基本上都可以找到自己想要的。</p><p><img src="https://img-blog.csdnimg.cn/20210420213110352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="6-中国色"><a href="#6-中国色" class="headerlink" title="6.中国色"></a>6.中国色</h3><p>网址：<a href="http://zhongguose.com/">http://zhongguose.com/</a></p><p>带有国风色彩的颜色搭配网站。点击RGB搭配的右侧就可以复制、导入颜色了。</p><p><img src="https://img-blog.csdnimg.cn/20210420222253614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="7-ColorHexa"><a href="#7-ColorHexa" class="headerlink" title="7.ColorHexa"></a>7.ColorHexa</h3><p>网址：<a href="https://www.colorhexa.com/">https://www.colorhexa.com/</a></p><p>这是一个方便，颜色种类众多的色彩搭配网站，只需输入想要搭配的颜色，就可以给出不同种的颜色搭配方案。</p><p><img src="https://img-blog.csdnimg.cn/20210420222635239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="学术导航类"><a href="#学术导航类" class="headerlink" title="学术导航类"></a>学术导航类</h2><h3 id="1-科塔学术导航"><a href="#1-科塔学术导航" class="headerlink" title="1.科塔学术导航"></a>1.科塔学术导航</h3><p>网址：<a href="https://site.sciping.com/">https://site.sciping.com/</a></p><p>一个质量不错的学术导航网站，站内分类包括文献数据，期刊出版，学术工具，科研软件，科研数据，学术搜索等。</p><p>它还提供科研社交，科学传播，科研机构版块，每一个版块也会进行具体网站分类；最后，网站的常用推荐功能也可以让你发现很多高质量的学术网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214033485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p>网址：<a href="https://www.chongbuluo.com/">https://www.chongbuluo.com/</a></p><p>功能齐全、很实用的学术搜索网站。</p><p><img src="https://img-blog.csdnimg.cn/20210420214747828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="课程学习类"><a href="#课程学习类" class="headerlink" title="课程学习类"></a>课程学习类</h2><h3 id="1-MOOC"><a href="#1-MOOC" class="headerlink" title="1.MOOC"></a>1.MOOC</h3><p>网址：<a href="https://www.icourse163.org/">https://www.icourse163.org/</a></p><p>国内联合750所高校共同开发的教学网站。收录了非常多名师教学课程。课程种类也非常齐全。</p><p><img src="https://img-blog.csdnimg.cn/20210420215331708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Visuwords"><a href="#2-Visuwords" class="headerlink" title="2.Visuwords"></a>2.Visuwords</h3><p>网址：<a href="https://visuwords.com/">https://visuwords.com/</a></p><p>这是一个比较有趣的交互式单词学习网站，当你输入一个单词回车后，会给出这个单词的近义词、反义词、从属关系词、因果关系词、属性、实例、分词、动词等等。</p><p>它通过不同的颜色和线条，不同颜色的球体构成一个单词树状图，来代表不同单词之间的关系和类型。</p><p><img src="https://img-blog.csdnimg.cn/20210420220418339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-白描"><a href="#1-白描" class="headerlink" title="1.白描"></a>1.白描</h3><p>网址：<a href="https://web.baimiaoapp.com/">https://web.baimiaoapp.com/</a></p><p>这是一个在线扫描工具，有图片文字提取，电子表格识别，PDF转文字，都是免费使用。</p><p><img src="https://img-blog.csdnimg.cn/20210420221121669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="2-Docsmall"><a href="#2-Docsmall" class="headerlink" title="2.Docsmall"></a>2.Docsmall</h3><p>网址：<a href="https://docsmall.com/">https://docsmall.com/</a></p><p>一个免费在线文件压缩网站，只要上传文件之后，进行处理，在下载就ok了，目前支持图片压缩、GIF压缩、PDF压缩、PDF合并、PDF分割功能。</p><p><img src="https://img-blog.csdnimg.cn/20210420221534842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="3-地图生成器"><a href="#3-地图生成器" class="headerlink" title="3.地图生成器"></a>3.地图生成器</h3><p>网址： <a href="http://datav.aliyun.com/tools/atlas/#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5">点击这里</a></p><p>可以下载国内省份，城市以及县城的svg格式的地图素材，并可以导入到PPT中，可编辑。</p><p><img src="https://img-blog.csdnimg.cn/20210420222012372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70" alt="img"></p><hr><p>后续遇到比较不错的网址还会继续更新下去…</p>]]></content>
    
    
    <categories>
      
      <category>好用的网站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
