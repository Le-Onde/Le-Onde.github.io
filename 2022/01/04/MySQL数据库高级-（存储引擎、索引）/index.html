

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/newcon.png">
  <link rel="icon" href="/img/newfav.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>MySQL数据库高级 - （存储引擎、索引） - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":64,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Le Onde</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                种类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img-blog.csdnimg.cn/20210421122657715.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MySQL数据库高级 - （存储引擎、索引）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-04 20:08" pubdate>
        January 4, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      74
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL数据库高级 - （存储引擎、索引）</h1>
            
            <div class="markdown-body">
              <h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>和其他数据库相比，MySQL有点与众不同，主要体现在存储引擎的架构上， <strong>插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。</strong> 这种架构可以根据业务的需求和实际需求选择合适的存储引擎</p>
<p><strong>逻辑架构分层</strong></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20200801165252510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70&sign=d1c65036ff7287ece25e17ae94969afa75e98009ed87605ff484bbc22ba0ae73&x-oss-process=image/resize,w_750,limit_0" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>连接层：</strong> 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于<code>tcp/ip</code>的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于<code>SSL</code>的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </li>
<li><strong>服务层：</strong> MySQL的核心服务功能层，该层是MySQL的核心，包括查询缓存，解析器，解析树，预处理器，查询优化器。主要进行查询解析、分析、查询缓存、内置函数、存储过程、触发器、视图等，select操作会先检查是否命中查询缓存，命中则直接返回缓存数据，否则解析查询并创建对应的解析树。 </li>
<li><strong>引擎层：</strong> 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 </li>
<li><strong>存储层：</strong> 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 </li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><code>show engines;</code> 命令查看MySQL5.7支持的存储引擎</p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20200801170442428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70&sign=fcedb5b8062023360b517c863e09d5645d28ab1ba1d4a2af19d17348080357fc&x-oss-process=image/resize,w_750,limit_0" srcset="/img/loading.gif" lazyload></p>
<p><code>show variables like &#39;default_storage_engine%&#39;;</code> 查看当前数据库正在使用的存储引擎</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">+------------------------+--------+<br>| Variable_name          | Value  |<br>+------------------------+--------+<br>| default_storage_engine | InnoDB |<br>+------------------------+--------+<br>1 row in set, 1 warning (0.12 sec)<br></code></pre></td></tr></table></figure>

<h3 id="InnoDB和MyISAM对比"><a href="#InnoDB和MyISAM对比" class="headerlink" title="InnoDB和MyISAM对比"></a>InnoDB和MyISAM对比</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整张表，<strong>不适合高并发操作</strong></td>
<td>行锁，操作时只锁某一行，不对其他行有影响，<strong>适合高并发操作</strong></td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据 ，对内存要求较高，而且内存大小対性能有决定性影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常称为事务的ACID属性</p>
<ul>
<li><strong>原子性 （Atomicity)</strong> ：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li>
<li>**一致性（Consistent)**：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li>
<li><strong>持久性（Durable）</strong>：事务完成之后，他对于数据的修改是永久性的，即使出现系统故障也能够保持。 </li>
</ul>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>隔离性要考虑多个线程操作同一个资源造成的多线程并发安全问题。</p>
<p>加锁可以非常完美的保证隔离性，但是这会造成数据库性能的大大下降。</p>
<ul>
<li>如果两个事务并发的修改——必须隔离开</li>
<li>如果两个事务并发的查询——完全不用隔离</li>
<li>如果一个事务修改，另一个事务查询——脏读、不可重复读、虚读</li>
</ul>
<h5 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a><strong>1、脏读</strong></h5><p>（<strong>一个事务读取到另一个事务未提交的数据</strong>）</p>
<p>下面的例子，a就这样骗走了b的100块钱的货物</p>
<p><img src="https://img-blog.csdnimg.cn/2019040322134078.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/20190403221951989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h5 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a><strong>2、不可重复读</strong></h5><p>（<strong>一个事务读取到另一个事务已经提交的数据</strong>）</p>
<p>下面的例子，b获取的数据前后不一致</p>
<p><img src="https://img-blog.csdnimg.cn/20190403220513247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h5 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3.幻读"></a>3.<strong>幻读</strong></h5><p>（一个事务多次查询整表数据，由于其他事务新增（删除）记录造成多次查询的记录条数不同（<strong>一个事务读取到另一个事务已经提交的数据</strong>））</p>
<p>下面的例子，在d做查询的时候，c进来存了2000块，造成avg的结果与预期不一致</p>
<p><img src="https://img-blog.csdnimg.cn/20190403222929418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h5 id="针对上面的三个问题，数据库提出四大隔离级别"><a href="#针对上面的三个问题，数据库提出四大隔离级别" class="headerlink" title="针对上面的三个问题，数据库提出四大隔离级别"></a>针对上面的三个问题，数据库提出四大隔离级别</h5><ul>
<li><strong>read uncommitted</strong>——不作任何隔离，具有脏读、不可重复读、幻读问题</li>
<li><strong>read committed</strong>——可防止脏读，不能防止不可重复读和幻读问题</li>
<li><strong>repeatable read</strong>——可以防止脏读、不可重复读，不能防止幻读问题（mysql默认是这个隔离级别）</li>
<li><strong>serializable</strong>——数据库运行在串行化，上述问题都可以防止，只是性能非常低</li>
</ul>
<p><strong>设置隔离级别的语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set [session&#x2F;global] transaction isolation level ...;——修改隔离级别<br> <br>select @@tx_isolation;——查询当前数据库的隔离级别<br></code></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="sql性能下降原因"><a href="#sql性能下降原因" class="headerlink" title="sql性能下降原因"></a>sql性能下降原因</h3><ul>
<li>查询语句写的差</li>
<li>索引失效：索引建了，但没有用上</li>
<li>关联 查询太多join（设计缺陷或者不得已的需求）</li>
<li>服务器调优以及各个参数的设置（缓冲、线程数等）</li>
</ul>
<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul>
<li>手写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select             <br>from           <br>join		<br>on					<br>where             <br>group by            <br>having             <br>distinct		<br>order by           <br>limit              <br></code></pre></td></tr></table></figure>

<ul>
<li>机读</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">from<br>on<br>join<br>where<br>group by<br>having<br>select<br>distinct<br>order by<br>limit<br></code></pre></td></tr></table></figure>

<h3 id="七种JOIN理论"><a href="#七种JOIN理论" class="headerlink" title="七种JOIN理论"></a>七种JOIN理论</h3><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20200801212011559.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70&sign=f8e02c35786d75e2ee049b1a82268416816fc2de33a2cf52d0d239f8a1039083&x-oss-process=image/resize,w_750,limit_0" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;* 1 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key &#x3D; B.Key;<br><br>&#x2F;* 2 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key &#x3D; B.Key;<br><br>&#x2F;* 3 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A INNER JOIN TableB B ON A.Key &#x3D; B.Key;<br><br>&#x2F;* 4 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key &#x3D; B.Key WHERE B.Key IS NULL;<br><br>&#x2F;* 5 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key &#x3D; B.Key WHERE A.Key IS NULL;<br><br>&#x2F;* 6 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key &#x3D; B.Key;<br>&#x2F;* MySQL不支持FULL OUTER JOIN这种语法 可以改成 1+2 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key &#x3D; B.Key<br>UNION<br>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key &#x3D; B.Key;<br><br>&#x2F;* 7 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A FULL OUTER JOIN TableB B ON A.Key &#x3D; B.Key <br>WHERE A.Key IS NULL OR B.Key IS NULL;<br>&#x2F;* MySQL不支持FULL OUTER JOIN这种语法 可以改成 4+5 *&#x2F;<br>SELECT &lt;select_list&gt; FROM TableA A LEFT JOIN TableB B ON A.Key &#x3D; B.Key <br>WHERE B.Key IS NULL;<br>UNION<br>SELECT &lt;select_list&gt; FROM TableA A RIGHT JOIN TableB B ON A.Key &#x3D; B.Key <br>WHERE A.Key IS NULL;<br></code></pre></td></tr></table></figure>

<h3 id="1-索引简介"><a href="#1-索引简介" class="headerlink" title="1.索引简介"></a>1.索引简介</h3><p>索引是帮助MySQL高效获取数据的数据结构</p>
<p>即 <strong>索引是排好序的快速查找数据结构</strong></p>
<p>索引目的在于提高查询效率，可以类比字典的目录。如果要查<code>mysql</code>这个这个单词，我们肯定要先定位到<code>m</code>字母，然后从上往下找<code>y</code>字母，再找剩下的<code>sql</code>。</p>
<p><strong>重点：索引会影响到MySQL查找（WHERE的查询条件）和排序（ORDER BY）两大功能</strong></p>
<p>除了数据本身之外， <strong>数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据</strong>，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引 </p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。</p>
<p>我们平时所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了<strong>B+树</strong>这种数据结构的索引之外，还有<strong>哈希索引</strong>（Hash Index）等。</p>
<h3 id="2-索引的优势和劣势"><a href="#2-索引的优势和劣势" class="headerlink" title="2.索引的优势和劣势"></a>2.索引的优势和劣势</h3><p><strong>优势</strong></p>
<ul>
<li>查找：类似大学图书馆的书目索引， <strong>提高数据检索的效率，降低数据库的IO成本</strong></li>
<li>排序：通过索引对数据进行排序， <strong>降低数据排序的成本，降低了CPU的消耗</strong></li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以 <strong>索引列也是要占空间的</strong></li>
<li>虽然索引大大提高了查询速度，但是同时<strong>会降低表的更新速度</strong>，例如对表频繁的进行<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
<li>索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引</li>
</ul>
<h3 id="3-MySQL索引分类"><a href="#3-MySQL索引分类" class="headerlink" title="3.MySQL索引分类"></a>3.MySQL索引分类</h3><ul>
<li>单值索引：一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引：索引列的值必须是唯一，但是允许空值</li>
<li>复合索引：一个索引包含多个字段</li>
</ul>
<p><strong>建议：一张表建的索引最好不超过5个</strong></p>
<h4 id="索引建立"><a href="#索引建立" class="headerlink" title="索引建立"></a>索引建立</h4><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;* 1、创建索引 [UNIQUE]可以省略*&#x2F;<br>&#x2F;* 如果只写一个字段就是单值索引，写多个字段就是复合索引 *&#x2F;<br>CREATE [UNIQUE] INDEX indexName ON tabName(columnName(length));<br>ALTER TABLE tabName ADD [UNIQUE] INDEX indexName ON (columnName(length));<br><br>&#x2F;* 2、删除索引 *&#x2F;<br>DROP INDEX [indexName] ON tabName;<br><br>&#x2F;* 3、查看索引 *&#x2F;<br>&#x2F;* 加上\G就可以以列的形式查看了 不加\G就是以表的形式查看 *&#x2F;<br>SHOW INDEX FROM tabName \G;<br></code></pre></td></tr></table></figure>

<p><strong>使用</strong><code>**ALTER**</code><strong>命令来为数据表添加索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&#x2F;* 1、该语句添加一个主键，这意味着索引值必须是唯一的，并且不能为NULL *&#x2F;<br>ALTER TABLE tabName ADD PRIMARY KEY(column_list);<br><br>&#x2F;* 2、该语句创建索引的键值必须是唯一的(除了NULL之外，NULL可能会出现多次) *&#x2F;<br>ALTER TABLE tabName ADD UNIQUE indexName(column_list);<br><br>&#x2F;* 3、该语句创建普通索引，索引值可以出现多次 *&#x2F;<br>ALTER TABLE tabName ADD INDEX indexName(column_list);<br><br>&#x2F;* 4、该语句指定了索引为FULLTEXT，用于全文检索 *&#x2F;<br>ALTER TABLE tabName ADD FULLTEXT indexName(column_list);<br></code></pre></td></tr></table></figure>

<h3 id="4-MySQL索引数据结构"><a href="#4-MySQL索引数据结构" class="headerlink" title="4.MySQL索引数据结构"></a>4.MySQL索引数据结构</h3><p>索引数据结构：</p>
<ul>
<li><p><code>B+Tree</code>索引</p>
</li>
<li><p><code>Hash</code>索引</p>
</li>
<li><p><code>Full-text</code>全文索引</p>
</li>
<li><p><code>R-Tree</code>索引</p>
</li>
</ul>
<p><strong>B+Tree索引检索原理</strong></p>
<p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20200801233134931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70&sign=cd7427d35454f375fd6d8b476934ad767cfeb58aa79a70b5d58a6223b8475a48&x-oss-process=image/resize,w_750,limit_0" srcset="/img/loading.gif" lazyload></p>
<h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvOC5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvOS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。<strong>因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</strong></p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p><strong>第一个重大区别是InnoDB的数据文件本身就是索引文件。</strong>从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvMTAucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<strong>聚集索引</strong>。<strong>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</strong>，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p><strong>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</strong>如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY29kaW5nbGFicy5vcmcvdXBsb2Fkcy9waWN0dXJlcy90aGVvcnktb2YtbXlzcWwtaW5kZXgvMTEucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-哪些情况需要建立索引"><a href="#5-哪些情况需要建立索引" class="headerlink" title="5.哪些情况需要建立索引"></a>5.哪些情况需要建立索引</h3><ul>
<li>主键 <strong>自动建立</strong>主键索引（唯一 + 非空）</li>
<li><strong>频繁作为查询条件的字段</strong>应该创建索引</li>
<li>查询中与其他表关联的字段， <strong>外键</strong>关系建立索引</li>
<li>查询中 <strong>排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度，建的复合索引尽量与Order by一致</li>
<li>查询中 <strong>统计或者分组字段(group by也和索引有关)</strong></li>
</ul>
<h3 id="6-哪些情况不需要建立索引"><a href="#6-哪些情况不需要建立索引" class="headerlink" title="6.哪些情况不需要建立索引"></a>6.哪些情况不需要建立索引</h3><ul>
<li>记录太少的表</li>
<li>经常增删改的表</li>
<li>频繁更新的字段不适合创建索引</li>
<li>Where条件里用不到的字段不需要创建索引</li>
</ul>
<p>索引建立选择</p>
<p>假如一个表有10万行记录，有一个字段A只有true和false两种值，并且每个值的分布概率大约为50%，那么对A字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是980/2000=0.99。<strong>一个索引的选择性越接近于1，这个索引的效率就越高。</strong> </p>
<h3 id="7-性能分析"><a href="#7-性能分析" class="headerlink" title="7.性能分析"></a>7.性能分析</h3><h4 id="7-1-MySQL-Query-Optimizer"><a href="#7-1-MySQL-Query-Optimizer" class="headerlink" title="7.1 MySQL Query Optimizer"></a>7.1 MySQL Query Optimizer</h4><p>MySQL中专门负责优化SELECT语句的优化器模块</p>
<p>主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的执行计划（它认为最优的数据检索方式，但不见得是DBA认为最优的，这部分最耗费时间）</p>
<p>当客户端像MySQL请求一条Query，命令解析器模块完成请求分类，去别处是SELECT并转发给MySQL Query Optimizer ，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件，结构调整等。然后分析Query中的Hint信息（如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读区所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p>
<h4 id="7-2MySQL常见瓶颈"><a href="#7-2MySQL常见瓶颈" class="headerlink" title="7.2MySQL常见瓶颈"></a>7.2MySQL常见瓶颈</h4><p><strong>CPU</strong>：CPU再饱和的时候一般发生再数据装入内存或从磁盘上读取数据的时候</p>
<p><strong>IO</strong>：磁盘IO瓶颈发生在装入数据远大于内存容量的时候</p>
<p><strong>服务器硬件的性能瓶颈</strong>：top free iostat和vmstat来查看系统的性能状态</p>
<h4 id="7-3-EXPLAIN"><a href="#7-3-EXPLAIN" class="headerlink" title="7.3 EXPLAIN"></a>7.3 EXPLAIN</h4><h5 id="EXPLAIN是什么"><a href="#EXPLAIN是什么" class="headerlink" title="EXPLAIN是什么"></a><strong>EXPLAIN是什么</strong></h5><ul>
<li>EXPLAIN：SQL的执行计划，使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的。</li>
</ul>
<h5 id="EXPLAIN怎么使用"><a href="#EXPLAIN怎么使用" class="headerlink" title="EXPLAIN怎么使用"></a><strong>EXPLAIN怎么使用</strong></h5><ul>
<li>语法：<code>explain + SQL语句</code></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1379492/1635235826482-259cd8fb-85ae-42ff-bf65-93a0f9aa28a2.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; explain select * from pms_category \G;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: pms_category<br>   partitions: NULL<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 1425<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>

<h5 id="EXPLAIN能干嘛"><a href="#EXPLAIN能干嘛" class="headerlink" title="EXPLAIN能干嘛"></a><strong>EXPLAIN能干嘛</strong></h5><p>可以查看以下信息</p>
<ul>
<li><ul>
<li><code>id</code>：表的读取顺序</li>
<li><code>select_type</code>：数据读取操作的操作类型</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><code>possible_keys</code>：哪些索引可以使用</li>
<li><code>key</code>：哪些索引被实际使用</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><code>ref</code>：表之间的引用</li>
<li><code>rows</code>：每张表有多少行被优化器查询</li>
</ul>
</li>
</ul>
<h5 id="EXPLAIN字段"><a href="#EXPLAIN字段" class="headerlink" title="EXPLAIN字段"></a>EXPLAIN字段</h5><p><code>id</code>：表的读取和加载顺序</p>
<p>值有以下三种情况</p>
<ul>
<li><ul>
<li>id相同，执行顺序由上至下</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/20200204182922160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODg1Mzcy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><ul>
<li>id不同，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行</strong></li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/20200204183006883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODg1Mzcy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<ul>
<li><ul>
<li>id相同不同，同时存在。<strong>永远是id大的优先级最高，id相等的时候顺序执行</strong></li>
</ul>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/20200204185236742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODg1Mzcy,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><code>select_type</code>：数据查询的类型，主要是用于区别，普通查询、联合查询、子查询等的复杂查询。</p>
<ul>
<li><code>SIMPLE</code>：简单的<code>SELECT</code>查询，查询中不包含子查询或者<code>UNION</code>。</li>
<li><code>PRIMARY</code>：查询中如果包含任何复杂的子部分，最外层查询则被标记为<code>PRIMARY</code>。</li>
</ul>
<ul>
<li><code>SUBQUERY</code>：在<code>SELECT</code>或者<code>WHERE</code>子句中包含了子查询。</li>
<li><code>DERIVED</code>：在<code>FROM</code>子句中包含的子查询被标记为<code>DERIVED(衍生)</code>，MySQL会递归执行这些子查询，把结果放在临时表中。</li>
</ul>
<ul>
<li><code>UNION</code>：如果第二个<code>SELECT</code>出现在<code>UNION</code>之后，则被标记为<code>UNION</code>；若<code>UNION</code>包含在<code>FROM</code>子句的子查询中，外层<code>SELECT</code>将被标记为<code>DERIVED</code>。</li>
<li><code>UNION RESULT</code>：从<code>UNION</code>表获取结果的<code>SELECT</code>。</li>
</ul>
<p><code>type</code>：访问类型排列</p>
<p>​    <strong>从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。</strong> 除了ALL没有用到索引，其他级别都用到了索引</p>
<p>​    一般来说，得保证查询至少到达range级别，最好到达ref</p>
<ul>
<li><p><code>system</code></p>
<p>表只有一行记录（等于系统表），这是<code>const</code>类型的特例，平时不会出现，这个可以忽略不计。</p>
</li>
<li><p><code>const</code></p>
<p>表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code>或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>中，MySQL就能将该查询转化为一个常量 </p>
</li>
<li><p><code>eq_ref</code></p>
<p>唯一性索引扫描，对于每个索引值，表中只有一条记录与之匹配，常见于主键或唯一索引扫描。除了<code>system</code> 和<code>const</code> 类型之外, 这是最好的联接类型。 </p>
</li>
<li><p><code>ref</code></p>
<p>非唯一性索引扫描，返回本表和关联表某个值匹配的所有行，查出来有多条记录</p>
</li>
<li><p><code>range</code></p>
<p>只检索给定范围的行，一般就是在<code>WHERE</code>语句中出现了<code>BETWEEN</code>、<code>&lt; &gt;</code>、<code>in</code>等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引树的某一点，而结束于另一点，不用扫描全部索引。 </p>
</li>
<li><p><code>index</code></p>
<p><code>Full Index Scan</code>，全索引扫描，<code>index</code>和<code>All</code>的区别为<code>index</code>类型只遍历索引树。<strong>也就是说虽然</strong><code>ALL</code><strong>和</strong><code>index</code><strong>都是读全表，但是</strong><code>index</code><strong>是从索引中读的，</strong><code>ALL</code><strong>是从磁盘中读取的。</strong> </p>
</li>
<li><p><code>ALL</code></p>
<p><code>Full Table Scan</code>，没有用到索引，全表扫描</p>
<p>​</p>
</li>
</ul>
<p><code>possible_keys</code></p>
<p>​    显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出， <strong>但不一定实际使用</strong></p>
<p><code>key</code></p>
<p>​    实际使用的索引。如果为<code>NULL</code>，则没建或没有使用索引，即索引失效。<strong>查询中如果使用了覆盖索引，则该索引仅仅出现在</strong><code>key</code><strong>列表中。</strong>与Extra有关。</p>
<p><code>key_len</code></p>
<p>​    表示索引中使用的字节数。可通过该列计算查询中使用的索引的长度</p>
<p><code>key_len</code>显示的值为索引字段的最大可能长度，<strong>并非实际使用长度</strong></p>
<p><code>key_len</code>是根据表定义计算而得，不是通过表内检索出的。在不损失精度的情况下，长度越短越好。</p>
<ul>
<li> 索引列为字符串类型的情况</li>
</ul>
<p>  1)列长度：</p>
<ol start="2">
<li><p>列是否为空： NULL(+1)，NOT NULL(+0)</p>
</li>
<li><p>字符集： 如 utf8mb4=4,utf8=3,gbk=2,latin1=1</p>
</li>
<li><p>列类型为字符： 如 varchar(+2), char(+0)</p>
</li>
</ol>
<p>  计算公式：key_len=(表字符集长度) * 列长度 + 1(null) + 2(变长列)</p>
<ul>
<li><p>数值数据的key_len计算公式:</p>
<p>TINYINT允许NULL = 1 + 1(NULL)</p>
<p>SMALLINT允许为NULL = 2 + 1(NULL)</p>
<p>INT允许为NULL = 4 + 1(NULL)</p>
</li>
<li><p>日期时间型的key_len计算：（针对mysql5.5及之前版本）</p>
<p>DATETIME允许为NULL = 8 + 1(NULL)</p>
<p>TIMESTAMP允许为NULL = 4 + 1(NULL)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc pms_category;<br>+---------------+------------+------+-----+---------+----------------+<br>| Field         | Type       | Null | Key | Default | Extra          |<br>+---------------+------------+------+-----+---------+----------------+<br>| cat_id        | bigint(20) | NO   | PRI | NULL    | auto_increment |<br>| name          | char(50)   | YES  |     | NULL    |                |<br>| parent_cid    | bigint(20) | YES  |     | NULL    |                |<br>| cat_level     | int(11)    | YES  |     | NULL    |                |<br>| show_status   | tinyint(4) | YES  |     | NULL    |                |<br>| sort          | int(11)    | YES  |     | NULL    |                |<br>| icon          | char(255)  | YES  |     | NULL    |                |<br>| product_unit  | char(50)   | YES  |     | NULL    |                |<br>| product_count | int(11)    | YES  |     | NULL    |                |<br>+---------------+------------+------+-----+---------+----------------+<br>9 rows in set (0.00 sec)<br><br><br>mysql&gt; explain select cat_id from pms_category where cat_id between 10 and 20 \G;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: pms_category<br>   partitions: NULL<br>         type: range<br>possible_keys: PRIMARY<br>          key: PRIMARY  # 用到了主键索引，通过查看表结构知道，cat_id是bigint类型，占用8个字节<br>      key_len: 8        # 这里只用到了cat_id主键索引，所以长度就是8！<br>          ref: NULL<br>         rows: 11<br>     filtered: 100.00<br>        Extra: Using where; Using index<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>



<p><code>ref</code></p>
<p>​     显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
<p>​    NULL    const    库名.表名.字段</p>
<p><code>rows</code></p>
<p>​    根据表统计信息及索引选用情况，大致估算出找到所需的记录需要读取的行数。</p>
<p><code>Extra</code></p>
<p>​    包含不适合在其他列中显示但十分重要的额外信息</p>
<ul>
<li><p><code>Using filesort</code></p>
<p>说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取</p>
<p><strong>MySQL中无法利用索引完成的排序操作称为“文件内排序”</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user (<br>    id     integer primary key auto_increment,<br>    name   varchar(20) not null,<br>    age    integer     not null,<br>    gender tinyint     not null<br>);<br>create index user_name_gender on user(name, gender);<br><br># 排序没有使用索引<br>explain select * from user where name &#x3D;&#39;zhangsan1&#39; order by id \G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: user<br>   partitions: NULL<br>         type: ref<br>possible_keys: user_name_gender<br>          key: user_name_gender<br>      key_len: 62<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: Using index; Using filesort<br>1 row in set, 1 warning (0.00 sec)<br><br>#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~<br># 排序使用到了索引<br>explain select * from user where name &#x3D;&#39;zhangsan1&#39; order by gender \G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: user<br>   partitions: NULL<br>         type: ref<br>possible_keys: user_name_gender<br>          key: user_name_gender<br>      key_len: 62<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: Using index<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>Using temporary</code></p>
<p>使用了临时表保存中间结果，MySQL在对查询结果排序时使用了临时表。常见于排序<code>order by</code>和分组<code>group by</code>。 <strong>临时表对系统性能损耗很大</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select count(*) from user where gender &#x3D;18 group by age;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: user<br>   partitions: NULL<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 5<br>     filtered: 20<br>        Extra: Using where; Using temporary; Using filesort<br>1 row in set, 1 warning (0.00 sec)<br><br><br>explain select count(*) from user where gender &#x3D;18 group by name;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: user<br>   partitions: NULL<br>         type: index <br>possible_keys: user_name_gender<br>          key: user_name_gender<br>      key_len: 63<br>          ref: NULL<br>         rows: 5<br>     filtered: 20<br>        Extra: Using where; Using index<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>Using index</code></p>
<p>表示相应的SELECT操作中使用了 <strong>覆盖索引</strong> ，避免访问了表的数据行，效率不错。如果同时出现<code>select where</code>，表示索引被用来执行索引值的查找；如果没有同时出现<code>Using where</code>，表明索引用来读取数据而非执行查找动作</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 覆盖索引<br># 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。<br># 注意：如果要使用覆盖索引，一定不能写SELECT *，要写出具体的字段。<br>explain select name, gender from user;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: pms_category<br>   partitions: NULL<br>         type: index<br>possible_keys: NULL       <br>          key: user_name_gender<br>      key_len: 63<br>          ref: NULL<br>         rows: 5<br>     filtered: 100.00<br>        Extra: Using index   # select的数据列只用从索引中就能够取得，不必从数据表中读取   <br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Using where</code>表明使用了WHERE过滤。</li>
<li><code>Using join buffer</code>：使用了连接缓存。</li>
<li><code>impossible where：</code>WHERE`子句的值总是false，不能用来获取任何元组。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select name from user where name &#x3D; &#39;zs&#39; and name &#x3D; &#39;ls&#39;\G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: NULL<br>   partitions: NULL<br>         type: NULL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: NULL<br>     filtered: NULL<br>        Extra: Impossible WHERE   # 不可能字段同时查到两个名字<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/MySQL/">MySQL</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7-%EF%BC%88%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%89/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL数据库高级 - （索引优化）</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/22/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%EF%BC%88%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%89/">
                        <span class="hidden-mobile">MySQL数据库基本操作 - （多表操作、函数、视图、存储过程、触发器）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.lazyComments('valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "99lfyqRg3CLazXoohVQjMwH3-gzGzoHsz",
          app_key: "qx9rFQuqjhuegpH6AwJ8B0eD",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
