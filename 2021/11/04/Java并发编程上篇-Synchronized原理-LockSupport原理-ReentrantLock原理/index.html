

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/newcon.png">
  <link rel="icon" href="/img/newfav.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>Java并发编程上篇 - (Synchronized原理,LockSupport原理,ReentrantLock原理) - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":64,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Le Onde</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                种类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img-blog.csdnimg.cn/20210421122657715.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java并发编程上篇 - (Synchronized原理,LockSupport原理,ReentrantLock原理)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-04 17:53" pubdate>
        November 4, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      347
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java并发编程上篇 - (Synchronized原理,LockSupport原理,ReentrantLock原理)</h1>
            
            <div class="markdown-body">
              <h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这就开启了一个进程</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进行（例如笔记本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360安全卫士等）</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>一个线程之内可以分为一到多个线程</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令已一定的顺序交给CPU执行。</li>
<li>Java中，线程作为小调度单位，进程作为资源分配的最小单位</li>
</ul>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><ul>
<li>进程基本上相互独立，而线程存在于进程内，是进程的一个子集，进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li>
</ul>
</li>
<li>进程通信相对简单，因为它们共享进程内的内存，一个例子是多线程可以访问同一个共享变量线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h3 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h3><p>并发是一个CPU在不同的时间去不同线程中执行指令</p>
<p>并行是多个CPU同时处理不同的线程</p>
<ul>
<li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li>
</ul>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><h4 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h4><p>以调用方法的角度讲，如果</p>
<ul>
<li>需要等待结果返回才能继续运行的话就是<strong>同步</strong></li>
<li>不需要等待就是<strong>异步</strong></li>
</ul>
<p><strong>1）设计</strong></p>
<p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，那么 cpu 只能等 5 秒，啥都不能做。</p>
<p><strong>2）结论</strong></p>
<p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程<br>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程<br>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>1） 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p>
<p>2）多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p>
<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
<p>3）IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化</p>
<h2 id="二、Java线程"><a href="#二、Java线程" class="headerlink" title="二、Java线程"></a>二、Java线程</h2><h3 id="1-线程创建与运行"><a href="#1-线程创建与运行" class="headerlink" title="1.线程创建与运行"></a>1.线程创建与运行</h3><h4 id="方法1，使用Thread"><a href="#方法1，使用Thread" class="headerlink" title="方法1，使用Thread"></a>方法1，使用Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 匿名内部类方式创建 Thread</span><br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        t.start();<br>        log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法二，使用Runnable配合Thread（推荐）"><a href="#方法二，使用Runnable配合Thread（推荐）" class="headerlink" title="方法二，使用Runnable配合Thread（推荐）"></a>方法二，使用Runnable配合Thread（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 lambda 表达式，因为 Runnable 接口 </span><br>        <span class="hljs-comment">// 标注了 @FunctionalInterface 这个注解，表示是一个函数式接口，可以使用 lambda 表达式</span><br>        Runnable r = () -&gt; log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>        <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="比较方法一与方法二："><a href="#比较方法一与方法二：" class="headerlink" title="比较方法一与方法二："></a>比较方法一与方法二：</h4><p>方法1是把线程和任务合并在了一起</p>
<p>方法2是把线程和任务分开了，用Runnable更容易与线程池等高级API配合，用Runnable让任务类脱离了Thread继承体系，更灵活</p>
<p>通过查看源码可以发现，方法二其实还是使用了Thread类中的run方法执行的</p>
<h4 id="方法三，Future-Task配合Thread"><a href="#方法三，Future-Task配合Thread" class="headerlink" title="方法三，Future Task配合Thread"></a>方法三，Future Task配合Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 1. 使用 FutureTask 传入 Callable 接口方式创建</span><br>        FutureTask&lt;Integer&gt; future = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 休眠</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;);<br>        <span class="hljs-comment">// 2. 传入 future, 因为 FutureTask 这个类是实现了 RunnableFuture 接口，RunnableFuture 继承了 Runnable 接口</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(future, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 3. 获取返回结果时</span><br>        <span class="hljs-comment">// 当主线程获取 t1 线程的返回值时, 需要等 2 秒，此时主线程进入阻塞状态</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,  future.get());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>	<span class="hljs-comment">// 取消任务</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br>	<span class="hljs-comment">// 获取任务执行结果</span><br>	<span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br>	<span class="hljs-comment">// 获取任务执行结果，带有超时时间限制</span><br>	<span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException,                             ExecutionException,  TimeoutException</span>;<br>	<span class="hljs-comment">// 判断任务是否已经取消</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-comment">// 判断任务是否已经结束</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Future Task类是Future 接口和Runable接口的实现弥补runnable创建线程没有返回值的缺陷</p>
<h3 id="2-线程运行原理"><a href="#2-线程运行原理" class="headerlink" title="2.线程运行原理"></a>2.线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>拟机栈描述的是Java方法执行的内存模型：</p>
<p>每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</p>
<p>当java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，当方法执行完会来到栈帧中的方法出口地址位置，然后从栈中 pop 出栈帧。</p>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致cpu不再执行当前的线程，转而执行另一个线程的代码</p>
<h5 id="被动原因"><a href="#被动原因" class="headerlink" title="被动原因"></a>被动原因</h5><ul>
<li>线程的cpu时间片用完(每个线程轮流执行，看前面并行的概念)</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
</ul>
<h5 id="主动原因"><a href="#主动原因" class="headerlink" title="主动原因"></a>主动原因</h5><ul>
<li>线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的。</p>
<h3 id="3-Thread的常见方法"><a href="#3-Thread的常见方法" class="headerlink" title="3.Thread的常见方法"></a>3.Thread的常见方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">static</th>
<th align="center">功能说明</th>
<th align="center">注意</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start()</td>
<td align="center"></td>
<td align="center">启动一个新线程，在新线程中运行run方法中的代码</td>
<td align="center">start方法只是让线程进入就绪状态，里面代码不一定立刻运行，只有当CPU将时间片分给线程时，才能进入运行状态，执行代码。每个线程的start方法只能调用一次，调用多次就会出现  IllegalThreadStateException</td>
</tr>
<tr>
<td align="center">run()</td>
<td align="center"></td>
<td align="center">新线程启动会调用的方法</td>
<td align="center">如果在构造 Thread 对象时传递了 Runnable 参数， 则线程启动后会调用 Runnable 中的 run 方法， 否则默认不执行任何操作。 但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td align="center">join()</td>
<td align="center"></td>
<td align="center">等待线程运行结束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">join(long n)</td>
<td align="center"></td>
<td align="center">等待线程运行结束，最多等待n毫秒</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">getId()</td>
<td align="center"></td>
<td align="center">获取线程长整型的 id</td>
<td align="center">id 唯一</td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center"></td>
<td align="center">获取线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">setName(String)</td>
<td align="center"></td>
<td align="center">修改线程名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">getPriority()</td>
<td align="center"></td>
<td align="center">获取线程优先级</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">setPriority(int)</td>
<td align="center"></td>
<td align="center">修改线程优先级</td>
<td align="center">java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的几率</td>
</tr>
<tr>
<td align="center">getState()</td>
<td align="center"></td>
<td align="center">获取线程状态</td>
<td align="center">Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td align="center">isInterrupted()</td>
<td align="center"></td>
<td align="center">判断是否被打断</td>
<td align="center">不会清除 打断标记</td>
</tr>
<tr>
<td align="center">isAlive()</td>
<td align="center"></td>
<td align="center">线程是否存活（还没有运行完毕）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">interrupt()</td>
<td align="center">static</td>
<td align="center">打断线程</td>
<td align="center">会清除 打断标记</td>
</tr>
<tr>
<td align="center">currentThread()</td>
<td align="center">static</td>
<td align="center">获取当前正在执行的线程</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">sleep(long n)</td>
<td align="center">static</td>
<td align="center">让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">yield()</td>
<td align="center">static</td>
<td align="center">提示线程调度器让出当前线程对CPU的使用</td>
<td align="center">主要是为了测试和调</td>
</tr>
</tbody></table>
<h4 id="1）start-VS-run"><a href="#1）start-VS-run" class="headerlink" title="1）start() VS run()"></a>1）start() VS run()</h4><p>直接调用run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running....&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 测试通过 Thread 类实例 t1 对象直接调用 run 方法</span><br>        t1.run();<br><br>        log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> [main] c.Code_05_Test - main running....<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> [main] c.Code_05_Test - main running...<br></code></pre></td></tr></table></figure>

<p>调用start()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running....&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 测试通过 Thread 类实例 t1 对象直接调用 run 方法</span><br><span class="hljs-comment">//        t1.run();</span><br>        <span class="hljs-comment">// 调用 start 方法</span><br>        t1.start();<br><br>        log.info(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">35</span> [main] c.Code_05_Test - main running...<br><span class="hljs-number">14</span>:<span class="hljs-number">59</span>:<span class="hljs-number">35</span> [t1] c.Code_05_Test - t1 running....<br></code></pre></td></tr></table></figure>

<p>发现两种结果是不一样的，使用 start 方式，CPU 会为创建的线程分配时间片，线程进入运行状态，然后线程调用 run 方法执行逻辑。直接使用 run 的方式，虽然会创建了线程，但是它是直接调用方法，而不是像 start 方式那样触发的，这个线程对象会处一直处在新建状态，从结果上也可以看出，run 方法是 main 线程调用，而不是 t1 线程。</p>
<h4 id="2）sleep-与-yield"><a href="#2）sleep-与-yield" class="headerlink" title="2）sleep() 与 yield()"></a>2）sleep() 与 yield()</h4><h5 id="sleep（使线程阻塞）"><a href="#sleep（使线程阻塞）" class="headerlink" title="sleep（使线程阻塞）"></a>sleep（使线程阻塞）</h5><ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），可通过state()方法查看</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ol>
<h5 id="yield-让出当前线程"><a href="#yield-让出当前线程" class="headerlink" title="yield(让出当前线程)"></a>yield(让出当前线程)</h5><ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态（仍然有可能被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
<h4 id="3）join-方法"><a href="#3）join-方法" class="headerlink" title="3）join() 方法"></a>3）join() 方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用t1.join()，则是主线程等待t1线程结束，join采用同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread();<br><span class="hljs-comment">//等待 t1 线程执行结束</span><br>t1.join();<br><span class="hljs-comment">// 最多等待 1000ms,如果 1000ms 内线程执行完毕，则会直接执行下面的语句，不会等够 1000ms</span><br>t1.join(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<h4 id="4）interrupt-方法"><a href="#4）interrupt-方法" class="headerlink" title="4）interrupt()方法"></a>4）interrupt()方法</h4><h5 id="interrupt-打断线程有两种情况。如下"><a href="#interrupt-打断线程有两种情况。如下" class="headerlink" title="interrupt 打断线程有两种情况。如下"></a>interrupt 打断线程有两种情况。如下</h5><ul>
<li>如果一个线程在运行中被打断，打断标记会被置为true</li>
<li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li>
</ul>
<h5 id="isInterrupted-与-interrupted-比较，如下："><a href="#isInterrupted-与-interrupted-比较，如下：" class="headerlink" title="isInterrupted() 与  interrupted() 比较，如下："></a>isInterrupted() 与  interrupted() 比较，如下：</h5><p>首先，isInterrupted 是实例方法，interrupted 是静态方法，它们的用处都是查看当前打断的状态，但是 isInterrupted 方法查看线程的时候，不会将打断标记清空，也就是置为 false，interrupted 查看线程打断状态后，会将打断标志置为 false，也就是清空打断标记，简单来说，interrupt() 方法类似于 setter 设置中断值，isInterrupted() 类似于 getter 获取中断值，interrupted() 类似于 getter + setter 先获取中断值，然后清除标志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试 isInterrupted 与 interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_14_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_14_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;park&quot;</span>);<br>            LockSupport.park();<br>            log.info(<span class="hljs-string">&quot;unpark&quot;</span>);<br><span class="hljs-comment">//            log.info(&quot;打断标记为:&#123;&#125;&quot;, Thread.currentThread().isInterrupted());</span><br>            log.info(<span class="hljs-string">&quot;打断标记为:&#123;&#125;&quot;</span>, Thread.interrupted());<br><br>            <span class="hljs-comment">// 使用 Thread.currentThread().isInterrupted() 查看打断标记为 true, LockSupport.park() 失效</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 执行结果：</span><br><span class="hljs-comment">             * 11:54:17 [t1] c.Code_14_Test - park</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - 打断标记为:true</span><br><span class="hljs-comment">             * 11:54:18 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 使用 Thread.interrupted() 查看打断标记为 true, 然后清空打断标记为 false, LockSupport.park() 不失效</span><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 执行结果：</span><br><span class="hljs-comment">             * 11:58:12 [t1] c.Code_14_Test - park</span><br><span class="hljs-comment">             * 11:58:13 [t1] c.Code_14_Test - unpark</span><br><span class="hljs-comment">             * 11:58:13 [t1] c.Code_14_Test - 打断标记为:true</span><br><span class="hljs-comment">             */</span><br>            LockSupport.park();<br>            log.info(<span class="hljs-string">&quot;unpark&quot;</span>);<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 主线程休眠 1 秒</span><br>        t1.interrupt();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="终止模式之两阶段终止模式，如下："><a href="#终止模式之两阶段终止模式，如下：" class="headerlink" title="终止模式之两阶段终止模式，如下："></a>终止模式之两阶段终止模式，如下：</h5><p>Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。</p>
<p><img src="https://img-blog.csdnimg.cn/2021012811453967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="两阶段终止模式"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 interrupt 进行两阶段终止模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_13_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_13_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        TwoParseTermination twoParseTermination = <span class="hljs-keyword">new</span> TwoParseTermination();<br>        twoParseTermination.start();<br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        twoParseTermination.stop();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoParseTermination&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoParseTermination</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Thread monitor;<br><br>    <span class="hljs-comment">// 启动线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Thread thread = Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(thread.isInterrupted()) &#123; <span class="hljs-comment">// 调用 isInterrupted 不会清除标记</span><br>                    log.info(<span class="hljs-string">&quot;料理后事 ...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        log.info(<span class="hljs-string">&quot;执行监控的功能 ...&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        log.info(<span class="hljs-string">&quot;设置打断标记 ...&quot;</span>);<br>                        thread.interrupt();<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;monitor&quot;</span>);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">// 终止线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5）sleep、yiled、wait、join对比"><a href="#5）sleep、yiled、wait、join对比" class="headerlink" title="5）sleep、yiled、wait、join对比"></a>5）sleep、yiled、wait、join对比</h4><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/8876670.html">点这里</a></p>
<h4 id="6）守护线程"><a href="#6）守护线程" class="headerlink" title="6）守护线程"></a>6）守护线程</h4><p>默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码，未执行完java进程也会停止。普通线程t1可以调用<strong>t1.setDeamon(true)；</strong>方法变成守护线程。</p>
<p>注意 垃圾回收器线程就是一种守护线程。 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p>
<h3 id="4-线程状态"><a href="#4-线程状态" class="headerlink" title="4.线程状态"></a>4.线程状态</h3><h4 id="1）线程的5种状态"><a href="#1）线程的5种状态" class="headerlink" title="1）线程的5种状态"></a>1）线程的5种状态</h4><p>从操作系统层划分，线程有5种状态</p>
<p><img src="https://img-blog.csdnimg.cn/20210128153015533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="线程五种状态"></p>
<ol>
<li><p>初始状态，仅仅是在语言层面上创建了线程对象，即Thead thread = new Thead();，还未与操作系统线程关联</p>
</li>
<li><p>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</p>
</li>
<li><p>运行状态，指线程获取了CPU时间片，正在运行</p>
<p>当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</p>
</li>
<li><p>阻塞状态</p>
<ol>
<li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】</li>
<li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li>
</ol>
</li>
<li><p>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ol>
<h4 id="2）线程的6种状态"><a href="#2）线程的6种状态" class="headerlink" title="2）线程的6种状态"></a>2）线程的6种状态</h4><p>这是从JavaAPI层面来描述的，我们主要研究的就是这种。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">点这里</a></p>
<p><img src="https://img-blog.csdnimg.cn/2021012815330125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="线程的六种状态"></p>
<ul>
<li>NEW 跟五种状态里的初始状态是一个意思</li>
</ul>
<ul>
<li>RUNNABLE 是当调用了 start() 方法之后的状态，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
</ul>
<ul>
<li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分。</li>
</ul>
<p>演示线程的 6 种状态，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 java 线程的 6 种状态(NEW, RUNNABLE, TERMINATED, BLOCKED, WAITING, TIMED_WAITING)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_15_Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_15_Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// NEW</span><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;NEW 状态&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// RUNNABLE</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t2.start();<br><br>        <span class="hljs-comment">// TERMINATED</span><br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;running&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>);<br>        t3.start();<br><br>        <span class="hljs-comment">// TIMED_WAITING</span><br>        Thread t4 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Code_15_Test.class) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t4&quot;</span>);<br>        t4.start();<br><br>        <span class="hljs-comment">// WAITING</span><br>        Thread t5 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t2.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t5&quot;</span>);<br>        t5.start();<br><br>        Thread t6 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Code_15_Test.class) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t6&quot;</span>);<br>        t6.start();<br><br>        <span class="hljs-comment">// 主线程休眠 1 秒, 目的是为了等待 t3 线程执行完</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;t1 线程状态: &#123;&#125;&quot;</span>, t1.getState());<br>        log.info(<span class="hljs-string">&quot;t2 线程状态: &#123;&#125;&quot;</span>, t2.getState());<br>        log.info(<span class="hljs-string">&quot;t3 线程状态: &#123;&#125;&quot;</span>, t3.getState());<br>        log.info(<span class="hljs-string">&quot;t4 线程状态: &#123;&#125;&quot;</span>, t4.getState());<br>        log.info(<span class="hljs-string">&quot;t5 线程状态: &#123;&#125;&quot;</span>, t5.getState());<br>        log.info(<span class="hljs-string">&quot;t6 线程状态: &#123;&#125;&quot;</span>, t6.getState());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>本章的重点在于掌握</p>
<ol>
<li>线程的创建</li>
<li>线程重要的API，如start、run、sleep、yield、join、interrupt等</li>
<li>线程的状态</li>
<li>原理方面，线程的运行流程，栈，栈帧，上下文切换，程序计数器等知识</li>
<li>Thread两种创建线程的源码</li>
<li>使用interrupt来编写两阶段终止</li>
</ol>
<h2 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h2><h3 id="1-线程共享带来的问题"><a href="#1-线程共享带来的问题" class="headerlink" title="1.线程共享带来的问题"></a>1.线程共享带来的问题</h3><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;<br>               count++;<br>           &#125;<br>       &#125;);<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-number">5000</span>; i++)&#123;<br>               count--;<br>           &#125;<br>       &#125;);<br>       t1.start();<br>       t2.start();<br>       t1.join();<br>       t2.join();<br>       log.debug(<span class="hljs-string">&quot;count的值是&#123;&#125;&quot;</span>,count);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>如上代码，当执行 count++ 或者 count– 操作的时候，从字节码分析，实际上是 4 步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">count++; <span class="hljs-comment">// 操作字节码如下：</span><br>getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>iadd <span class="hljs-comment">// 自增</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br><br>count--; <span class="hljs-comment">// 操作字节码如下：</span><br>getstatic i <span class="hljs-comment">// 获取静态变量i的值</span><br>iconst_1 <span class="hljs-comment">// 准备常量1</span><br>isub <span class="hljs-comment">// 自减</span><br>putstatic i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></table></figure>

<p>当 CPU 时间片分给 t1 线程时，t1 线程去读取变量值为 0 并且执行 ++ 的操作，如上在字节码自增操作中，当 t1 执行完自增，还没来得急将修改后的值存入静态变量时，假如线程的时间片用完了，并且 CPU 将时间片分配给 t2 线程，t2 线程拿到时间片执行自减操作，并且将修改后的值存入静态变量，此时 count 的值为 -1，但是当 CPU 将时间片分给经历了上下文切换的 t1 线程时，t1 将修改后的值存入静态变量，此时 counter 的值为 1，覆盖了 t2 线程执行的结果，出现了丢失更新，这就是多线对共享资源读取的问题。</p>
<h4 id="1）临界区-Criteria-Section"><a href="#1）临界区-Criteria-Section" class="headerlink" title="1）临界区 Criteria Section"></a>1）临界区 Criteria Section</h4><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ul>
<p>例如，下面代码中的临界区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2）竞态条件-Race-Condition"><a href="#2）竞态条件-Race-Condition" class="headerlink" title="2）竞态条件 Race Condition"></a>2）竞态条件 Race Condition</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竟态条件</p>
<h3 id="2-synchronized解决方案"><a href="#2-synchronized解决方案" class="headerlink" title="2.synchronized解决方案"></a>2.synchronized解决方案</h3><h4 id="1）解决手段"><a href="#1）解决手段" class="headerlink" title="1）解决手段"></a>1）解决手段</h4><p>为了避免临界区中的竟态条件发生，有多种手段可以达到</p>
<ul>
<li>阻塞式解决方案：synchronized，lock</li>
<li>非阻塞式解决方案：原子变量</li>
</ul>
<p>现在讨论使用<strong>synchronized</strong>来进行解决，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<p>注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码 同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</p>
<h4 id="2）synchronized-语法"><a href="#2）synchronized-语法" class="headerlink" title="2）synchronized 语法"></a>2）synchronized 语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<br>	<span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的实例程序使用synchronized后如下，计算出的结果是正确！Test13.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>             <span class="hljs-keyword">synchronized</span> (room) &#123;<br>             counter++;<br>        	&#125;<br> 		&#125;<br> 	&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>     Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>             <span class="hljs-keyword">synchronized</span> (room) &#123;<br>             counter--;<br>         &#125;<br>     &#125;<br>     &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>     t1.start();<br>     t2.start();<br>     t1.join();<br>     t2.join();<br>     log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3）synchronized原理"><a href="#3）synchronized原理" class="headerlink" title="3）synchronized原理"></a>3）synchronized原理</h4><p>synchronized实际上利用<strong>对象保证了临界区代码的原子性</strong>，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断</p>
<p><img src="https://gitee.com/gu_chun_bo/picture/raw/master/image/20200307170035-215697.png" srcset="/img/loading.gif" lazyload alt="synchronized原理"></p>
<h4 id="4）synchronized加在方法上"><a href="#4）synchronized加在方法上" class="headerlink" title="4）synchronized加在方法上"></a>4）synchronized加在方法上</h4><ul>
<li>加在成员方法上，锁住的是this对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-comment">// 在方法上加上synchronized关键字</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">// 等价于</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123; <span class="hljs-comment">// 锁住的是对象</span><br>		<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>加在静态方法上，锁住的是类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-comment">// 在静态方法上加上 synchronized 关键字</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>	&#125;<br>	<span class="hljs-comment">//等价于</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">synchronized</span>(Test.class) &#123; <span class="hljs-comment">// 锁住的是类</span><br>		<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5）线程八锁案例分析"><a href="#5）线程八锁案例分析" class="headerlink" title="5）线程八锁案例分析"></a>5）线程八锁案例分析</h4><ul>
<li>考察synchronized锁住的是哪个对象，如果锁住的是同一对象，就不会出现线程安全问题</li>
</ul>
<h5 id="1-锁住同一对象都是this-e1对象-，结果为：1-2-2-1"><a href="#1-锁住同一对象都是this-e1对象-，结果为：1-2-2-1" class="headerlink" title="1.锁住同一对象都是this(e1对象)，结果为：1,2 || 2,1"></a>1.锁住同一对象都是this(e1对象)，结果为：1,2 || 2,1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1/2 或 2/1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//    public void a () &#123;</span><br><span class="hljs-comment">//        synchronized (this) &#123;</span><br><span class="hljs-comment">//            log.debug(&quot;1&quot;);</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-锁住同一个对象都是this-e1对象-，结果为：1s后1-2-2-1s后1"><a href="#2-锁住同一个对象都是this-e1对象-，结果为：1s后1-2-2-1s后1" class="headerlink" title="2.锁住同一个对象都是this(e1对象)，结果为：1s后1,2 || 2,1s后1"></a>2.锁住同一个对象都是this(e1对象)，结果为：1s后1,2 || 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会出现安全问题, 打印结果顺序为: 1s后1,2 || 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-a-b锁住同一个对象都是this-e1对象-，c没有上锁。结果为：3-1s后1-2-2-3-1s后1-3-2-1s后1"><a href="#3-a-b锁住同一个对象都是this-e1对象-，c没有上锁。结果为：3-1s后1-2-2-3-1s后1-3-2-1s后1" class="headerlink" title="3.a,b锁住同一个对象都是this(e1对象)，c没有上锁。结果为：3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1"></a>3.a,b锁住同一个对象都是this(e1对象)，c没有上锁。结果为：3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会出现安全问题, 因为前两个线程, 执行run方法时, 都对相同的对象加锁;</span><br><span class="hljs-comment"> *              而第三个线程,调用的方法c, 并没有加锁, 所以它可以同前两个线程并行执行;</span><br><span class="hljs-comment"> *  打印结果顺序为: 分析: 因为线程3和线程1,2肯定是并行执行的, 所以有以下情况</span><br><span class="hljs-comment"> *               3,1s后1,2 || 2,3,1s后1 || 3,2,1s后1</span><br><span class="hljs-comment"> *               至于 1,3,2的情况是不会发生的, 可以先调用到1,但需要sleep一秒.3肯定先执行了</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象就是this, 也就是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象也是this, e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;3&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                e1.a();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.c()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="4-a锁住对象this-n1对象-，b锁住对象this（n2对象），不互斥。结果为：2-1s后1"><a href="#4-a锁住对象this-n1对象-，b锁住对象this（n2对象），不互斥。结果为：2-1s后1" class="headerlink" title="4.a锁住对象this(n1对象)，b锁住对象this（n2对象），不互斥。结果为：2,1s后1"></a>4.a锁住对象this(n1对象)，b锁住对象this（n2对象），不互斥。结果为：2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会出现安全问题, 线程1的锁对象为e1, 线程2的锁对象为e2. 所以他们会同一时刻执行1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是e1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>    	Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是e2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="5-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1"><a href="#5-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1" class="headerlink" title="5.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1"></a>5.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是e2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="6-a，b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2"><a href="#6-a，b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2" class="headerlink" title="6.a，b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2"></a>6.a，b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1 || 1s后1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="7-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1"><a href="#7-a锁住的是EightLockTest-class对象-b锁住的是this-e1-不会互斥-结果-2-1s后1" class="headerlink" title="7.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1"></a>7.a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥; 结果: 2,1s后1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 会发生安全问题, 因为a锁住的是EightLockTest.class对象, b锁住的是this(e1),不会互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是this,e2对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="8、a-b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2"><a href="#8、a-b锁住的是EightLockTest-class对象-会发生互斥-结果为：2-1s后1-1s后1-2" class="headerlink" title="8、a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2"></a>8、a,b锁住的是EightLockTest.class对象, 会发生互斥; 结果为：2,1s后1 || 1s后1,2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 不会发生安全问题, 因为a,b锁住的是EightLockTest.class对象, 会发生互斥</span><br><span class="hljs-comment"> *              结果: 2,1s后1 || 1s后1,2</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/19 11:24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.EightLockTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EightLockTest</span> </span>&#123;<br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 锁对象是EightLockTest.class类对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        EightLockTest e1 = <span class="hljs-keyword">new</span> EightLockTest();<br>        EightLockTest e2 = <span class="hljs-keyword">new</span> EightLockTest();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e1.a()).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; e2.b()).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-变量的线程安全分析"><a href="#3-变量的线程安全分析" class="headerlink" title="3.变量的线程安全分析"></a>3.变量的线程安全分析</h3><h4 id="1）成员变量和静态变量的线程安全分析-重要"><a href="#1）成员变量和静态变量的线程安全分析-重要" class="headerlink" title="1）成员变量和静态变量的线程安全分析(重要)"></a>1）成员变量和静态变量的线程安全分析(<code>重要</code>)</h4><ul>
<li><code>如果变量没有在线程间共享，那么变量是安全的</code></li>
<li>如果变量在线程间共享<ul>
<li>如果只有<code>读操作</code>，则<code>线程安全</code></li>
<li>如果有<code>读写操作</code>，则这段代码是<code>临界区</code>，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="2）局部变量线程安全分析-重要"><a href="#2）局部变量线程安全分析-重要" class="headerlink" title="2）局部变量线程安全分析(重要)"></a>2）局部变量线程安全分析(<code>重要</code>)</h4><ul>
<li>局部变量【局部变量被初始化为基本数据类型】是安全的</li>
<li>但局部变量引用的对象则未必（要看该对象是否被共享且被执行了读写操作）<ul>
<li>如果该对象没有逃离方法的作用范围；是线程安全的</li>
<li>如果该对象逃离方法的作用范围；需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="3）线程安全的情况-重要"><a href="#3）线程安全的情况-重要" class="headerlink" title="3）线程安全的情况(重要)"></a>3）线程安全的情况(<code>重要</code>)</h4><ul>
<li>局部变量表是存在于栈帧中，而虚拟机栈中又包括很多栈帧，虚拟机栈是线程私有的</li>
<li>局部变量【局部变量被初始化为基本数据类型】是安全的，示例如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>     i++;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>每个线程调用test1()方法时局部变量i，会在每个线程的栈内存中被创建多份，因此不存在共享</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;<br> descriptor: ()V<br> flags: ACC_PUBLIC, ACC_STATIC<br> Code:<br>	 stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">0</span><br>	 <span class="hljs-number">0</span>: bipush <span class="hljs-number">10</span><br>	 <span class="hljs-number">2</span>: istore_0<br>	 <span class="hljs-number">3</span>: iinc <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>	 <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span><br>	 LineNumberTable:<br>	 line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>	 line <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br>	 line <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br>	 LocalVariableTable:<br>	 Start Length Slot Name Signature<br>	 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> i I<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020121913434871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h4 id="4）线程不安全的情况"><a href="#4）线程不安全的情况" class="headerlink" title="4）线程不安全的情况"></a>4）线程不安全的情况</h4><ul>
<li><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全问题，代码示例如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">循环创建了<span class="hljs-number">100</span>个线程, 在线程体里面都调用了method1方法, 在method1方法中又循环调用了<span class="hljs-number">100</span>次method2,method3方法。方法<span class="hljs-number">2</span>,<span class="hljs-number">3</span>都使用到了成员变量<span class="hljs-built_in">array</span>List, 此时的问题就是: <span class="hljs-number">1</span>个线程它会循环调用<span class="hljs-number">100</span>次方法<span class="hljs-number">2</span>和<span class="hljs-number">3</span>, 一共有<span class="hljs-number">100</span>个线程, 此时<span class="hljs-number">100</span>个线程操作的共享资源就是<span class="hljs-built_in">array</span>List成员变量 , 而且还进行了读写操作. 必然会造成线程不安全的问题<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test15</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        UnsafeTest unsafeTest = <span class="hljs-keyword">new</span> UnsafeTest();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                unsafeTest.method1();<br>            &#125;,<span class="hljs-string">&quot;线程&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeTest</span></span>&#123;<br>    ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            method2();<br>            method3();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        arrayList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br>Exception in thread <span class="hljs-string">&quot;线程1&quot;</span> Exception in thread <span class="hljs-string">&quot;线程2&quot;</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="5）不安全原因分析"><a href="#5）不安全原因分析" class="headerlink" title="5）不安全原因分析"></a>5）不安全原因分析</h4><ul>
<li>无论哪个线程中的method2和method3引用的都是同一个对象中的list成员变量</li>
<li>一个ArrayList，在添加一个元素的时候，他可能会有两步来完成<ul>
<li>第一步：在arrayList[size]的位置存放此元素</li>
<li>第二部：size++</li>
</ul>
</li>
<li>在单线程运行的情况下，如果size=0，添加一个元素后，此元素在位置0，而且size=1；</li>
<li>在多线程情况下，比如有两个线程，<code>线程 A 先将元素存放在位置 0。但是此时 CPU 进行上下文切换 (线程A还没来得及size++)</code>，<strong>线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于0</strong>  （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，<code>都增加 size 的值</code>。</li>
<li>那好，现在我们来看看 <code>ArrayList</code> 的情况，<code>元素实际上只有一个，存放在位置 0</code>，而 <code>size 却等于 2</code>。这就是“线程不安全”了。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/589573a2de17a1bc7ca5728a20248ef5.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fbc6e2e0d0cc62e37fcf70984813091e.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-解决方法"><a href="#6-解决方法" class="headerlink" title="6.解决方法"></a>6.解决方法</h4><ul>
<li>可以将<code>list</code>修改成<code>局部变量</code>，然后将 list 作为引用传入方法中，局部变量存放在栈帧中, 栈帧又存放在<code>虚拟机栈</code>中, <strong>虚拟机栈是作为线程私有的;</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br> <br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>因为method1方法, 将<code>arrayList</code>传给method2,method3方法, 此时他们三个方法<code>共享这同一个arrayList</code>, 此时<strong>不会被其他线程访问到</strong>, 所以不会出现<code>线程安全问题</code>, 因为<code>这三个方法使用的同一个线程</code>。</li>
</ul>
<ul>
<li>在外部, 创建了100个线程, 每个线程都会调用<code>method1</code>方法, 然后都会再从新创建一个新的<code>arrayList</code>对象, 这个新对象再传递给method2,method3方法.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201219151354651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h4 id="7）思考private或final的重要性-重要"><a href="#7）思考private或final的重要性-重要" class="headerlink" title="7）思考private或final的重要性(重要)"></a>7）思考private或final的重要性(<code>重要</code>)</h4><p>提高线程的安全性</p>
<p>如果把method2和method3 的方法修改为<code>public</code> 会不会导致线程安全问题; 分情况:</p>
<h5 id="情况1：有其它线程调用-method2-和-method3"><a href="#情况1：有其它线程调用-method2-和-method3" class="headerlink" title="情况1：有其它线程调用 method2 和 method3"></a><strong>情况1：有其它线程调用 method2 和 method3</strong></h5><ul>
<li>只修改为public修饰,此时不会出现线程安全的问题, 即使线程2调用method2/3方法, 给2/3方法传过来的list对象也是线程2调用method1方法时,传递给method2/3的list对象, 不可能是线程1调用method1方法传的对象。 具体原因看上面: 4.2解决方法。</li>
</ul>
<h5 id="情况2：在情况1-的基础上，为ThreadSafe-类添加子类，子类覆盖method2-或-method3方法，即如下所示：-从这个例子可以看出-private-或-final-提供【安全】的意义所在，请体会开闭原则中的【闭】"><a href="#情况2：在情况1-的基础上，为ThreadSafe-类添加子类，子类覆盖method2-或-method3方法，即如下所示：-从这个例子可以看出-private-或-final-提供【安全】的意义所在，请体会开闭原则中的【闭】" class="headerlink" title="情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖method2 或 method3方法，即如下所示： 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】"></a>情况2：在情况1 的基础上，为ThreadSafe 类添加子类，子类覆盖<code>method2 或 method3</code>方法，即如下所示： 从这个例子可以看出 <code>private</code> 或 <code>final</code> 提供【安全】的意义所在，请体会<code>开闭原则中的【闭】</code></h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">- 如果改为<span class="hljs-keyword">public</span>, 此时子类可以重写父类的方法, 在子类中开线程来操作list对象, 此时就会出现线程安全问题: 子类和父类共享了list对象<br>- 如果改为<span class="hljs-keyword">private</span>, 子类就不能重写父类的私有方法, 也就不会出现线程安全问题; 所以所<span class="hljs-keyword">private</span>修饰符是可以避免线程安全问题.<br>- 所以如果不想子类, 重写父类的方法的时候, 我们可以将父类中的方法设置为<span class="hljs-keyword">private</span>, <span class="hljs-keyword">final</span>修饰的方法, 此时子类就无法影响父类中的方法了!<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            method2(list);<br>            method3(list);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        list.remove(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeSubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadSafe</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            list.remove(<span class="hljs-number">0</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8）常见线程安全类"><a href="#8）常见线程安全类" class="headerlink" title="8）常见线程安全类"></a>8）常见线程安全类</h4><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类 JUC</li>
</ul>
<p><strong>重点:</strong></p>
<ul>
<li>这里<code>说它们是线程安全</code>的是指，<strong>多个线程调用它们同一个实例的某个方法时，是线程安全的</strong> , 也可以理解为 <strong>它们的每个方法是原子的</strong></li>
<li>它们的每个方法是原子的<code>（方法都被加上了synchronized）</code></li>
</ul>
<ul>
<li>但注意它们<code>多个方法的组合不是原子的</code>，所以可能<strong>会出现线程安全问题</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>	<span class="hljs-comment">// put方法增加了synchronized</span><br> 	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> 	table.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<h5 id="线程安全类方法的组合"><a href="#线程安全类方法的组合" class="headerlink" title="线程安全类方法的组合"></a>线程安全类方法的组合</h5><ul>
<li>但注意<code>它们多个方法的组合不是原子的</code>，见下面分析<ul>
<li>这里只能是get方法内部是线程安全的, put方法内部是线程安全的. 组合起来使用还是会受到<code>上下文切换</code>的影响</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Hashtable table = <span class="hljs-keyword">new</span> Hashtable();<br><span class="hljs-comment">// 线程1，线程2</span><br><span class="hljs-keyword">if</span>( table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br> table.put(<span class="hljs-string">&quot;key&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/3f38b860d4b0a73d3bc446598d38c867.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示，当使用方法组合时，出现了线程安全问题，当线程 1 执行完 get(“key”) ，这是一个原子操作没出问题，但是在 get(“key”) == null 比较时，如果线程的时间片用完了，线程 2 获取时间片执行了 get(“key”) == null 操作，然后进行 put(“key”, “v2”) 操作，结束后，线程 1 被分配 cpu 时间片继续执行，执行 put 操作就会出现线程安全问题。</p>
<h5 id="不可变类的线程安全"><a href="#不可变类的线程安全" class="headerlink" title="不可变类的线程安全"></a>不可变类的线程安全</h5><ul>
<li><code>String</code>和<code>Integer</code>类都是<code>不可变的类</code>，因为其类内部<code>状态是不可改变</code>的，因此<strong>它们的方法都是线程安全的</strong>, 都被<code>final</code>修饰, 不能被继承.</li>
<li>肯定有些人他们知道<code>String</code> 有 <code>replace</code>，<code>substring</code> 等方法【<code>可以】改变值啊</code>，<strong>其实调用这些方法返回的已经是一个新创建的对象了！</strong> <code>(在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(endIndex);<br>        &#125;<br>        <span class="hljs-keyword">int</span> subLen = endIndex - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span><br>                : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen); <span class="hljs-comment">// 新建一个对象，然后返回，没有修改等操作，是线程安全的。</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="9）示例分析-是否线程安全"><a href="#9）示例分析-是否线程安全" class="headerlink" title="9）示例分析-是否线程安全"></a>9）示例分析-是否线程安全</h4><h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h5><p>分析线程是否安全，先对类的成员变量，类变量，局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题了，如果变量A引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量A是线程安全的。</p>
<ul>
<li><code>Servlet运行在Tomcat环境下并只有一个实例</code>，因此会被Tomcat的多个线程共享使用，因此存在成员变量的共享问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	 <span class="hljs-comment">// 是否安全？  否：HashMap不是线程安全的，HashTable是</span><br>	 Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>	 <span class="hljs-comment">// 是否安全？  是:String 为不可变类，线程安全</span><br>	 String S1 = <span class="hljs-string">&quot;...&quot;</span>;<br>	 <span class="hljs-comment">// 是否安全？ 是</span><br>	 <span class="hljs-keyword">final</span> String S2 = <span class="hljs-string">&quot;...&quot;</span>;<br>	 <span class="hljs-comment">// 是否安全？ 否：不是常见的线程安全类</span><br>	 Date D1 = <span class="hljs-keyword">new</span> Date();<br>	 <span class="hljs-comment">// 是否安全？  否：引用值D2不可变，但是日期里面的其它属性比如年月日可变。与字符串的最大区别是Date里面的属性可变。</span><br>	 <span class="hljs-keyword">final</span> Date D2 = <span class="hljs-keyword">new</span> Date();<br> <br>	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response)</span> </span>&#123;<br>	  <span class="hljs-comment">// 使用上述变量</span><br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h5><ul>
<li><strong>MyAspect切面类只有一个实例，成员变量start 会被多个线程同时进行读写操作</strong></li>
<li><strong>Spring中的Bean都是单例的, 除非使用@Scope修改为多例。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全？不安全, 因为MyAspect是单例的</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-meta">@Before(&quot;execution(* *(..))&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>            start = System.nanoTime();<br>        &#125;<br><br>        <span class="hljs-meta">@After(&quot;execution(* *(..))&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.println(<span class="hljs-string">&quot;cost time:&quot;</span> + (end-start));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>#####示例三</p>
<ul>
<li>此例是典型的三层模型调用，MyServlet UserServiceImpl UserDaoImpl类都只有一个实例，UserDaoImpl类中没有成员变量，update方法里的变量引用的对象不是线程共享的，所以是线程安全的；UserServiceImpl类中只有一个线程安全的UserDaoImpl类的实例，那么UserServiceImpl类也是线程安全的，同理 MyServlet也是线程安全的</li>
<li>Servlet调用Service, Service调用Dao这三个方法使用的是<code>同一个线程</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>	 <span class="hljs-comment">// 是否安全    是：UserService不可变，虽然有一个成员变量,</span><br>	 			<span class="hljs-comment">// 但是是私有的, 没有地方修改它</span><br>	 <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>	 <br>	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>	 	userService.update(...);<br>	 &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>	 <span class="hljs-comment">// 是否安全     是：Dao不可变, 其没有成员变量</span><br>	 <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>	 <br>	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>	 	userDao.update();<br>	 &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123; <br>	 <span class="hljs-comment">// 是否安全   是：没有成员变量，无法修改其状态和属性</span><br>	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>	 	String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>	 	<span class="hljs-comment">// 是否安全   是：不同线程创建的conn各不相同，都在各自的栈内存中</span><br>	 	<span class="hljs-keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))&#123;<br>	 	<span class="hljs-comment">// ...</span><br>	 	&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>	 	<span class="hljs-comment">// ...</span><br>	 	&#125;<br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h5><ul>
<li><code>UserDaoImpl</code>类中<code>有成员变量</code>，那么<strong>多个线程可以对成员变量</strong><code>conn</code> 同时进行操作，<code>故是不安全的</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>       userDao.update();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全: 不安全; 当多个线程,共享conn, 一个线程拿到conn,刚创建一个连接赋值给conn, 此时另一个线程进来了, 直接将conn.close</span><br>    <span class="hljs-comment">//另一个线程恢复了, 拿到conn干事情, 此时conn都被关闭了, 出现了问题</span><br>    <span class="hljs-keyword">private</span> Connection conn = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h5><p><code>UserServiceImpl</code>类的<code>update方法中UserDao是作为局部变量存在</code>的，所以每个线程访问的时候都会新建有一个<code>UserDao</code>对象，新建的对象是线程独有的，所以<code>是线程安全的</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> UserService userService = <span class="hljs-keyword">new</span> UserServiceImpl();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        userService.update(...);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();<br>        userDao.update();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">// 是否安全</span><br>    <span class="hljs-keyword">private</span> Connection = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        String sql = <span class="hljs-string">&quot;update user set password = ? where username = ?&quot;</span>;<br>        conn = DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h5><ul>
<li>私有变量sdf被暴露出去了，发生了逃逸</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 是否安全</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        foo(sdf);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Test().bar();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中<code>foo 的行为是不确定的</code>，可能<code>导致不安全的发生</code>，被称之为<strong>外星方法</strong>，<strong>因为foo方法可以被重写，导致线程不安全。</strong> 在String类中就考虑到了这一点，String类是<code>final</code>的，<strong>子类不能重写它的方法。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(SimpleDateFormat sdf)</span> </span>&#123;<br>    String dateStr = <span class="hljs-string">&quot;1999-10-11 00:00:00&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sdf.parse(dateStr);<br>            &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="10）习题分析"><a href="#10）习题分析" class="headerlink" title="10）习题分析"></a>10）习题分析</h4><h5 id="卖票练习"><a href="#卖票练习" class="headerlink" title="- 卖票练习"></a>- 卖票练习</h5><p>测试下面代码是否存在线程安全问题，并尝试改正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.n4.exercise;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Vector;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseSell&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseSell</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 模拟多人买票</span><br>        TicketWindow window = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 所有线程的集合（由于threadList在主线程中，不被共享，因此使用ArrayList不会出现线程安全问题）</span><br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 卖出的票数统计(Vector为线程安全类)</span><br>        List&lt;Integer&gt; amountList = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-comment">// 买票</span><br>                <span class="hljs-keyword">int</span> amount = window.sell(random(<span class="hljs-number">5</span>));<br>                <span class="hljs-comment">// 统计买票数</span><br>                amountList.add(amount);<br>            &#125;);<br>            threadList.add(thread);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            thread.join();<br>        &#125;<br><br>        <span class="hljs-comment">// 统计卖出的票数和剩余票数</span><br>        log.debug(<span class="hljs-string">&quot;余票：&#123;&#125;&quot;</span>,window.getCount());<br>        log.debug(<span class="hljs-string">&quot;卖出的票数：&#123;&#125;&quot;</span>, amountList.stream().mapToInt(i -&gt; i).sum());<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~5</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(amount) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 售票窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> </span>&#123;<br>	<span class="hljs-comment">// 票总数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取余票数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-comment">// 售票</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在售票方法中加上synchronized ，对this加锁保证线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">/ 售票<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= amount) &#123;<br>            <span class="hljs-keyword">this</span>.count -= amount;<br>            <span class="hljs-keyword">return</span> amount;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="转账练习"><a href="#转账练习" class="headerlink" title="- 转账练习"></a>- 转账练习</h5><p>测试下面代码是否存在线程安全问题，并尝试改正</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.n4.exercise;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ExerciseTransfer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExerciseTransfer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Account a = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Account b = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">1000</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                a.transfer(b, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                b.transfer(a, randomAmount());<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br>        <span class="hljs-comment">// 查看转账2000次后的总金额</span><br>        log.debug(<span class="hljs-string">&quot;total:&#123;&#125;&quot;</span>, (a.getMoney() + b.getMoney()));<br>    &#125;<br><br>    <span class="hljs-comment">// Random 为线程安全</span><br>    <span class="hljs-keyword">static</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-comment">// 随机 1~100</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomAmount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 账户</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> money;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoney</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-comment">// 转账</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Account target, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(Account.class) &#123;   <span class="hljs-comment">//锁住Account类，因为涉及到A.money和B.money。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.money &gt;= amount) &#123;<br>                <span class="hljs-keyword">this</span>.setMoney(<span class="hljs-keyword">this</span>.getMoney() - amount);<br>                target.setMoney(target.getMoney() + amount);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 没问题, 最终的结果仍然是 2000元</span><br></code></pre></td></tr></table></figure>

<h3 id="4-Monitor概念"><a href="#4-Monitor概念" class="headerlink" title="4.Monitor概念"></a>4.Monitor概念</h3><h4 id="1）Java对象头"><a href="#1）Java对象头" class="headerlink" title="1）Java对象头"></a>1）Java对象头</h4><p>对象头包含两部分：<strong>运行时元数据（Mark Word）和类型指针（Klass Word）</strong></p>
<ol>
<li><strong>运行时元数据</strong><ol>
<li><code>哈希值（HashCode）</code>，可以看作是<strong>堆中对象的地址</strong></li>
<li><code>GC分代年龄（年龄计数器）</code> (用于新生代from/to区晋升老年代的标准, 阈值为15)</li>
<li><strong>锁状态标志</strong> (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)</li>
<li><strong>线程持有的锁</strong></li>
<li><strong>偏向线程ID</strong> (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)</li>
<li>偏向时间戳</li>
</ol>
</li>
<li>类型指针<ol>
<li>指向<code>类元数据InstanceKlass，确定该对象所属的类型</code>。指向的其实是<strong>方法区中存放的类元信息</strong></li>
</ol>
</li>
</ol>
<p>说明：如果对象是数组，还需要记录数组的长度</p>
<ul>
<li>以32位虚拟机为例，普通对象的对象头结构如下，其中的Klass Word为类型指针，指向方法区对应的Class对象；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ac7274e0d0dbe8c8b25f43f2aa1ed1d6.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>数组对象</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52c45594819f30fb8a9d6087682be254.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>其中Mark Word结构为：<strong>无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0ffaeb7ddf7d71801bfd3eeb00754162.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>一个对象的结构如下：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2）Monitor原理"><a href="#2）Monitor原理" class="headerlink" title="2）Monitor原理"></a>2）Monitor原理</h4><p>Monitor 被翻译为监视器或者说管程</p>
<p>每个 java 对象都可以关联一个 Monitor ，如果使用 synchronized 给对象上锁（重量级），该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">多线程同时访问临界区: 使用重量级锁<br><br><span class="hljs-bullet">-</span> JDK6对Synchronized的优先状态：偏向锁–&gt;轻量级锁–&gt;重量级锁<br></code></pre></td></tr></table></figure>

<p>原理解释:</p>
<ul>
<li><p>当<code>Thread1</code>访问到<code>synchronized(obj)</code>中的<code>共享资源</code>的时候</p>
<ul>
<li>首先会将synchronized中的<code>锁对象</code>中<code>对象头</code>的<code>MarkWord</code>去尝试指向<code>操作系统</code>的<code>Monitor</code>对象。让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的<code>MarkWord</code>的<code>对象状态</code>从01改为10。</li>
<li>因为Monitor没有和其他的obj的MarkWord相关联, 所以<code>Thread1</code>就成为了该<code>Monitor</code>的Owner(所有者)。</li>
<li>又来了个Thread1执行synchronized(obj)代码, 它首先会看看能不能执行该临界区的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); Thread1也会和该Monitor关联, 该线程就会进入到它的EntryList(阻塞队列);</li>
<li>当<code>Thread2</code>执行完<code>临界区</code>代码后, Monitor的<code>Owner(所有者)</code>就空出来了. 此时就会<code>通知</code>Monitor中的EntryList阻塞队列中的线程, 这些线程通过<code>竞争</code>, 成为新的<code>所有者</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98c3189e41fd654fe34ead273ec76eba.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>刚开始时<code>Monitor</code>中的<code>Owner为null</code></p>
</li>
<li><p><strong>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</strong></p>
</li>
<li><p>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入<code>EntryList</code>中变成<code>BLOCKED状态</code></p>
</li>
<li><p><strong>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的 (仍然是抢占式)</strong></p>
</li>
<li><p><code>图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</code></p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个锁对象的monitor 才有上述的效果; —&gt; 也就要使用同一把锁</li>
<li>不加 synchronized的锁对象不会关联监视器，不遵从以上规则<img src="https://img-blog.csdnimg.cn/20201219200615817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></li>
</ul>
<p>它加锁就是依赖底层操作系统的 <code>mutex</code>相关指令实现, 所以会造成<code>用户态和内核态之间的切换</code>, 非常耗性能 !</p>
<ul>
<li>在JDK6的时候, 对synchronized进行了优化, 引入了<code>轻量级锁, 偏向锁</code>, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗~</li>
</ul>
<h3 id="5-synchronized原理进阶"><a href="#5-synchronized原理进阶" class="headerlink" title="5.synchronized原理进阶"></a>5.synchronized原理进阶</h3><h4 id="1）synchronized原理"><a href="#1）synchronized原理" class="headerlink" title="1）synchronized原理"></a>1）synchronized原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        counter++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>反编译后的部分字节码</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201219201521709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p>方法级别的synchronized不会在字节码指令中有所体现</p>
<h4 id="2）轻量级锁"><a href="#2）轻量级锁" class="headerlink" title="2）轻量级锁"></a>2）轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有线程可以竞争），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是synchronized，假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 A</span><br>         method2();<br>     &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>         <span class="hljs-comment">// 同步块 B</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以存储对象的Mark Word和对象引用reference</p>
<p><img src="https://img-blog.csdnimg.cn/20210130164759889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>让锁记录中的Object reference指向对象，并且尝试用cas（compare and sweep）替换Object对象的Mark Word，将Mark Word的值存入锁记录中</p>
<p><img src="https://img-blog.csdnimg.cn/20210130164905217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>如果cas替换成功，那么对象的对象头存储的就是锁记录的地址和状态 00表示轻量级锁，如下</p>
<p><img src="https://img-blog.csdnimg.cn/20210130165114847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>如果cas失败，有两种情况</p>
<ol>
<li>如果是<code>其它线程</code>已经持有了<code>该Object的轻量级锁</code>，那么表示<strong>有竞争</strong>，将进入 <strong>锁膨胀阶段</strong> 。此时<code>对象Object</code>对象头中已经存储了别的线程的<code>锁记录地址 00</code>,指向了其他线程;</li>
<li>如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条Lock Record作为重入的计数</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210130165409613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>当线程退出synchronized代码块的时候，如果获取的是取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src="https://img-blog.csdnimg.cn/20210130165114847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为null，那么使用cas将Mark Word的值恢复给对象</p>
<ol>
<li>成功则解锁</li>
<li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ol>
</li>
</ol>
<h4 id="3）锁膨胀"><a href="#3）锁膨胀" class="headerlink" title="3）锁膨胀"></a>3）锁膨胀</h4><p>如果在尝试<code>加轻量级锁</code>的过程中，<code>cas替换操作无法成功</code>，这是<strong>有一种情况就是其它线程已经为这个对象加上了轻量级锁</strong>，这是就要进行<code>锁膨胀(有竞争)</code>，<strong>将轻量级锁变成重量级锁。</strong></p>
<p>当Thread - 1进行轻量级加锁时，Thread - 0已经对该对象加了轻量级锁，此时发生锁膨胀</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png" srcset="/img/loading.gif" lazyload></p>
<p>这时Thread-1加轻量级锁失败，<strong>进入锁膨胀流程</strong></p>
<ul>
<li><strong>因为Thread-1线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念</strong>, 所以此时就要<code>为对象申请Monitor锁(重量级锁)</code>，让<code>Object指向重量级锁地址 10</code>，然后<code>自己进入Monitor 的EntryList 变成BLOCKED状态</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p>当<code>Thread-0 线程</code>执行完<code>synchronized同步块</code>时，<strong>使用cas将Mark Word的值恢复给对象头</strong>, 肯定恢复失败,因为对象的对象头中存储的是<code>重量级锁的地址,状态变为10了</code>之前的是00, 肯定恢复失败。</p>
<p>那么会<code>进入重量级锁的解锁过程</code>，即按照<code>Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程</code></p>
<h4 id="4）自旋优化"><a href="#4）自旋优化" class="headerlink" title="4）自旋优化"></a>4）自旋优化</h4><p>当发生<code>重量级锁竞争的时候</code>，还可以使用<code>自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)</code>，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），<strong>那么当前线程就可以不用进行上下文切换**</strong>(持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程)** 就获得了<code>锁</code></p>
<ul>
<li>优化的点: 不用将<code>线程</code>加入到阻塞队列, 减少cpu切换</li>
</ul>
<ol>
<li><p>自旋重试成功的情况</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>自旋重试失败的情况，<strong>自旋了一定次数还是没有等到持锁的线程释放锁</strong>，线程2就会加入Monitor的阻塞队列（EntryList）</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</strong>。</li>
<li><code>Java 6 之后自旋锁是自适应</code>的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h4 id="5）偏向锁-用于优化轻量级锁重入"><a href="#5）偏向锁-用于优化轻量级锁重入" class="headerlink" title="5）偏向锁(用于优化轻量级锁重入)"></a>5）偏向锁(用于优化轻量级锁重入)</h4><p>场景: 没有竞争的时候, 一个线程中多次使用synchronized需要重入加锁的情况; (只有一个线程进入临界区)</p>
<ul>
<li><p>在经常需要竞争的情况下就不使用偏向锁, 因为偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭</p>
</li>
<li><p>将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</p>
</li>
<li><p>在<code>轻量级的锁</code>中，我们可以发现，如果同一个线程对同一个对象进行<code>重入锁</code>时，<strong>也需要执行CAS替换操作，这是有点耗时。</strong></p>
</li>
<li><p>那么java6开始引入了<code>偏向锁</code>，<strong>将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了</strong></p>
<ul>
<li><strong>升级为轻量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( <code>此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁</code>)</li>
<li><strong>升级为重量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( <code>此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁</code>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块A</span><br>            m2();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块B</span><br>            m3();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 同步块C</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p><strong>偏向状态</strong></p>
<p>对象头格式：</p>
<p><img src="https://img-blog.csdnimg.cn/20210130181306490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDI4MDU3Ng==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p>一个对象的创建过程</p>
<ul>
<li><p>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值.</p>
</li>
<li><p>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：</p>
<p>-XX:BiasedLockingStartupDelay=0 来禁用延迟</p>
</li>
<li><p>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p>
</li>
</ul>
<p><strong>撤销偏向</strong></p>
<ul>
<li>调用对象的hashCode方法</li>
<li>多个线程使用该对象</li>
<li>调用了wait/notify方法（调用wait方法会导致锁膨胀而使用重量级锁）</li>
</ul>
<h4 id="6）批量重偏向"><a href="#6）批量重偏向" class="headerlink" title="6）批量重偏向"></a>6）批量重偏向</h4><ul>
<li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 t1 的对象仍有机会重新偏向 t2</li>
<li>重偏向会重置Thread ID</li>
<li>当撤销超过20次后（超过阈值），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li>
</ul>
<h4 id="7）批量撤销"><a href="#7）批量撤销" class="headerlink" title="7）批量撤销"></a>7）批量撤销</h4><p>当撤销偏向锁的阈值超过 40 以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从JDK1.6开始，synchronized锁的实现发生了很大的变化；JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁，轻量级锁以及重量级锁，从而减少锁的竞争带来的用户态与内核态之间的切换；这种锁的优化实际上是通过java对象头中的一些标志位去实现的；对于锁的访问与改变，实际上都是与java对象头息息相关。对象实例在堆中会被划分为三个部分：对象头，实例数据与对其填充。对象头也是由三块内容来构成：</p>
<ol>
<li>Mark Word</li>
<li>指向类的指针</li>
<li>数组长度</li>
</ol>
<p>其中Mark Word（它记录了对象，锁及垃圾回收的相关信息，在64位的JVM中，其长度也是 64bit 的）的位信息包括如下组成部分：</p>
<ol>
<li>无锁标记（hashcode、分代年龄、偏向锁标志）</li>
<li>偏向锁标记 （偏向线程 id）</li>
<li>轻量级锁标记 （锁记录）</li>
<li>重量级锁标记 （Monitor）</li>
<li>GC标记</li>
</ol>
<p>对于 synchronized 锁来说，锁的升级主要是通过 Mark Word 中的锁标记位与是否是偏向锁标记为来达成的；synchronized 关键字所对象的锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后变成了重量级锁。</p>
<ol>
<li><p>偏向锁：针对一个线程来说的，主要作用是优化同一个线程多次获取一个锁的情况， 当一个线程执行了一个 synchronized 方法的时候，肯定能得到对象的 monitor ，这个方法所在的对象就会在 Mark Work 处设为偏向锁标记，还会有一个字段指向拥有锁的这个线程的线程 ID 。</p>
<p>当这个线程再次访问同一个 synchronized 方法的时候，如果按照通常的方法，这个线程还是要尝试获取这个对象的 monitor ，再执行这个 synchronized 方法。但是由于 Mark Word 的存在，当第二个线程再次来访问的时候，就会检查这个对象的 Mark Word 的偏向锁标记，再判断一下这个字段记录的线程 ID 是不是跟第二个线程的 ID 是否相同的。如果相同，就无需再获取 monitor 了，直接进入方法体中。</p>
</li>
</ol>
<p>如果是另一个线程访问这个 synchronized 方法，那么实际情况会如何呢？：偏向锁会被取消掉。</p>
<ol start="2">
<li>轻量级锁：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程再争抢时，会发现该对象头中的 Mark Word 已经是偏向锁，但里面储存的线程 ID 并不是自己（是第一个线程），那么她会进行 CAS(Compare and Swap)，从而获取到锁，这里面存在两种情况：<ol>
<li>获取到锁成功（一共只有两个线程）：那么它会将 Mark Word 中的线程 ID 由第一个线程变成自己(偏向锁标记位保持不表)，这样该对象依然会保持偏向锁的状态</li>
<li>获取锁失败（一共不止两个线程）：则表示这时可能会有多个线程同时再尝试争抢该对象的锁，那么这是偏向锁就会进行升级，升级为轻量级锁</li>
<li>自旋锁，若自旋失败，那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到 moniter(即内核态)，自旋最大的特点是避免了线程从用户态进入到内核态。</li>
</ol>
</li>
</ol>
<h3 id="6-Wait-Notify"><a href="#6-Wait-Notify" class="headerlink" title="6.Wait/Notify"></a>6.Wait/Notify</h3><h4 id="1）原理"><a href="#1）原理" class="headerlink" title="1）原理"></a>1）原理</h4><p><img src="https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>当线程0获得到了锁, 成为Monitor的Owner, 但是此时它发现自己想要执行synchroized代码块的条件不满足; 此时它就调用obj.wait方法, 进入到Monitor中的WaitSet集合, 此时线程0的状态就变为WAITING</strong></li>
<li>处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为<code>阻塞状态</code>，CPU都不会分给他们时间片。但是有所区别：<ul>
<li><code>BLOCKED状态</code>的线程是在<code>竞争锁对象</code>时，<code>发现Monitor的Owner已经是别的线程了</code><strong>，此时就会进入EntryList中，并处于BLOCKED状态</strong></li>
<li><code>WAITING状态</code>的线程是<code>获得了对象的锁</code>，但是自身的原因无法执行<code>synchroized的临界区资源</code>需要进入<code>阻塞状态</code>时，<strong>锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</strong></li>
</ul>
</li>
<li><strong>处于BLOCKED状态的线程会在锁被释放的时候被唤醒</strong></li>
<li><strong>处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁</strong>(此时就将锁升级为<code>重量级锁</code>)</li>
</ul>
<h4 id="2）Wait与Sleep的区别"><a href="#2）Wait与Sleep的区别" class="headerlink" title="2）Wait与Sleep的区别"></a>2）Wait与Sleep的区别</h4><ul>
<li>Sleep 是 Thread 类的静态方法，Wait 是 Object 的方法，Object 又是所有类的父类，所以所有类都有Wait方法。</li>
</ul>
<ul>
<li>Sleep 在阻塞的时候不会释放锁，而 Wait 在阻塞的时候会释放锁，它们都会释放 CPU 资源。</li>
<li>Sleep 不需要与 synchronized 一起使用，而 Wait 需要与 synchronized 一起使用（对象被锁以后才能使用）</li>
</ul>
<ul>
<li>使用 wait 一般需要搭配 notify 或者 notifyAll 来使用，不然会让线程一直等待。</li>
</ul>
<h4 id="3）优雅地使用-wait-notify"><a href="#3）优雅地使用-wait-notify" class="headerlink" title="3）优雅地使用 wait/notify"></a>3）优雅地使用 wait/notify</h4><p><strong>什么时候适合使用wait</strong></p>
<ul>
<li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用 wait 。这样会<strong>将对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用 sleep，<strong>会导致所有线程都进入阻塞</strong>，导致所有线程都没法运行，直到当前线程 sleep 结束后，运行完毕，才能得到执行。</li>
</ul>
<p><strong>使用wait/notify需要注意什么</strong></p>
<ul>
<li>当有多个线程在运行时，对象调用了 wait 方法，此时这些线程都会进入 WaitSet 中等待。如果这时使用了 notify 方法，可能会<strong>造成虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用 notifyAll 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span><br>		lock.wait();<br>	&#125;<br>	<span class="hljs-comment">//满足条件后再运行</span><br>&#125;<br><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>	<span class="hljs-comment">//唤醒所有等待线程</span><br>	lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4）同步模式之保护性暂停"><a href="#4）同步模式之保护性暂停" class="headerlink" title="4）同步模式之保护性暂停"></a>4）同步模式之保护性暂停</h4><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果，要点：</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果<strong>有结果不断从一个线程到另一个线程</strong> 那么可以使用<code>消息队列</code>（见生产者/消费者）</li>
<li>JDK 中，<code>join 的实现、Future 的实现</code>，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到<code>同步模式</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e73412e2618ca103105cce41f4b228c9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>一方等待另一方的执行结果</code>举例</li>
<li>举例, 线程1等待线程2下载的结果,并获取该结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 多线程同步模式 - 一个线程需要等待另一个线程的执行结果</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardeObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 线程1等待线程2的下载结果</span><br>        GuardeObject guardeObject = <span class="hljs-keyword">new</span> GuardeObject();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>            List&lt;String&gt; list = (List&lt;String&gt;) guardeObject.get();<br>            log.debug(<span class="hljs-string">&quot;结果大小:&#123;&#125;&quot;</span>, list.size());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行下载&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;String&gt; list = Downloader.download();<br>                guardeObject.complete(list);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObject</span> </span>&#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 防止虚假唤醒</span><br>            <span class="hljs-comment">// 没有结果</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>线程t1</code> 等待 <code>线程t2</code>的结果, 可以<code>设置超时时间</code>, 如果超过时间还没返回结果,此时就不等了.退出while循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardeObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 线程1等待线程2的下载结果</span><br>        GuardeObject guardeObject = <span class="hljs-keyword">new</span> GuardeObject();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Object obj = guardeObject.get(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, obj);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            <span class="hljs-comment">// Sleeper.sleep(1); // 在等待时间内</span><br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>            guardeObject.complete(<span class="hljs-keyword">new</span> Object());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardeObject</span> </span>&#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示等待多久. 这里假如是2s</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,</span><br>                    <span class="hljs-comment">// 进入while循环的时候response还是空,此时判断1s&lt;=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了</span><br>                    <span class="hljs-comment">// 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)</span><br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在等待时间内的情况</span><br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">41.627</span> guizy.GuardeObjectTest [t1] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">41.627</span> guizy.GuardeObjectTest [t2] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">20</span>:<span class="hljs-number">42.633</span> guizy.GuardeObjectTest [t1] - 结果是:java.lang.Object@1e1d0168<br><br><span class="hljs-comment">// 超时的情况</span><br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">24.663</span> guizy.GuardeObjectTest [t2] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">24.663</span> guizy.GuardeObjectTest [t1] - begin<br><span class="hljs-number">16</span>:<span class="hljs-number">21</span>:<span class="hljs-number">26.667</span> guizy.GuardeObjectTest [t1] - 结果是:<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure>

<ul>
<li>关于超时的增强，在<code>join(long millis) 的源码</code>中得到了体现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> base = System.currentTimeMillis();<br>    <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// join一个指定的时间</span><br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-keyword">long</span> delay = millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>多任务版GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。</li>
<li>不仅能够<code>解耦</code>【结果等待者】和【结果生产者】，还能够同时支持<code>多个任务的管理</code>。和生产者消费者模式的区别就是：<strong>这个产生结果的线程和使用结果的线程是一一对应的关系，但是生产者消费者模式并不是。</strong></li>
<li>rpc框架的调用中就使用到了这种模式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8af156fb943083720b551f6e52ddd03c.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 同步模式保护性暂停模式 (多任务版)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 14:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.GuardedObjectTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObjectTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> People().start();<br>        &#125;<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br>            <span class="hljs-keyword">new</span> Postman(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.People&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 收信</span><br>        GuardedObject guardedObject = Mailboxes.createGuardedObject();<br>        log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>        Object mail = guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Postman&quot;)</span><br><span class="hljs-comment">// 邮寄员类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Postman</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String mail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.mail = mail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>        guardedObject.complete(mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 信箱类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mailboxes</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">getGuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-comment">//根据id获取到box并删除对应的key和value,避免堆内存爆了</span><br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title">createGuardedObject</span><span class="hljs-params">()</span> </span>&#123;<br>        GuardedObject go = <span class="hljs-keyword">new</span> GuardedObject(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title">getIds</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 用来传递信息的作用, 当多个类使用GuardedObject,就很不方便,此时需要一个设计一个解耦的中间类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span> </span>&#123;<br>    <span class="hljs-comment">// 标记GuardedObject</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GuardedObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示等待多久. 这里假如是2s</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-keyword">long</span> waitTime = timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,</span><br>                    <span class="hljs-comment">// 进入while循环的时候response还是空,此时判断1s&lt;=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了</span><br>                    <span class="hljs-comment">// 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)</span><br>                    <span class="hljs-keyword">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">complete</span><span class="hljs-params">(Object response)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-keyword">this</span>.response = response;<br>            <span class="hljs-keyword">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5）异步模式之生产者-消费者（重点）"><a href="#5）异步模式之生产者-消费者（重点）" class="headerlink" title="5）异步模式之生产者/消费者（重点）"></a>5）异步模式之生产者/消费者（重点）</h4><ul>
<li>与前面的<code>保护性暂停</code>中的 <code>GuardedObject</code> 不同，<strong>不需要</strong><code>产生结果</code>和<code>消费结果</code>的<code>线程一一对应 (一个生产一个消费)</code></li>
<li><strong>消费队列</strong> 可以用来<strong>平衡生产和消费的线程资源</strong></li>
<li><strong>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</strong></li>
<li><strong>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</strong></li>
</ul>
<ul>
<li>JDK 中各种 <a target="_blank" rel="noopener" href="https://blog.csdn.net/yanpenglei/article/details/79556591">阻塞队列</a>，采用的就是这种模式</li>
</ul>
<p>异步模式中, 生产者产生消息之后消息没有被立刻消费<br>同步模式中, 消息在产生之后被立刻消费了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/82487e714da1c44453d46a61d6dcb27b.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>我们下面写的小例子是<code>线程间通信</code>的<code>消息队列</code>，要注意区别,像<code>RabbitMQ</code>等消息框架是<code>进程间通信</code>的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 异步模式之生产者/消费者</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/21 18:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;giuzy.ProductConsumerTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductConsumerTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> id = i;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                queue.put(<span class="hljs-keyword">new</span> Message(id, <span class="hljs-string">&quot;值&quot;</span> + id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>        &#125;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Sleeper.sleep(<span class="hljs-number">1</span>);<br>                Message message = queue.take();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 消息队列类,在线程之间通信</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.MessageQueue&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息的队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 队列容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capcity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capcity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Message <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 检查队列是否为空</span><br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 从队列头部获取消息并返回</span><br>            Message message = list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 存入消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">// 检查对象是否已满</span><br>            <span class="hljs-keyword">while</span> (list.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>);<br>                    list.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, Object value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.440</span> guizy.MessageQueue [生产者<span class="hljs-number">1</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.443</span> guizy.MessageQueue [生产者<span class="hljs-number">0</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">53.444</span> guizy.MessageQueue [生产者<span class="hljs-number">2</span>] - 队列已满, 生产者线程等待<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.439</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">1</span>, value=值<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">54.439</span> guizy.MessageQueue [生产者<span class="hljs-number">2</span>] - 已生产消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">55.439</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">0</span>, value=值<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">56.440</span> guizy.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="hljs-number">2</span>, value=值<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">18</span>:<span class="hljs-number">52</span>:<span class="hljs-number">57.441</span> guizy.MessageQueue [消费者] - 队列为空, 消费者线程等待<br></code></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li>当调用 wait 时，首先需要确保调用了 wait 方法的线程已经持有了对象的锁(调用 wait 方法的代码片段需要放在 sychronized 块或者时 sychronized 方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁)</li>
<li>当调用 wait 时，该线程就会释放掉这个对象的锁，然后进入等待状态 (wait set)</li>
<li>当线程调用了 wait 后进入到等待状态时，它就可以等待其他线程调用相同对象的 notify 或者 notifyAll 方法使得自己被唤醒</li>
<li>一旦这个线程被其它线程唤醒之后，该线程就会与其它线程以同开始竞争这个对象的锁(公平竞争)；只有当该线程获取到对象的锁后，线程才会继续往下执行</li>
<li>当调用对象的 notify 方法时，他会随机唤醒对象等待集合 (wait set) 中的任意一个线程，当某个线程被唤醒后，它就会与其它线程一同竞争对象的锁</li>
<li>当调用对象的 notifyAll 方法时，它会唤醒该对象等待集合 (wait set) 中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁</li>
<li>在某一时刻，只有唯一的一个线程能拥有对象的锁</li>
</ol>
<h3 id="7-park-amp-unpark"><a href="#7-park-amp-unpark" class="headerlink" title="7.park &amp; unpark"></a>7.park &amp; unpark</h3><h4 id="1）-基本使用"><a href="#1）-基本使用" class="headerlink" title="1） 基本使用"></a>1） 基本使用</h4><p>park &amp; unpark是LockSupport线程通信工具类的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 暂停当前线程</span><br>LockSupport.park();<br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark;<br></code></pre></td></tr></table></figure>

<p>先调用unpark后，在调用park，此时park不会暂停线程</p>
<h4 id="2）park-amp-unpark原理"><a href="#2）park-amp-unpark原理" class="headerlink" title="2）park &amp; unpark原理"></a>2）park &amp; unpark原理</h4><p><code>每个线程</code>都有自己的一个 <code>Parker 对象</code>，由三部分组成 <strong>_counter， _cond和 _mutex</strong></p>
<ul>
<li>打个比喻线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 _ cond就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li>
<li><strong>调用 park 就是要看需不需要停下来歇息</strong><ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
</li>
<li><strong>调用 unpark，就好比令干粮充足</strong><ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进</li>
<li>因为背包空间有限，<strong>多次调用 unpark 仅会补充一份备用干粮</strong></li>
</ul>
</li>
</ul>
<h5 id="先调用park在调用unpark的过程"><a href="#先调用park在调用unpark的过程" class="headerlink" title="先调用park在调用unpark的过程"></a><strong>先调用park在调用unpark的过程</strong></h5><ul>
<li><strong>调用park</strong><ul>
<li>当前线程调用 <strong>Unsafe.park()</strong> 方法</li>
<li><strong>检查 _counter, 本情况为0,</strong> 这时, 获得<code>_mutex 互斥锁</code><strong>(mutex对象有个等待队列 _cond)</strong></li>
<li>线程进入 _cond 条件变量<code>阻塞</code></li>
<li>设置<code>_counter = 0</code> (没干粮了)</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/090e9cb2aed20d43c147ec0ea6470d5e.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>调用unpark<ul>
<li>调用<code>Unsafe.unpark(Thread_0)方法</code>，设置<code>_counter 为 1</code></li>
<li>唤醒 _cond 条件变量中的 Thread_0</li>
<li>Thread_0 <code>恢复运行</code></li>
<li><strong>设置 _counter 为 0</strong></li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ca03643f837f34098def91bfadc54bd6.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="先调用unpark在调用park的过程"><a href="#先调用unpark在调用park的过程" class="headerlink" title="先调用unpark在调用park的过程"></a><strong>先调用unpark在调用park的过程</strong></h5><ul>
<li>调用<code>Unsafe.unpark(Thread_0)</code>方法，设置 <code>_counter 为 1</code></li>
<li>当前<code>线程</code>调用 <code>Unsafe.park()</code> 方法</li>
<li>检查 <code>_counter</code>，本情况为 <code>1</code>，这时线程 <strong>无需阻塞，继续运行</strong></li>
<li>设置 _counter 为 0</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0d3270088a031c2066af2762e894413.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="8-线程状态转换"><a href="#8-线程状态转换" class="headerlink" title="8.线程状态转换"></a>8.线程状态转换</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/20201221214359753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>1.<strong>NEW &lt;–&gt; RUNNABLE</strong><ul>
<li>t.start()方法时，NEW —&gt; RUNNABLE</li>
</ul>
</li>
<li>2.<strong>RUNNABLE &lt;-&gt;WAITING</strong><ul>
<li>线程用synchronized(obj)获取了对象锁后<ul>
<li>调用 <strong>obj.wait()方法时，t 线程进入waitSet</strong>中, 从<code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <strong>obj.notify()，obj.notifyAll()，t.interrupt()</strong> 时, 唤醒的线程都到<strong>entrySet</strong>阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列,和其他线程再进行 <strong>竞争锁</strong><ul>
<li><strong>竞争锁成功</strong>，t 线程从 <code>WAITING --&gt; RUNNABLE</code></li>
<li><strong>竞争锁失败</strong>，t 线程从 <code>WAITING --&gt; BLOCKED</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>3.<strong>RUNNABLE &lt;–&gt; WAITING</strong><ul>
<li><strong>当前线程</strong>调用 <strong>t.join()</strong> 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> ,注意是<strong>当前线程</strong>在t线程对象在<strong>waitSet</strong>上等待</li>
<li><strong>t 线程运行结束，或调用了当前线程的 interrupt() 时</strong>，<strong>当前线程</strong>从 <code>WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li>4.<strong>RUNNABLE &lt;–&gt; WAITING</strong><ul>
<li>当前线程调用 <strong>LockSupport.park()</strong> 方法会让<strong>当前线程</strong>从<code>RUNNABLE --&gt; WAITING</code></li>
<li>调用 <strong>LockSupport.unpark(目标线程)</strong> 或调用了线程 的 <strong>interrupt()</strong> ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
</ul>
<p><strong>Runnable 和 Timed-Waiting的相互转换</strong></p>
<ul>
<li>5.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING (带超时时间的wait)</strong><ul>
<li>t 线程用<code>synchronized(obj)</code> 获取了<code>对象锁</code>后<ul>
<li>调用 <strong>obj.wait(long n)</strong> 方法时，t 线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify() ， obj.notifyAll() ，t.interrupt()</code> 时; 唤醒的线程都到<strong>entrySet</strong>阻塞队列成为<code>BLOCKED</code>状态, 在阻塞队列,和其他线程再进行 <strong>竞争锁</strong><ul>
<li>竞争锁成功，t 线程从 <strong>TIMED_WAITING –&gt; RUNNABLE</strong></li>
<li>竞争锁失败，t 线程从 <strong>TIMED_WAITING –&gt; BLOCKED</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>6.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <strong>t.join(long n)</strong> 方法时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code> 注意是当前线程在t 线程对象的<strong>waitSet</strong>等待</li>
<li>当前线程等待时间超过了 n 毫秒，<strong>或t 线程运行结束，或调用了当前线程的 interrupt() 时</strong>，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li>7.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>当前线程等待时间超过了 n 毫秒或调用了线程的 <strong>interrupt()</strong> ，当前线程从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>
</li>
<li>8.<strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><ul>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis)</code> 时，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>用<code>LockSupport.unpark(目标线程) 或调用了线程 的 interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ul>
</li>
<li>9.<strong>RUNNABLE &lt;–&gt; BLOCKED</strong><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ul>
</li>
<li>10.<strong>RUNNABLE &lt;–&gt; TERMINATED</strong><ul>
<li>当前线程所有代码运行完毕，进入 TERMINATED</li>
</ul>
</li>
</ul>
<h3 id="9-活跃性"><a href="#9-活跃性" class="headerlink" title="9.活跃性"></a>9.活跃性</h3><p><img src="https://img-blog.csdnimg.cn/20210202223351594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h4 id="1）多把锁"><a href="#1）多把锁" class="headerlink" title="1）多把锁"></a>1）多把锁</h4><p>将锁粒度细分</p>
<ul>
<li>好处，可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BigRoom bigRoom = <span class="hljs-keyword">new</span> BigRoom();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; bigRoom.sleep(), <span class="hljs-string">&quot;小南&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; bigRoom.study(), <span class="hljs-string">&quot;小女&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoom&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 相当于串行执行, 因为锁对象是整个屋子, 所以并发性很低</span><br><span class="hljs-number">12</span>:<span class="hljs-number">16</span>:<span class="hljs-number">15.952</span> guizy.BigRoom [小南] - sleeping <span class="hljs-number">2</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">16</span>:<span class="hljs-number">17.954</span> guizy.BigRoom [小女] - study <span class="hljs-number">1</span> 小时<br></code></pre></td></tr></table></figure>

<ul>
<li>改进让<code>小南, 小女</code>获取不同的锁即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BigRoom sleepRoom = <span class="hljs-keyword">new</span> BigRoom();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BigRoom studyRoom = <span class="hljs-keyword">new</span> BigRoom();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    	<span class="hljs-comment">// 不同对象调用</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; sleepRoom.sleep(), <span class="hljs-string">&quot;小南&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; studyRoom.study(), <span class="hljs-string">&quot;小女&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为使用的是不同的锁对象</span><br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">50.580</span> guizy.BigRoom [小女] - study <span class="hljs-number">1</span> 小时<br><span class="hljs-number">12</span>:<span class="hljs-number">18</span>:<span class="hljs-number">50.580</span> guizy.BigRoom [小南] - sleeping <span class="hljs-number">2</span> 小时<br></code></pre></td></tr></table></figure>

<h4 id="2）活跃性"><a href="#2）活跃性" class="headerlink" title="2）活跃性"></a>2）活跃性</h4><ul>
<li>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 <strong>活跃性</strong></li>
</ul>
<h5 id="1-死锁（重点）"><a href="#1-死锁（重点）" class="headerlink" title="1.死锁（重点）"></a>1.死锁（重点）</h5><ul>
<li>有这样的情况：一个线程需要 <strong>同时获取多把锁</strong>，这时就容易发生死锁</li>
</ul>
<p>如：线程1获取A对象锁, 线程2获取B对象锁; 此时线程1又想获取B对象锁, 线程2又想获取A对象锁; 它们都等着对象释放锁, 此时就称为死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<br>	<span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<br>	<br>	<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>		<span class="hljs-keyword">synchronized</span> (A) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">2000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-keyword">synchronized</span> (B) &#123;<br><br>			&#125;<br>		&#125;<br>	&#125;).start();<br><br>	<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>		<span class="hljs-keyword">synchronized</span> (B) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<span class="hljs-keyword">synchronized</span> (A) &#123;<br><br>			&#125;<br>		&#125;<br>	&#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="1-2发生死锁的必要条件（重点）"><a href="#1-2发生死锁的必要条件（重点）" class="headerlink" title="1.2发生死锁的必要条件（重点）"></a>1.2发生死锁的必要条件（重点）</h5><ul>
<li>互斥条件<ul>
<li>在一段时间内，<code>一种资源只能被一个进程所使</code></li>
</ul>
</li>
<li>请求和保持条件<ul>
<li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
</ul>
</li>
<li>不可抢占条件<ul>
<li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
</ul>
</li>
<li>循环等待条件<ul>
<li>发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
</li>
</ul>
<h5 id="1-3定位死锁的方法"><a href="#1-3定位死锁的方法" class="headerlink" title="1.3定位死锁的方法"></a>1.3定位死锁的方法</h5><ol>
<li>JPS+JStack 进程ID</li>
<li>jconsole检测死锁</li>
</ol>
<h5 id="1-4死锁举例-哲学家就餐问题（重点）"><a href="#1-4死锁举例-哲学家就餐问题（重点）" class="headerlink" title="1.4死锁举例-哲学家就餐问题（重点）"></a>1.4死锁举例-哲学家就餐问题（重点）</h5><p><img src="https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p>有五位哲学家，围坐在圆桌旁。</p>
<ul>
<li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li>
<li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li>
<li>如果筷子被身边的人拿着，自己就得等待</li>
</ul>
<p>当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用synchronized加锁, 导致哲学家就餐问题, 死锁: 核心原因是因为synchronized的锁是不可打断的, 进入阻塞队列</span><br><span class="hljs-comment"> *                  需要一直等待别的线程释放锁</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhilosopherEat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>        Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>        Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>        Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>        Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Chopstick left;<br>    <span class="hljs-keyword">final</span> Chopstick right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 尝试获取左手筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 尝试获取右手筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span></span>&#123;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 程序只执行了下面的打印, 没有停止, 没有打印</span><br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.346</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.346</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.850</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">55.850</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">56.351</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">56.852</span> guizy.Philosopher [亚里士多德] - eating...<br></code></pre></td></tr></table></figure>

<p>通过<code>jps, jstack 进程id</code>查看死锁原因<br><code>Found one Java-level deadlock:</code> 发现了一个Java级别的死锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;阿基米德&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000001ae2a358</span> (object <span class="hljs-number">0x00000000d6ea7420</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;苏格拉底&quot;</span><br><span class="hljs-string">&quot;苏格拉底&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb3518</span> (object <span class="hljs-number">0x00000000d6ea7430</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;柏拉图&quot;</span><br><span class="hljs-string">&quot;柏???图&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb3468</span> (object <span class="hljs-number">0x00000000d6ea7440</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;亚里士多德&quot;</span><br><span class="hljs-string">&quot;亚里士多德&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb0bd8</span> (object <span class="hljs-number">0x00000000d6ea7450</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;赫拉克利特&quot;</span><br><span class="hljs-string">&quot;赫拉克利特&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x0000000017fb0c88</span> (object <span class="hljs-number">0x00000000d6ea7460</span>, a com.guizy.reentrantlock.Chopstick),<br>  which is held by <span class="hljs-string">&quot;阿基米德&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;阿基米德&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7420</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7460</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;苏格拉底&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7430</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7420</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;柏拉图&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7440</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7430</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;亚里士多德&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7450</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7440</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><span class="hljs-string">&quot;赫拉克利特&quot;</span>:<br>        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d6ea7460</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br>        - locked &lt;<span class="hljs-number">0x00000000d6ea7450</span>&gt; (a com.guizy.reentrantlock.Chopstick)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>

<h5 id="1-5、避免死锁方法"><a href="#1-5、避免死锁方法" class="headerlink" title="1.5、避免死锁方法"></a>1.5、避免死锁方法</h5><ul>
<li>在线程使用锁对象时, 采用<strong>固定加锁的顺序</strong>, 可以使用Hash值的大小来确定加锁的先后</li>
<li>尽可能缩减加锁的范围，等到操作共享变量的时候才加锁</li>
<li>使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-活锁"><a href="#2-活锁" class="headerlink" title="2.活锁"></a>2.活锁</h4><p><code>活锁</code>出现在两个线程 <strong>互相改变对方的结束条件</strong>，谁也无法结束</p>
<h5 id="2-1-避免活锁的方法"><a href="#2-1-避免活锁的方法" class="headerlink" title="2.1 避免活锁的方法"></a>2.1 避免活锁的方法</h5><ul>
<li>在线程执行时，中途给予 <strong>不同的间隔时间</strong>, 让某个线程先结束即可。</li>
</ul>
<h5 id="2-2死锁和活锁的区别"><a href="#2-2死锁和活锁的区别" class="headerlink" title="2.2死锁和活锁的区别"></a>2.2死锁和活锁的区别</h5><ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
</ul>
<ul>
<li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li>
</ul>
<h4 id="3-饥饿"><a href="#3-饥饿" class="headerlink" title="3.饥饿"></a>3.饥饿</h4><ul>
<li>某些线程因为优先度太低，导致一直无法获取资源的现象</li>
<li>在使用顺序加锁时，可能会出现饥饿现象</li>
</ul>
<h3 id="10-ReentrantLock"><a href="#10-ReentrantLock" class="headerlink" title="10.ReentrantLock"></a>10.ReentrantLock</h3><h4 id="1-支持锁重入"><a href="#1-支持锁重入" class="headerlink" title="1.支持锁重入"></a>1.支持锁重入</h4><ul>
<li>可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把<code>锁的拥有者</code>，因此 <strong>有权利再次获取这把锁</strong></li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    	<span class="hljs-comment">// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry main...&quot;</span>);<br>            m1();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;entry m1...&quot;</span>);<br>            m2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;entry m2....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.324</span> guizy.ReentrantTest [main] - entry main...<br><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.326</span> guizy.ReentrantTest [main] - entry m1...<br><span class="hljs-number">13</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.326</span> guizy.ReentrantTest [main] - entry m2....<br></code></pre></td></tr></table></figure>

<h4 id="2-可中断（针对于lockInterruptibly-方法获得的中断锁）直接退出阻塞队列，获取锁失败"><a href="#2-可中断（针对于lockInterruptibly-方法获得的中断锁）直接退出阻塞队列，获取锁失败" class="headerlink" title="2.可中断（针对于lockInterruptibly()方法获得的中断锁）直接退出阻塞队列，获取锁失败"></a>2.可中断（针对于lockInterruptibly()方法获得的中断锁）直接退出阻塞队列，获取锁失败</h4><p><strong>synchronized</strong> 和 <strong>reentrantlock.lock()</strong> 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断</p>
<ul>
<li>可被中断的锁, 通过<code>lock.lockInterruptibly()</code>获取的锁对象, 可以通过调用<strong>阻塞线程的interrupt()方法</strong></li>
<li>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，<strong>获得锁失败</strong><ul>
<li>处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</li>
</ul>
</li>
<li>可中断的锁，在一定程度上可以被动的减少死锁的概率，之所以被动，是因为我们需要手动调用<code>阻塞线程的interrupt</code>方法;</li>
</ul>
<p>测试使用<code>lock.lockInterruptibly()</code>可以从阻塞队列中,打断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的可打断锁方法 lock.lockInterruptibly();</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1线程启动...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>); <span class="hljs-comment">//没有获得锁就被打断跑出的异常</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程获得了锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 主线程获得锁(此锁不可打断)</span><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;main线程获得了锁&quot;</span>);<br>        <span class="hljs-comment">// 启动t1线程</span><br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            t1.interrupt();            <span class="hljs-comment">//打断t1线程</span><br>            log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">09.145</span> guizy.ReentrantTest [main] - main线程获得了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">09.148</span> guizy.ReentrantTest [t1] - t1线程启动...<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.149</span> guizy.ReentrantTest [main] - 执行打断<br><span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">10.149</span> guizy.ReentrantTest [t1] - 等锁的过程中被打断<br>java.lang.InterruptedException<br>	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">898</span>)<br>	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">1222</span>)<br>	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>)<br>	at com.guizy.reentrantlock.ReentrantTest.lambda$main$<span class="hljs-number">0</span>(ReentrantTest.java:<span class="hljs-number">25</span>)<br>	at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br></code></pre></td></tr></table></figure>

<p>测试使用<code>lock.lock()</code>不可以从阻塞队列中打断, 一直等待别的线程释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;t1线程启动...&quot;</span>);<br>                lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;t1线程获得了锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">// 主线程获得锁(此锁不可打断)</span><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;main线程获得了锁&quot;</span>);<br>        <span class="hljs-comment">// 启动t1线程</span><br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">4</span>);<br>            t1.interrupt();            <span class="hljs-comment">//打断t1线程</span><br>            log.debug(<span class="hljs-string">&quot;main线程执行打断&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>lock()锁不能被打断</strong>, 在主线程中调用t1.interrupt(), 没用, 当主线程释放锁之后, t1获得了锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">01.329</span> guizy.ReentrantTest [main] - main线程获得了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">01.331</span> guizy.ReentrantTest [t1] - t1线程启动...<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">05.333</span> guizy.ReentrantTest [main] - main线程执行打断<br><span class="hljs-number">14</span>:<span class="hljs-number">21</span>:<span class="hljs-number">05.333</span> guizy.ReentrantTest [t1] - t1线程获得了锁<br></code></pre></td></tr></table></figure>

<h4 id="3-锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败"><a href="#3-锁超时-lock-tryLock-直接退出阻塞队列-获取锁失败" class="headerlink" title="3.锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败"></a>3.锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败</h4><p><strong>防止无限制等待, 减少死锁</strong></p>
<ul>
<li>使用 <strong>lock.tryLock()</strong> 方法会<code>返回获取锁是否成功</code>。如果成功则返回true，反之则返回false。</li>
</ul>
<ul>
<li>并且<code>tryLock方法</code>可以设置<strong>指定等待时间</strong>，参数为：<strong>tryLock(long timeout, TimeUnit unit)</strong> , 其中timeout为最长等待时间，TimeUnit为时间单位</li>
</ul>
<p>获取锁的过程中, 如果<code>超过等待时间</code>, <code>或者被打断</code>, 就直接从<code>阻塞队列</code>移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)</p>
<ul>
<li><strong>不设置等待时间, 立即失败</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(), 获取锁立即失败</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);<br>            <span class="hljs-comment">// 此时肯定获取失败, 因为主线程已经获得了锁对象</span><br>            <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>                log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 主线程2s之后才释放锁</span><br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.726</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.728</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">19.728</span> guizy.WaitNotifyTest [t1] - 获取立刻失败，返回<br><span class="hljs-number">14</span>:<span class="hljs-number">52</span>:<span class="hljs-number">21.728</span> guizy.WaitNotifyTest [main] - 释放了锁<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock, 演示RenntrantLock中的tryLock(long mills), 超过锁设置的等待时间,就从阻塞队列移除</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ReentrantTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 设置等待时间, 超过等待时间 / 被打断, 都会获取锁失败; 退出阻塞队列</span><br>                <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取锁超时，返回&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.debug(<span class="hljs-string">&quot;被打断了, 获取锁失败, 返回&quot;</span>);<br>                e.printStackTrace();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>        t1.start();<br><span class="hljs-comment">//        t1.interrupt();</span><br>        <span class="hljs-comment">// 主线程2s之后才释放锁</span><br>        Sleeper.sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;main线程释放了锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 超时的打印</span><br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">56.647</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">56.651</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">57.652</span> guizy.WaitNotifyTest [t1] - 获取锁超时，返回<br><span class="hljs-number">14</span>:<span class="hljs-number">55</span>:<span class="hljs-number">58.652</span> guizy.WaitNotifyTest [main] - main线程释放了锁<br><br><span class="hljs-comment">// 中断的打印</span><br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.258</span> guizy.WaitNotifyTest [main] - 获得到锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.260</span> guizy.WaitNotifyTest [main] - main线程释放了锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.261</span> guizy.WaitNotifyTest [t1] - 尝试获得锁<br><span class="hljs-number">14</span>:<span class="hljs-number">56</span>:<span class="hljs-number">41.261</span> guizy.WaitNotifyTest [t1] - 被打断了, 获取锁失败, 返回<br>java.lang.InterruptedException<br></code></pre></td></tr></table></figure>

<h4 id="通过lock-tryLock-来解决-哲学家就餐问题-重点"><a href="#通过lock-tryLock-来解决-哲学家就餐问题-重点" class="headerlink" title="通过lock.tryLock()来解决, 哲学家就餐问题 (重点)"></a>通过<code>lock.tryLock()</code>来解决, <code>哲学家就餐</code>问题 (<code>重点</code>)</h4><p><code>lock.tryLock(时间)</code> : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用了ReentrantLock锁, 该类中有一个tryLock()方法, 在指定时间内获取不到锁对象, 就从阻塞队列移除,不用一直等待。</span><br><span class="hljs-comment"> *              当获取了左手边的筷子之后, 尝试获取右手边的筷子, 如果该筷子被其他哲学家占用, 获取失败, 此时就先把自己左手边的筷子,</span><br><span class="hljs-comment"> *              给释放掉. 这样就避免了死锁问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.PhilosopherEat&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhilosopherEat</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Chopstick c1 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;1&quot;</span>);<br>        Chopstick c2 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;2&quot;</span>);<br>        Chopstick c3 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;3&quot;</span>);<br>        Chopstick c4 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;4&quot;</span>);<br>        Chopstick c5 = <span class="hljs-keyword">new</span> Chopstick(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> Philosopher(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Philosopher&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Chopstick left;<br>    <span class="hljs-keyword">final</span> Chopstick right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name);<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 获得了左手边筷子 (针对五个哲学家, 它们刚开始肯定都可获得左筷子)</span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                	<span class="hljs-comment">// 此时发现它的right筷子被占用了, 使用tryLock(), </span><br>                	<span class="hljs-comment">// 尝试获取失败, 此时它就会将自己左筷子也释放掉</span><br>                    <span class="hljs-comment">// 临界区代码</span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123; <span class="hljs-comment">//尝试获取右手边筷子, 如果获取失败, 则会释放左边的筷子</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            eat();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    left.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承ReentrantLock, 让筷子类称为锁</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chopstick</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">01.793</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">01.795</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.293</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.295</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.794</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">02.796</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.294</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.296</span> guizy.Philosopher [柏拉图] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.795</span> guizy.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">03.797</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.295</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.297</span> guizy.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.796</span> guizy.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">04.798</span> guizy.Philosopher [阿基米德] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">05.296</span> guizy.Philosopher [柏拉图] - eating...<br><span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">05.299</span> guizy.Philosopher [赫拉克利特] - eating...<br><br></code></pre></td></tr></table></figure>

<h4 id="4-公平锁new-ReentrantLock-true"><a href="#4-公平锁new-ReentrantLock-true" class="headerlink" title="4.公平锁new ReentrantLock(true)"></a>4.公平锁new ReentrantLock(true)</h4><ul>
<li><strong>ReentrantLock默认是非公平锁, 可以指定为公平锁。</strong></li>
<li>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。一般不设置<code>ReentrantLock</code>为公平的, 会降低<code>并发度</code></li>
<li><code>Synchronized</code>底层的<code>Monitor锁</code>就是不公平的, 和谁先进入<code>阻塞队列</code>是没有关系的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>

<h5 id="4-1、什么是公平锁？什么是非公平锁"><a href="#4-1、什么是公平锁？什么是非公平锁" class="headerlink" title="4.1、什么是公平锁？什么是非公平锁"></a>4.1、什么是公平锁？什么是非公平锁</h5><h5 id="公平锁-new-ReentrantLock-true"><a href="#公平锁-new-ReentrantLock-true" class="headerlink" title="公平锁 (new ReentrantLock(true))"></a>公平锁 (new ReentrantLock(true))</h5><ul>
<li>公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上</li>
<li>只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁</li>
</ul>
<h5 id="非公平锁-synchronized-new-ReentrantLock"><a href="#非公平锁-synchronized-new-ReentrantLock" class="headerlink" title="非公平锁 (synchronized, new ReentrantLock())"></a>非公平锁 (synchronized, new ReentrantLock())</h5><ul>
<li>非公平锁, 当阻塞队列中已经有等待的线程A了, 此时后到的线程B, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程B就先获得到锁了</li>
</ul>
<p>所以公平和非公平的区别 : <strong>线程执行同步代码块时, 是否回去尝试获取锁</strong>, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的</p>
<ul>
<li>如果不进如队列呢? 线程一直尝试获取锁不就行了?<ul>
<li>一直尝试获取锁, 在synchronized轻量级锁升级为重量级锁时, 做的一个优化, 叫做<code>自旋锁</code>, 一般很消耗资源, cpu一直空转, 最后获取锁也失败, 所以不推荐使用。在jdk6对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等</li>
</ul>
</li>
</ul>
<h4 id="5-条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒"><a href="#5-条件变量-可避免虚假唤醒-lock-newCondition-创建条件变量对象-通过条件变量对象调用await-signal方法-等待-唤醒" class="headerlink" title="5.条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用await/signal方法, 等待/唤醒"></a>5.条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用<code>await/signal</code>方法, 等待/唤醒</h4><ul>
<li><strong>Synchronized</strong> 中也有<code>条件变量</code>，就是<code>Monitor监视器</code>中的 <code>waitSet等待集合</code>，当条件不满足时进入<code>waitSet 等待</code></li>
<li><strong>ReentrantLock</strong> 的条件变量比 synchronized 强大之处在于,它是 <strong>支持多个条件变量</strong></li>
<li>这就好比synchronized 是那些不满足条件的线程都在<code>一间休息室</code>等通知; <strong>(此时会造成虚假唤醒)</strong>, 而 ReentrantLock 支持<code>多间休息室</code>，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; <strong>(可以避免虚假唤醒)</strong></li>
</ul>
<p>使用要点</p>
<ul>
<li>await 前需要 <strong>获得锁</strong></li>
<li>await 执行后，会释放锁，进入 <code>conditionObject</code> (条件变量)中等待</li>
<li>await 的线程被唤醒（或打断、或超时）去重新竞争 lock 锁<ul>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
</li>
<li>signal 方法用来唤醒<code>条件变量(等待室)</code>汇总的某一个等待的线程</li>
<li>signalAll方法, 唤醒<code>条件变量(休息室)</code>中的所有线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: ReentrantLock可以设置多个条件变量(多个休息室), 相对于synchronized底层monitor锁中waitSet</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 13:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.ConditionVariable&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionVariable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasCigarette = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> hasTakeout = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">// 等待烟的休息室</span><br>    <span class="hljs-keyword">static</span> Condition waitCigaretteSet = lock.newCondition();<br>    <span class="hljs-comment">// 等外卖的休息室</span><br>    <span class="hljs-keyword">static</span> Condition waitTakeoutSet = lock.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小南进入到 等烟的休息室</span><br>                        waitCigaretteSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;烟来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 此时小女进入到 等外卖的休息室</span><br>                        waitTakeoutSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖来咯, 可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送外卖的来咯~&quot;</span>);<br>                hasTakeout = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 唤醒等外卖的小女线程</span><br>                waitTakeoutSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;送烟的来咯~&quot;</span>);<br>                hasCigarette = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">// 唤醒等烟的小南线程</span><br>                waitCigaretteSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span>:08:<span class="hljs-number">58.231</span> guizy.WaitNotifyTest [小南] - 有烟没？[<span class="hljs-keyword">false</span>]<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.234</span> guizy.WaitNotifyTest [小南] - 没烟，先歇会！<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.235</span> guizy.WaitNotifyTest [小女] - 外卖送到没？[<span class="hljs-keyword">false</span>]<br><span class="hljs-number">15</span>:08:<span class="hljs-number">58.235</span> guizy.WaitNotifyTest [小女] - 没外卖，先歇会！<br><span class="hljs-number">15</span>:08:<span class="hljs-number">59.232</span> guizy.WaitNotifyTest [送外卖的] - 送外卖的来咯~<br><span class="hljs-number">15</span>:08:<span class="hljs-number">59.233</span> guizy.WaitNotifyTest [小女] - 外卖来咯, 可以开始干活了<br><span class="hljs-number">15</span>:09:<span class="hljs-number">00.233</span> guizy.WaitNotifyTest [送烟的] - 送烟的来咯~<br><span class="hljs-number">15</span>:09:<span class="hljs-number">00.234</span> guizy.WaitNotifyTest [小南] - 烟来咯, 可以开始干活了<br></code></pre></td></tr></table></figure>

<h3 id="11-同步模式之顺序控制"><a href="#11-同步模式之顺序控制" class="headerlink" title="11.同步模式之顺序控制"></a>11.同步模式之顺序控制</h3><ul>
<li>假如两个线程，线程A打印1，线程B打印2</li>
<li>要求：程序先打印2，在打印1</li>
</ul>
<h4 id="1-Wait-Notify版本实现"><a href="#1-Wait-Notify版本实现" class="headerlink" title="1.Wait/Notify版本实现"></a>1.Wait/Notify版本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用wait/notify来实现顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2Runned = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                    	<span class="hljs-comment">// 进入等待(waitset), 会释放锁</span><br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-keyword">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-使用ReentrantLock的await-signal"><a href="#2-使用ReentrantLock的await-signal" class="headerlink" title="2.使用ReentrantLock的await/signal"></a>2.使用ReentrantLock的await/signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用ReentrantLock的await/sinal 来实现顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Condition condition = lock.newCondition();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> t2Runned = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 临界区</span><br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        condition.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-keyword">true</span>;<br>                condition.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-使用LockSupport中的park-unpark"><a href="#3-使用LockSupport中的park-unpark" class="headerlink" title="3.使用LockSupport中的park/unpark"></a>3.使用LockSupport中的park/unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用LockSupport中的park,unpark来实现, 顺序打印 2, 1</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 16:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.SyncPrintWaitTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncPrintWaitTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>需求：</p>
<ul>
<li><strong>线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcabc</strong></li>
</ul>
<h5 id="wait-notify版本"><a href="#wait-notify版本" class="headerlink" title="wait/notify版本"></a>wait/notify版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWaitNotify</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    WaitNotify waitNotify = <span class="hljs-keyword">new</span> WaitNotify(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    &#125;,<span class="hljs-string">&quot;a线程&quot;</span>).start;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>    &#125;,<span class="hljs-string">&quot;b线程&quot;</span>).start;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      waitnotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-string">&quot;c线程&quot;</span>).start;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.WaitNotify&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag;<br>    <br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输出内容    等待标记    下一个标记</span><br><span class="hljs-comment">        a           1          2</span><br><span class="hljs-comment">        b           2          3</span><br><span class="hljs-comment">        c           3          1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> waitFlag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (waitFlag != <span class="hljs-keyword">this</span>.flag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-keyword">this</span>.flag = nextFlag;<br>                <span class="hljs-keyword">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-await-signal版本"><a href="#2-await-signal版本" class="headerlink" title="2.await/signal版本"></a>2.await/signal版本</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用await/signal来实现三个线程交替打印abcabcabcabcabc</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 17:10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAwaitSignal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal(<span class="hljs-number">5</span>);<br>        Condition a_condition = awaitSignal.newCondition();<br>        Condition b_condition = awaitSignal.newCondition();<br>        Condition c_condition = awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a_condition, b_condition);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b_condition, c_condition);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c_condition, a_condition);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;==========开始=========&quot;</span>);<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            a_condition.signal();  <span class="hljs-comment">//首先唤醒a线程</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AwaitSignal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Condition condition, Condition next)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    condition.await();<br>                    <span class="hljs-comment">//System.out.print(&quot;i:===&quot;+i);</span><br>                    System.out.print(str);<br>                    next.signal();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-LockSupport的park-unpark实现"><a href="#3-LockSupport的park-unpark实现" class="headerlink" title="3.LockSupport的park/unpark实现"></a>3.LockSupport的park/unpark实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用park/unpark来实现三个线程交替打印abcabcabcabcabc</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/23 17:12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParkUnpark</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread a;<br>    <span class="hljs-keyword">static</span> Thread b;<br>    <span class="hljs-keyword">static</span> Thread c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ParkUnpark parkUnpark = <span class="hljs-keyword">new</span> ParkUnpark(<span class="hljs-number">5</span>);<br><br>        a = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;a&quot;</span>, b);<br>        &#125;, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        b = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;b&quot;</span>, c);<br>        &#125;, <span class="hljs-string">&quot;b&quot;</span>);<br><br>        c = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            parkUnpark.print(<span class="hljs-string">&quot;c&quot;</span>, a);<br>        &#125;, <span class="hljs-string">&quot;c&quot;</span>);<br><br>        a.start();<br>        b.start();<br>        c.start();<br><br>        LockSupport.unpark(a);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkUnpark</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> loopNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParkUnpark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String str, Thread nextThread)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(nextThread);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p><img src="https://img-blog.csdnimg.cn/20201223172500153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/20201223172527523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JUC/">JUC</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JUC/">JUC</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%AF%87-JMM-CAS%E5%8E%9F%E7%90%86-Volatile%E5%8E%9F%E7%90%86/">
                        <span class="hidden-mobile">Java并发编程中篇 - (JMM,CAS原理,Volatile原理)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.lazyComments('valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "99lfyqRg3CLazXoohVQjMwH3-gzGzoHsz",
          app_key: "qx9rFQuqjhuegpH6AwJ8B0eD",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
