

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/newcon.png">
  <link rel="icon" href="/img/newfav.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>Java并发编程上篇 - (JMM,CAS原理,Volatile原理) - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":64,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Le Onde</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                种类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://img-blog.csdnimg.cn/20210421122657715.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzYxMzEwNQ==,size_16,color_FFFFFF,t_70') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java并发编程上篇 - (JMM,CAS原理,Volatile原理)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-01 14:40" pubdate>
        November 1, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      213
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java并发编程上篇 - (JMM,CAS原理,Volatile原理)</h1>
            
            <div class="markdown-body">
              <h2 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h2><h3 id="1-Java内存模型（重点）"><a href="#1-Java内存模型（重点）" class="headerlink" title="1.Java内存模型（重点）"></a>1.Java内存模型（重点）</h3><ul>
<li>JMM即 <code>Java Memory Model</code>，它从Java层面定义了主存、工作内存 抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等。JMM体现在以下几个方面<ul>
<li>原子性 - 保证指令不会受<strong>线程上下文切换的影响</strong></li>
<li>可见性 - 保证指令不会受<strong>cpu缓存的影响</strong>（JIT对热点代码的缓存优化）</li>
<li>有序性 - 保证指令不会受<strong>cpu指令并行优化的影响</strong></li>
</ul>
</li>
</ul>
<h4 id="1-可见性（重点）"><a href="#1-可见性（重点）" class="headerlink" title="1.可见性（重点）"></a>1.可见性（重点）</h4><h5 id="1-1退不出的循环"><a href="#1-1退不出的循环" class="headerlink" title="1.1退不出的循环"></a>1.1退不出的循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(run) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;t1 Stop&quot;</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>为什么会出现对run变量的不可见性呢呢？分析一下</strong></p>
<ul>
<li>初始状态，t线程刚开始从主内存中读取值，因为主线程sleep1秒，这时候t线程循环了好多次run的值，超过了一定的阈值，JIT就会将主存中的run值读取到工作内存（相当于缓存了一份，不会从主存中读run的值了）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/55a9700c011a4188ffdb8993f88ded28.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>因为t线程频繁从主存中读取run值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中的run的访问以提高效率</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e81d86ac7eea71c6f94dab875af787c7.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>1秒之后，main线程修改了run的值，并同步至内存。而t线程是从自己工作内存中的高速缓存中读取这个变量的值，<strong>结果永远是旧值</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/62f824bbb5595133018b992b326c7913.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="1-2解决方法"><a href="#1-2解决方法" class="headerlink" title="1.2解决方法"></a>1.2<strong>解决方法</strong></h5><ul>
<li>使用volatile（易变关键字）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">// 增加t1线程, 对主线程更改run变量的可见性</span><br>    <span class="hljs-comment">// 一开始一直不结束, 是因为无限循环, run都是true, JIT及时编译器, 会对t1线程所执行的</span><br>    <span class="hljs-comment">// run变量,进行缓存, 缓存到本地工作内存. 不去访问主存中的run. 这样可以提高性能; 也可以说是JVM打到一定阈值之后</span><br>    <span class="hljs-comment">// while(true)变成了一个热点代码, 所以一直访问的都是缓存到本地工作内存(局部)中的run. 当主线程修改主存中的run变量的时候,</span><br>    <span class="hljs-comment">// t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了. 所以一直运行. 我们为主存(成员变量)进行volatile修饰, 增加</span><br>    <span class="hljs-comment">// 变量的可见性, 当主线程修改run为false, t1线程对run的值可见. 这样就可以退出循环</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-comment">// 如果打印一句话</span><br>                <span class="hljs-comment">// 此时就可以结束, 因为println方法中, 使用到了synchronized</span><br>                <span class="hljs-comment">// synchronized可以保证原子性、可见性、有序性</span><br>                <span class="hljs-comment">// System.out.println(&quot;123&quot;);</span><br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        run = <span class="hljs-keyword">false</span>;<br>        System.out.println(run);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>synchronized</code>解决</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出</span><br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj) &#123;<br><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 当主线程获取到锁的时候, 就修改为false了</span><br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            run = <span class="hljs-keyword">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;false&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>使用<code>volatile</code>（表示易变关键字的意思），它可以用来修饰<code>成员变量</code>和<code>静态成员变量</code>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</li>
<li>volatile 可以认为是一个轻量级的锁，被 volatile 修饰的变量，汇编指令会存在于一个”lock”的前缀。在CPU层面与主内存层面，通过缓存一致性协议，<strong>加锁后能够保证写的值同步到主内存，使其他线程能够获得最新的值。</strong></li>
<li>使用<code>synchronized关键字</code>也有相同的效果, 在<code>Java内存模型</code>中，synchronized规定，线程在加锁时， <code>先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。</code></li>
</ul>
<h5 id="1-3-可见性-vs-原子性"><a href="#1-3-可见性-vs-原子性" class="headerlink" title="1.3 可见性 vs 原子性"></a>1.3 可见性 vs 原子性</h5><ul>
<li>前面例子体现的实际就是<code>可见性</code>，<strong>它保证的是在多个线程之间一个线程对volatile变量的修改对另一个线程可见，而不能保证原子性。</strong>volatile用在一个写线程，多个读线程的情况，比较合适。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run true</span><br>putstatic run <span class="hljs-comment">// 线程 main 修改 run 为 false， 仅此一次</span><br>getstatic run <span class="hljs-comment">// 线程 t 获取 run false </span><br></code></pre></td></tr></table></figure>

<ul>
<li>比较一下之前我们讲线程安全时举的例子：<strong>两个线程一个 i++ 一个 i– ，只能保证看到最新值(可见性)，不能解决指令交错(原子性)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br>getstatic i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br>iconst_1 <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd <span class="hljs-comment">// 线程1-自增 线程内i=1</span><br>putstatic i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br>iconst_1 <span class="hljs-comment">// 线程2-准备常量1</span><br>isub <span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br>putstatic i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1 </span><br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">注意：：synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。<span class="hljs-strong">**但缺点是 synchronized 是属于重量级操作，性能相对更低。**</span>  如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，因为println方法里面有synchronized修饰。还有那个等烟的示例, 为啥没有出现可见性问题?和synchrozized是一个道理。<br></code></pre></td></tr></table></figure>

<h5 id="1-4模式之两阶段终止"><a href="#1-4模式之两阶段终止" class="headerlink" title="1.4模式之两阶段终止"></a>1.4模式之两阶段终止</h5><ul>
<li>当我们在执行线程一时，想要终止线程二、这就是需要使用interrupt方法来优雅的停止线程二。这是我们之前的做法</li>
<li>使用volatile关键字来实现两阶段终止模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_02_Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>		Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>		monitor.start();<br>		Thread.sleep(<span class="hljs-number">3500</span>);<br>		monitor.stop();<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>	Thread monitor;<br>	<span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 启动监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>		monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				<span class="hljs-comment">// 开始不停的监控</span><br>				<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>					<span class="hljs-keyword">if</span>(stop) &#123;<br>						System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>						<span class="hljs-keyword">break</span>;<br>					&#125;<br>					System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 线程休眠</span><br>						Thread.sleep(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;;<br>		monitor.start();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 	用于停止监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 修改标记</span><br>		stop = <span class="hljs-keyword">true</span>;<br>		<span class="hljs-comment">// 打断线程</span><br>		monitor.interrupt();        <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="1-5模式之Balking（了解）"><a href="#1-5模式之Balking（了解）" class="headerlink" title="1.5模式之Balking（了解）"></a>1.5模式之Balking（了解）</h5><ul>
<li>定义： <code>balking（犹豫）模式</code>用在<code>一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</code> 有点类似于单例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>        monitor.start();<br>        monitor.start();<br>        monitor.start();<br>        Sleeper.sleep(<span class="hljs-number">3.5</span>);<br>        monitor.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Monitor&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;<br><br>    Thread monitor;<br>    <span class="hljs-comment">//设置标记，用于判断是否被终止了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-comment">//已被启动，直接返回</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//启动监视器，改变标记</span><br>            starting = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>        monitor = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">//开始不停的监控</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span>(stop) &#123;<br>                    log.debug(<span class="hljs-string">&quot;处理后续儿事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//线程休眠</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;被打断了...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        monitor.start();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 	用于停止监控器线程</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//打断线程</span><br>        stop = <span class="hljs-keyword">true</span>;<br>        monitor.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-有序性（重点）"><a href="#2-有序性（重点）" class="headerlink" title="2.有序性（重点）"></a>2.有序性（重点）</h3><p>是JIT即时编译器的优化，可能会导致指令重排。为什么要优化？因为CPU支持多级指令流水线，例如支持同时执行<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code> 的处理器。效率快</p>
<ul>
<li>JVM会在不影响正确性的前提下，可以调整语句的执行顺序，是一种优化</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201224225308100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>这种特性称为 <code>指令重排</code>，多线程下指令重排会影响正确性</li>
</ul>
<h4 id="1-多线程下指令重排问题"><a href="#1-多线程下指令重排问题" class="headerlink" title="1.多线程下指令重排问题"></a>1.多线程下指令重排问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>; <br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <br> <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程1执行actor1方法，线程2执行actor2方法</p>
<ul>
<li>I_Result是一个对象，有一个属性r1用来保存结果，可能有哪几种结果？<ul>
<li>情况1，线程1先执行，这时ready = false，所以进入else分支结果为1</li>
<li>情况2，线程2先执行num = 2，但没来得及执行ready = true，线程1执行，进入else分支，结果为1</li>
<li>情况3，线程2执行到ready = true，线程1执行，这回进入if分支，结果为4（因为num已经执行过了）</li>
<li>情况4，线程2先执行ready = true，切换到线程1，进入if分支，相加为0，再切回线程2执行num = 2，结果为0</li>
</ul>
</li>
<li>情况4的现象为指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用<code>jcstress工具</code>进行测试。上面仅是从代码层面体现出了<code>有序性</code>问题，下面在讲到 <code>double-checked locking (双重检查锁)</code>问题时还会从java字节码的层面了解有序性的问题。</li>
</ul>
<h5 id="1-2指令重排也需要遵守一定规则："><a href="#1-2指令重排也需要遵守一定规则：" class="headerlink" title="1.2指令重排也需要遵守一定规则："></a>1.2指令重排也需要遵守一定规则：</h5><ul>
<li>指令重排序规则不会对存在数据依赖关系的操作进行重排序。比如：a = 1；b = a；这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</li>
<li>重排序是为了优化性能，但是不管怎么重排序，<strong>单线程下程序的执行结果不能被改变</strong> 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</li>
</ul>
<p><strong>指令重排序 在单线程模式下是一定会保证最终结果的正确性</strong>，但是在多线程环境下，问题就出来了</p>
<h5 id="1-3解决方法"><a href="#1-3解决方法" class="headerlink" title="1.3解决方法"></a>1.3解决方法</h5><p>用volatile修饰的变量，可以禁用指令重排</p>
<p>注意：</p>
<ul>
<li>使用<code>synchronized并不能解决有序性</code>问题，<strong>但是如果是该变量整个都在synchronized代码块的保护范围内</strong>，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！</li>
</ul>
<h4 id="2-volatile-原理-重点"><a href="#2-volatile-原理-重点" class="headerlink" title="2.volatile 原理(重点)"></a>2.volatile 原理(重点)</h4><ul>
<li>volatile的底层实现原理是内存屏障。Memory Barrier（Memory Fence）<ul>
<li>对volatile变量的<strong>写指令后</strong>会加入<strong>写屏障</strong>。（保证写屏障之前的写操作, 都能同步到主存中）</li>
<li>对volatile变量的<strong>读指令前</strong>会加入<strong>读屏障</strong>。(保证读屏障之后的读操作, 都能读到主存的数据)</li>
</ul>
</li>
</ul>
<h5 id="2-1volatile是如何保证可见性的（重点）"><a href="#2-1volatile是如何保证可见性的（重点）" class="headerlink" title="2.1volatile是如何保证可见性的（重点）"></a>2.1volatile是如何保证可见性的（重点）</h5><ul>
<li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存之中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// ready是被volatile修饰的 ，赋值带写屏障</span><br>     <span class="hljs-comment">// 写屏障.(在ready=true写指令之后加的, </span><br>     <span class="hljs-comment">//在该屏障之前对共享变量的改动, 都同步到主存中. 包括num)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>	 <span class="hljs-comment">// 读屏障</span><br>	 <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span><br>	 <span class="hljs-keyword">if</span>(ready) &#123;	<span class="hljs-comment">// ready, 读取的就是主存中的新值</span><br>	 	r.r1 = num + num; <span class="hljs-comment">// num, 读取的也是主存中的新值</span><br>	 &#125; <span class="hljs-keyword">else</span> &#123;<br>	 	r.r1 = <span class="hljs-number">1</span>;<br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/b17feb2d8cc0907ddee8b08949a44d0d.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-2volatile是如何保证有序性（重点）"><a href="#2-2volatile是如何保证有序性（重点）" class="headerlink" title="2.2volatile是如何保证有序性（重点）"></a>2.2volatile是如何保证有序性（重点）</h5><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//  ready是被volatile修饰的 ， 赋值带写屏障</span><br> <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>读屏障会保证指令重排序时，不会将读屏障之后的代码排在读排序之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>	 <span class="hljs-comment">// 读屏障</span><br>	 <span class="hljs-comment">//  ready是被volatile修饰的 ，读取值带读屏障</span><br>	 <span class="hljs-keyword">if</span>(ready) &#123;<br>	 	r.r1 = num + num;<br>	 &#125; <span class="hljs-keyword">else</span> &#123;<br>	 	r.r1 = <span class="hljs-number">1</span>;<br>	 &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/98518f6441a448a9a6ef441ef2518c83.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>volatile不能解决指令交错（不能解决原子性）</strong></p>
<ul>
<li>写屏障仅仅是保障之后的读能够读到最新结果，但不能保证其它线程的读，跑到它前面去</li>
<li><strong>而有序性的保证也只是保证了本线程内相关代码不被重排序</strong></li>
</ul>
<p>下图t2线程, 就先读取了i=0, 此时还是会出现指令交错的现象, 可以使用<code>synchronized</code>来解决原子性</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e8fff6923548db93e27ac4a947633e9.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-3-double-checked-locking-（双重检验锁）问题（重点）"><a href="#2-3-double-checked-locking-（双重检验锁）问题（重点）" class="headerlink" title="2.3 double-checked locking （双重检验锁）问题（重点）"></a>2.3 double-checked locking （双重检验锁）问题（重点）</h5><p>首先synchronized可以保证它的临界区的资源是 <code>原子性、可见性、有序性</code>的, 有序性的前提是，在synchronized代码块中的共享变量，不会在代码块外使用到，否则有序性不能被保证，只能使用volatile来保证有序性。</p>
<ul>
<li><p><strong>下面代码的第二个双重检查单例, 就出现了这个问题(在synchronized外使用到了INSTANCE), 此时synchronized就不能防止指令重排, 确保不了指令的有序性.</strong></p>
</li>
<li><p>以著名的<code>double-checked locking(双重检查锁) 单例模式</code>为例，这是volatile最常使用的地方。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 最开始的单例模式是这样的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>	    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	      多线程同时调用getInstance(), 如果不加synchronized锁, 此时两个线程同时</span><br><span class="hljs-comment">	      判断INSTANCE为空, 此时都会new Singleton(), 此时就破坏单例了.所以要加锁,</span><br><span class="hljs-comment">	      防止多线程操作共享资源,造成的安全问题</span><br><span class="hljs-comment">	     */</span><br>	    <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>	    	<span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>	    		INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>	        &#125;<br>	    &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	首先上面代码的效率是有问题的, 因为当我们创建了一个单例对象后, 又来一个线程获取到锁了,还是会加锁, </span><br><span class="hljs-comment">	严重影响性能,再次判断INSTANCE==null吗, 此时肯定不为null, 然后就返回刚才创建的INSTANCE;</span><br><span class="hljs-comment">	这样导致了很多不必要的判断; </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	所以要双重检查, 在第一次线程调用getInstance(), 直接在synchronized外,判断instance对象是否存在了,</span><br><span class="hljs-comment">	如果不存在, 才会去获取锁,然后创建单例对象,并返回; 第二个线程调用getInstance(), 会进行</span><br><span class="hljs-comment">	if(instance==null)的判断, 如果已经有单例对象, 此时就不会再去同步块中获取锁了. 提高效率</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//但是上面的if(INSTANCE == null)判断代码没有在同步代码块synchronized中，</span><br><span class="hljs-comment">// 不能享有synchronized保证的原子性、可见性、以及有序性。所以可能会导致 指令重排</span><br></code></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p>懒惰实例化</p>
</li>
<li><p>首次使用getInstance() 才使用 synchronized 加锁，<strong>后续使用时无需加锁 (也就是上面的第二个单例)</strong></p>
</li>
<li><p>有隐含的: 但很关键的一点：<code>第一个 if 使用了 INSTANCE 变量，是在同步块之外</code>, 这样会导致<code>synchronized</code>无法保证指令的<code>有序性</code>, 此时可能会导致<code>指令重排</code>问题</p>
</li>
</ul>
<p>注意: 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span> <span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-comment">// ldc是获得类对象</span><br>6: ldc #3 // class cn/itcast/n5/Singleton<br><span class="hljs-comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span><br><span class="hljs-comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span><br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter<br>11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-comment">// 新建一个实例</span><br>17: new #3 // class cn/itcast/n5/Singleton<br><span class="hljs-comment">// 复制了一个实例的引用</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-comment">// 通过这个复制的引用调用它的构造方法</span><br>21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V<br><span class="hljs-comment">// 最开始的这个引用用来进行赋值操作</span><br>24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br>37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure>

<p><strong>其中</strong></p>
<ul>
<li>17 表示创建对象，将对象引用入栈 // new Singleton</li>
</ul>
<ul>
<li>20 表示复制一份对象引用 // 复制了引用地址, 解锁使用</li>
<li>21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>可能jvm 会优化为：<code>先执行 24(赋值)，再执行 21(构造方法)</code>。如果两个线程 t1，t2 按如下时间序列执行：</p>
<ul>
<li>通过上面的字节码发现, 这一步<code>INSTANCE = new Singleton();</code>操作不是一个<code>原子操作</code>, 它分为<code>21, 24两个指令</code>, 此时可能就会发生<code>指令重排</code>的问题</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/702a41b984561f85cab618621b824079.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>关键在于 <code>0: getstatic</code> 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值</li>
<li>这时 <code>t1 还未完全将构造方法</code>执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 <strong>对 INSTANCE 使用 volatile 修饰</strong>即可，可以<code>禁用指令重排。</code></li>
<li>注意在 JDK 5 以上的版本的 volatile 才会真正有效</li>
</ul>
<h5 id="2-4-double-checked-locking关于指令重排的解决"><a href="#2-4-double-checked-locking关于指令重排的解决" class="headerlink" title="2.4 double-checked locking关于指令重排的解决"></a>2.4 double-checked locking关于指令重排的解决</h5><ul>
<li>加volatile</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>字节码上看不出来volatile指令的效果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br>0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br>6: ldc #3 // class cn/itcast/n5/Singleton<br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br>11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br>17: new #3 // class cn/itcast/n5/Singleton<br><span class="hljs-number">20</span>: dup<br>21: invokespecial #4 // Method &quot;&lt;init&gt;&quot;:()V<br>24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br>37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;<br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure>

<ul>
<li>如上面所注释的内容，读写volatile变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier）保证下面两点：<ol>
<li>可见性<ol>
<li>写屏障（sfence）保证该屏障之前的t1对共享变量的改动，都同步到主存中</li>
<li>读屏障（lfence）保证该屏障之后的t2对共享变量的读取，加载的是主存中最新数据</li>
</ol>
</li>
<li>有序性<ol>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会保证指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ol>
</li>
<li><strong>更底层是读写变量时使用lock指令来多核cpu之间的可见性与有序性</strong></li>
</ol>
</li>
</ul>
<p>加上volatile之后，保证了指令的有序性，不会发生指令重排，21就不会跑到24之后执行了</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dd32cd4090a29b5dbd4c6a0bd8945187.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>小结</strong></p>
<ul>
<li>synchronized即能保证<strong>原子性、有序性、可见性</strong>，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作）。上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</li>
<li>对共享变量加<code>volatile</code>关键字可以保证<code>可见性</code>和<code>有序性</code>，但是<strong>不能保证原子性</strong>（即不能防止指令交错）。</li>
</ul>
<h4 id="3-happens-before-对共享变量的写操作-对其它线程的读操作可见"><a href="#3-happens-before-对共享变量的写操作-对其它线程的读操作可见" class="headerlink" title="3.happens-before (对共享变量的写操作,对其它线程的读操作可见)"></a>3.happens-before (<code>对共享变量的写操作,对其它线程的读操作可见</code>)</h4><p>下面说的变量都是指成员变量或静态成员变量</p>
<ol>
<li>线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对改变量的读可见<ul>
<li>synchronized锁，保证了可见性</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>	<br>	<span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object();<br>	<br>	<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>	    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>	        x = <span class="hljs-number">10</span>;<br>	    &#125;<br>	&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>	<br>	<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>	    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>	        System.out.println(x);<br>	    &#125;<br>	&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>线程对volatile变量的写，对接下来其他线程对该变量的读可见<ul>
<li>volatile修饰的变量，通过写屏障，共享到主存中，其他线程通过读屏障，读取主存的数据</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> 	x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> 	System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>线程start前对变量的写，对该线程开始后对该变量的读可见</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br> x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>               <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                   System.out.println(x);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>       t2.start();<br>       <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>           sleep(<span class="hljs-number">1</span>);<br>           x = <span class="hljs-number">10</span>;<br>           t2.interrupt();<br>       &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>       <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>           Thread.yield();<br>       &#125;<br>       System.out.println(x);<br>   &#125;<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>​<ul>
<li>对<code>变量默认值（0，false，null）的写</code>，对其它线程对该变量的 读可见 (最基本)</li>
<li><code>具有传递性</code>，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，<strong>配合 volatile 的防指令重排，有下面的例子</strong></li>
<li>因为<code>x加了volatile</code>, 所以在volatile static int x 代码的上面添加了<code>读屏障</code>, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都OK); 通过传递性, t2线程对x,y的写操作, 都是可见的</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y;  <br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>	y = <span class="hljs-number">10</span>;  <br>	x = <span class="hljs-number">20</span>;  <br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();  <br>	<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;  <br>	<span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见  </span><br>	System.out.println(x);  <br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start(); <br></code></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><code>volatile</code>主要用在<code>一个线程改,多个线程读时的来保证可见性</code>，和<code>double-checked locking模式中保证synchronized代码块外的共享变量的</code>指令重排序<code>问题</code></li>
</ul>
<h3 id="3-习题"><a href="#3-习题" class="headerlink" title="3.习题"></a>3.习题</h3><h4 id="1-balking练习题"><a href="#1-balking练习题" class="headerlink" title="1.balking练习题"></a>1.balking练习题</h4><ul>
<li>希望doInit()方法仅被调用一次下面的实现是否有问题，为什么？</li>
<li>有问题: volatile无法保证原子性; 当多个线程同时调用init()方法时, 此时都进入到if判断, 因为都为false, 所以都调用<code>doInit()</code>方法, 此时就调用了多次<ul>
<li>解决方法: 对init()方法的方法体, 通过<code>synchronized</code>加锁, 防止多个线程访问共享资源导致的安全问题</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestVolatile</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialized) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        doInit();<br>        initialized = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>修改后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.BigRoomTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoomTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> initialized = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            init();<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            init();<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">if</span> (initialized) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            doInit();<br>            initialized = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInit</span><span class="hljs-params">()</span> </span>&#123;<br>        log.debug(<span class="hljs-string">&quot;init...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-线程安全单例模式（重点）"><a href="#2-线程安全单例模式（重点）" class="headerlink" title="2.线程安全单例模式（重点）"></a>2.线程安全单例模式（重点）</h4><ul>
<li>单例模式有很多实现方法，<code>饿汉、懒汉、静态内部类、枚举类</code>，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题<ul>
<li><code>饿汉式</code>：<strong>类加载就会导致该单实例对象被创建</strong></li>
<li><code>懒汉式</code>：<strong>类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</strong></li>
</ul>
</li>
</ul>
<p>实现1：饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：为什么加 final，防止子类继承后更改</span><br><span class="hljs-comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// 问题3：为什么设置为私有? 放弃其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能。</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。</span><br>    <span class="hljs-comment">//1.提供更好的封装性；2.提供范型的支持</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>问题1 : 加final为了防止有子类, 因为子类可以重写父类的方法</li>
<li>问题2 : 首先通过反序列化操作, 也是可以创建一个对象的, 破坏了单例, 可以使用readResolve方法并返回instance对象, 当反序列化的时候就会调用自己写的readResolve方法</li>
<li>问题3 : 私有化构造器, 防止外部通过构造器来创建对象; 但不能防止反射来创建对象</li>
<li>问题4 : 因为单例对象是static的, 静态成员变量的初始化操作是在类加载阶段完成, 由JVM保证其线程安全 (这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。)</li>
<li>问题5 : 通过向外提供公共方法, 体现了更好的封装性, 可以在方法内实现懒加载的单例; 可以提供泛型等</li>
</ul>
<p>补充 : 任何一个readObject方法，不管是显式的还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。</p>
<p>实现2：饿汉式: 因为枚举的变量, 底层是通过public static final来修饰的, 类加载就创建了,所以是饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量</span><br><span class="hljs-comment">// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量</span><br><span class="hljs-comment">// 问题3：枚举单例能否被反射破坏单例：不能</span><br><span class="hljs-comment">// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例</span><br><span class="hljs-comment">// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式</span><br><span class="hljs-comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 问题1 : 枚举类中, 只有一个INSTANCE, 就确保了它是单例的<br><span class="hljs-bullet">-</span> 问题2 : 没有并发问题, 是线程安全的, 因为枚举单例底层是一个静态成员变量, 它是通过类加载器的加载而创建的, 确保了线程安全<br><span class="hljs-bullet">-</span> 问题3 : 反射无法破坏枚举单例, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。<br><span class="hljs-bullet">  -</span> if ((this.clazz.getModifiers() &amp; 16384) != 0)<br><span class="hljs-code">    throw new IllegalArgumentException(“Cannot       reflectively create enum objects”);</span><br><span class="hljs-code">- 问题4 : 反序列化不能破坏, 枚举类默认也实习了序列号接口. 但枚举类考虑到了这个问题, 不会破坏单例. 通过反序列化得到的并不是同一个单例对象; 除此之外, 还可以写上readResolve方法,</span><br><span class="hljs-code">- 问题 5 : 属于饿汉式, 静态成员变量, 通过类加载器的时候就加载了。</span><br><span class="hljs-code">- 问题 6 : 加构造方法</span><br></code></pre></td></tr></table></figure>

<p>实现3：懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( INSTANCE != <span class="hljs-keyword">null</span> )&#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是一个懒汉式的单例, 代码存在性能问题: 当单例对象已经创建好了, 多个线程访问<code>getInstance()</code>方法, 仍然会获取锁, 同步操作, 性能很低, 此时出现<code>重复判断</code>, 因此要使用<code>双重检查</code></p>
<p>实现4：DCL 懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 问题1：解释为什么要加 volatile ?为了防止重排序问题</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 问题2：对比实现3, 说出这样做的意义：提高了效率</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。</span><br>            <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-keyword">return</span> INSTANCE;<br>            &#125;<br>            INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>问题1 : 因为在synchronized外部使用到了共享变量INSTANCE, 所以synchronized无法保证instance的有序性, 又因为instance = new Singleton()不是一个原子操作, 可分为多个指令. 此时通过指令重排, 可能会造成INSTANCE还未初始化, 就赋值的现象, 所以要给共享变量INSTANCE加上volatile,禁止指令重排</li>
<li>问题2 : 增加了双重判断, 如果存在了单例对象, 别的线程再进来就无需加锁判断, 大大提高性能</li>
<li>问题3 : 防止多线程并发导致不安全的问题:防止单例对象被重复创建. 当t1,t2线程都调用getInstance()方法, 它们都判断单例对象为空, 还没有创建;<ul>
<li>此时t1先获取到锁对象, 进入到synchronized中, 此时创建对象, 返回单例对象, 释放锁;</li>
<li>这时候t2获得了锁对象, 如果在代码块中没有if判断, 则线程2认为没有单例对象, 因为在代码块外判断的时候就没有, 所以t2就还是会创建单例对象. 此时就重复创建了</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章重点讲解了 JMM 中的</p>
<ul>
<li>可见性 - 由 JVM 缓存优化引起; <code>(JIT即时编译器, 通过对热点代码的优化)</code></li>
<li>有序性 - 由 JVM <code>指令重排序优化</code>引起; <code>(提高指令的执行效率, 类似流水线系统)</code></li>
</ul>
<ul>
<li>happens-before 规则; <code>(happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结。)</code></li>
</ul>
<p>原理方面</p>
<ul>
<li>volatile (读写屏障)</li>
</ul>
<p>模式方面</p>
<ul>
<li>两阶段终止模式的 volatile 改进</li>
<li>同步模式之 balking (犹豫模式)</li>
</ul>
<h2 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h2><ul>
<li>Java中 <strong>synchronized</strong> 和 <strong>ReentrantLock</strong> 等 独占锁 就是 <strong>悲观锁</strong> 思想的实现</li>
</ul>
<ul>
<li>在Java中<strong>java.util.concurrent.atomic包下面的原子变量类</strong>就是使用了<code>乐观锁</code>的一种实现方式 <strong>CAS</strong> 实现的</li>
</ul>
<ul>
<li>管程即<code>monitor</code>是<code>阻塞式的悲观锁</code>实现<code>并发控制</code>，这章我们将通过<code>非阻塞式的乐观锁</code>的来实现<code>并发控制</code></li>
</ul>
<h3 id="1-问题提出"><a href="#1-问题提出" class="headerlink" title="1.问题提出"></a>1.问题提出</h3><ul>
<li>有如下需求，保证<code>account.withdraw取款方法</code>的线程安全, 下面使用<code>synchronized</code>保证线程安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 使用重量级锁synchronized来保证多线程访问共享资源发生的安全问题</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/27 16:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));<br>        Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> balance;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>        <span class="hljs-comment">// 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            balance -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Java8之后接口新特性, 可以添加默认方法</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(<span class="hljs-number">10</span>);<br>            &#125;));<br>        &#125;<br>        ts.forEach(thread -&gt; thread.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(account.getBalance()<br>                + <span class="hljs-string">&quot; cost: &quot;</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-解决思路-无锁"><a href="#2-解决思路-无锁" class="headerlink" title="2.解决思路-无锁"></a>2.解决思路-无锁</h3><ul>
<li>上面的代码中使用<code>synchronized加锁</code>操作来<code>保证线程安全</code>，但是 **synchronized加锁操作太耗费资源 (因为底层使用了操作系统mutex指令, 造成内核态和用户态的切换)**，这里我们使用 <strong>无锁</strong> 来解决此问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<br>	<span class="hljs-comment">//使用原子整数: 底层使用CAS+重试的机制</span><br>	<span class="hljs-keyword">private</span> AtomicInteger balance;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//得到原子整数的值</span><br>		<span class="hljs-keyword">return</span> balance.get();<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>		<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>			<span class="hljs-comment">//获得修改前的值</span><br>			<span class="hljs-keyword">int</span> prev = balance.get();<br>			<span class="hljs-comment">//获得修改后的值</span><br>			<span class="hljs-keyword">int</span> next = prev - amount;<br>			<span class="hljs-comment">//比较并设置值</span><br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">				此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,</span><br><span class="hljs-comment">				就继续where(true),如果匹配上了, 将next值设置给共享变量.</span><br><span class="hljs-comment">				</span><br><span class="hljs-comment">				AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.</span><br><span class="hljs-comment">			*/</span><br>			<span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-CAS与volatile（重点）"><a href="#3-CAS与volatile（重点）" class="headerlink" title="3. CAS与volatile（重点）"></a>3. CAS与volatile（重点）</h3><p>使用原子操作来保证线程访问共享资源的安全性，cas + 重试的机制来确保（乐观锁思想），相对于悲观锁的思想的synchronized，reentrantLock来说，cas的方式效率会更好</p>
<h4 id="3-1cas-重试的原理"><a href="#3-1cas-重试的原理" class="headerlink" title="3.1cas + 重试的原理"></a>3.1cas + 重试的原理</h4><ul>
<li>前面看到的Atomic Integer的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<br>    <span class="hljs-comment">// 核心代码</span><br>    <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>        <span class="hljs-keyword">int</span> prev = balance.get();<br>        <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>        <span class="hljs-keyword">int</span> next = prev - amount;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         compareAndSet 保证操作共享变量安全性的操作:</span><br><span class="hljs-comment">         ① 线程A首先获取balance.get(),拿到当前的balance值prev</span><br><span class="hljs-comment">         ② 根据这个prev值 - amount值 = 修改后的值next</span><br><span class="hljs-comment">         ③ 调用compareAndSet方法, 首先会判断当初拿到的prev值,是否和现在的balance值相同;</span><br><span class="hljs-comment">         	3.1、如果相同,表示其他线程没有修改balance的值, 此时就可以将next值</span><br><span class="hljs-comment">         		设置给balance属性</span><br><span class="hljs-comment">         	3.2、如果不相同,表示其他线程也修改了balance值, 此时就设置next值失败, </span><br><span class="hljs-comment">				然后一直重试, 重新获取balance.get()的值,计算出next值,</span><br><span class="hljs-comment">				并判断本次的prev和balnce的值是否相同...重复上面操作</span><br><span class="hljs-comment">		*/</span><br>        <span class="hljs-keyword">if</span> (atomicInteger.compareAndSet(prev,next))&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中的关键是compareAndSwap（比较并设置值），它的简称就是CAS（也有Compare And Swap的说法），它必须是<code>原子操作</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/436a166f7e783537464879edf14ccc0c.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>流程</strong></p>
<ul>
<li>当一个线程要去修改<code>Account对象</code>中的值时，<code>先获取值prev(调用get方法)</code>，然后再将其设置为新的值<code>next</code>(调用cas方法)。在调用cas方法时，会将<code>prev</code>与<code>Account中的余额</code>进行比较<ul>
<li>如果两者相等，就说明该值还未被其他线程修改，此时便可以进行修改操作</li>
<li>如果不相等，就不设置值，重新获取值prev(调用get方法)；然后再将其设置为新的值next(调用cas方法)，直到修改成功为止</li>
</ul>
</li>
</ul>
<p><strong>注意 :</strong></p>
<ul>
<li>其实CAS底层是<strong>lock cmpxchg指令</strong>（X86架构），在单核CPU和多核CPU下都能够保证<code>[比较 - 交换]的原子性</code></li>
<li>在多核状态下，某个核执行到带lock的指令时，<strong>CPU会让总线锁住，当这个核把此指令执行完，在开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210202190842397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2volatile的作用"><a href="#3-2volatile的作用" class="headerlink" title="3.2volatile的作用"></a>3.2volatile的作用</h4><ul>
<li>在上面的代码中的AtomicInteger类，<strong>保存值的value属性使用了volatile修饰</strong>。获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</li>
<li>volatile可以用来修饰 <strong>成员变量和静态成员变量</strong>，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。<code>即一个线程对volatile变量的修改，对另一个线程可见</code></li>
</ul>
<p>注意：</p>
<p>volatile仅仅保证了共享变量的<strong>可见性</strong>，让其他线程能够看到最新值，但<strong>不能解决指令交错问题（不能保证原子性）</strong></p>
<ul>
<li>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</li>
</ul>
<h4 id="3-3为什么CAS-重试（无锁）效率高"><a href="#3-3为什么CAS-重试（无锁）效率高" class="headerlink" title="3.3为什么CAS+重试（无锁）效率高"></a>3.3为什么CAS+重试（无锁）效率高</h4><ul>
<li><strong>使用CAS+重试 — 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞</strong><ul>
<li>打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li>
</ul>
</li>
<li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li>
</ul>
<h4 id="3-4CAS的特点（乐观锁和悲观锁的特点）"><a href="#3-4CAS的特点（乐观锁和悲观锁的特点）" class="headerlink" title="3.4CAS的特点（乐观锁和悲观锁的特点）"></a>3.4CAS的特点（乐观锁和悲观锁的特点）</h4><p>结合CAS和volatile可以实现无锁并发，适用于线程数小、多核CPU的场景下</p>
<ul>
<li>CAS是基于乐观锁的思想：<strong>最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</strong></li>
<li>synchronized是基于悲观锁的思想：<strong>最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</strong></li>
<li>CAS体现的是无锁并发、无阻塞并发<ul>
<li>因为没有使用synchronized，所以线程不会陷入阻塞，这时效率提升的因素之一</li>
<li>但如果竞争激烈（写操作多），可以想到重试必然频繁发生，<strong>反而效率会受影响</strong></li>
</ul>
</li>
</ul>
<p>###4.原子整数（内部通过CAS来实现-AtomicInteger）</p>
<ul>
<li>java.util.concurrent.atomic并发包提供了一些并发工具类，这里把它分成5类：</li>
<li>使用原子的方式（<strong>共享数据为基本数据类型原子类</strong>）<ul>
<li>AtomicInteger：整型原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔原子类</li>
</ul>
</li>
<li>上面三个类提供的方法几乎相同，所以我们将以AtomicInteger为例子来介绍。先讨论原子整数类，以AtomicInteger为例讨论它的api接口：通过观察源码可以发现</li>
<li><strong>AtomicInteger内部都是通过cas的原理来实现的</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>举个例子：updateAndGet的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>	AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">5</span>);<br>	<br>    updateAndGet(i, <span class="hljs-keyword">new</span> IntUnaryOperator() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">applyAsInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operand)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> operand / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;);<br>    System.out.println(i.get()); <span class="hljs-comment">// 2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> prev = i.get(); <span class="hljs-comment">// 5</span><br>        <span class="hljs-keyword">int</span> next = operator.applyAsInt(prev);<br>        <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>步骤：</p>
<ul>
<li>调用updateAndGet方法，将共享变量i，IntUnaryOperator传递过去</li>
<li>updateAndGet方法内部，传过来的operator对象，调用IntUnaryOperator中的applyAsInt方法，实际调用的就是传递过来的对象的方法，进行/操作</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201227190220505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-原子引用（AtomicReference）"><a href="#5-原子引用（AtomicReference）" class="headerlink" title="5.原子引用（AtomicReference）"></a>5.原子引用（AtomicReference）</h3><p>原子引用的作用：保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）</p>
<ul>
<li>为什么需要原子引用类型？（引用数据类型原子类）<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference（可以解决ABA问题）</li>
</ul>
</li>
</ul>
<p>为什么需要<code>原子引用类型</code>？<strong>保证引用类型的共享变量是线程安全的（确保这个原子引用没有引用过别人）。</strong></p>
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。 </p>
<ul>
<li><strong>AtomicReference</strong>：引用类型原子类</li>
<li><strong>AtomicStampedReference</strong>：原子更新带有<code>版本号</code>的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，<strong>可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</strong></li>
<li><strong>AtomicMarkableReference</strong> ：原子更新带有<code>标记</code>的引用类型。该类将 boolean 标记与引用关联起来</li>
</ul>
<p>例子：使用原子引用实现BigDecimal存取款的线程安全：</p>
<p>下面这个是不安全的实现过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    BigDecimal balance;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountUnsafe</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        BigDecimal balance = <span class="hljs-keyword">this</span>.getBalance();<br>        <span class="hljs-keyword">this</span>.balance = balance.subtract(amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决代码如下：在<code>AtomicReference类</code>中，存在一个value类型的变量，保存对BigDecimal对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountCas(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br><br>    <span class="hljs-comment">//原子引用，泛型类型为小数类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            BigDecimal prev = balance.get();<br>            BigDecimal next = prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<br>    <span class="hljs-comment">// 获取余额</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccount account)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ABA-问题及解决-重点"><a href="#ABA-问题及解决-重点" class="headerlink" title="ABA 问题及解决 (重点)"></a>ABA 问题及解决 (<code>重点</code>)</h4><ul>
<li>如下程序所示，虽然 <strong>在other方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值</strong>，<strong>main线程对修改过共享变量的过程是不可见的，这种操作这对业务代码并无影响。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.get();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            Sleeper.sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//把ref中的A改为C</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        	<span class="hljs-comment">// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS</span><br>        	<span class="hljs-comment">// 可以修改成功, B</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        	<span class="hljs-comment">// 同上, 修改为A</span><br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201227200916774.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>主线程仅能判断出<code>共享变量的值</code>与<code>最初值 A</code>是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：<strong>只要有其它线程【动过】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。</strong></li>
</ul>
<h4 id="AtomicStampedReference-加版本号解决ABA问题"><a href="#AtomicStampedReference-加版本号解决ABA问题" class="headerlink" title="AtomicStampedReference (加版本号解决ABA问题)"></a>AtomicStampedReference (加版本号解决ABA问题)</h4><ul>
<li>解决ABA问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.getReference();<br>            <span class="hljs-comment">//获得版本号</span><br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp(); <span class="hljs-comment">// 此时的版本号还是第一次获取的</span><br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把ref中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">int</span> stamp = ref.getStamp();<br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201227201334161.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="AtomicMarkableReference-标记cas的共享变量是否被修改过"><a href="#AtomicMarkableReference-标记cas的共享变量是否被修改过" class="headerlink" title="AtomicMarkableReference (标记cas的共享变量是否被修改过)"></a>AtomicMarkableReference (标记cas的共享变量是否被修改过)</h4><ul>
<li><code>AtomicStampedReference</code> 可以给<code>原子引用</code>加上<code>版本号</code>，<strong>追踪原子引用整个的变化过程</strong>，如：A -&gt; B -&gt; A -&gt;C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</li>
</ul>
<ul>
<li>但是有时候，<code>并不关心引用变量更改了几次，只是单纯的关心是否更改过</code>，所以就有了<code>AtomicMarkableReference</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/23026a8d2e27e7a4f474d15f0e3684bc.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.TestABAAtomicMarkableReference&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestABAAtomicMarkableReference</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        GarbageBag bag = <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br>        <br>        <span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(bag, <span class="hljs-keyword">true</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程 start...&quot;</span>);<br>        <br>        GarbageBag prev = ref.getReference();<br>        log.debug(prev.toString());<br>        <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;打扫卫生的线程 start...&quot;</span>);<br>            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!ref.compareAndSet(bag, bag, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>)) &#123;<br>            &#125;<br>            log.debug(bag.toString());<br>        &#125;).start();<br>        <br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        log.debug(<span class="hljs-string">&quot;主线程想换一只新垃圾袋？&quot;</span>);<br>        <br>        <span class="hljs-keyword">boolean</span> success = ref.compareAndSet(prev, <span class="hljs-keyword">new</span> GarbageBag(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>        log.debug(ref.getReference().toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GarbageBag</span> </span>&#123;<br>    String desc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GarbageBag</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.062</span> guizy.TestABAAtomicMarkableReference [main] - 主线程 start...<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.069</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 装满了垃圾<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.312</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="hljs-number">0</span>] - 打扫卫生的线程 start...<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">24.313</span> guizy.TestABAAtomicMarkableReference [Thread-<span class="hljs-number">0</span>] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.313</span> guizy.TestABAAtomicMarkableReference [main] - 主线程想换一只新垃圾袋？<br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - 换了么？<span class="hljs-keyword">false</span><br><span class="hljs-number">23</span>:<span class="hljs-number">00</span>:<span class="hljs-number">25.314</span> guizy.TestABAAtomicMarkableReference [main] - com.guizy.cas.GarbageBag@2be94b0f 空垃圾袋<br></code></pre></td></tr></table></figure>

<p><strong>举例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-comment">//指定版本号</span><br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            String pre = ref.getReference();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> + ref.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201227201642314.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="AtomicStampedReference和AtomicMarkableReference两者的区别"><a href="#AtomicStampedReference和AtomicMarkableReference两者的区别" class="headerlink" title="AtomicStampedReference和AtomicMarkableReference两者的区别"></a>AtomicStampedReference和AtomicMarkableReference两者的区别</h4><ul>
<li><strong>AtomicStampedReference</strong>需要我们传入<strong>整型变量</strong>作为版本号，来判断是否被更改过</li>
<li><strong>AtomicMarkableReference</strong>需要我们传入布尔变量作为<code>标记</code>，来判断是否更改过</li>
</ul>
<h3 id="6-原子数组"><a href="#6-原子数组" class="headerlink" title="6.原子数组"></a>6.原子数组</h3><ul>
<li>保证数组内的元素的线程安全</li>
<li>使用原子的方式更新数组里的某个元素<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicArrayTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>],<br>                array -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                array -&gt; System.out.println(Arrays.toString(array))<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     * 参数2，获取数组长度的方法</span><br><span class="hljs-comment">     * 参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     * 参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="hljs-function"><span class="hljs-params">                                 BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer)</span> </span>&#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        T array = arraySupplier.get();<br>        <span class="hljs-keyword">int</span> length = lengthFun.apply(array);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 创建10个线程, 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;); <span class="hljs-comment">// 等所有线程结束</span><br><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">9870</span>, <span class="hljs-number">9862</span>, <span class="hljs-number">9774</span>, <span class="hljs-number">9697</span>, <span class="hljs-number">9683</span>, <span class="hljs-number">9678</span>, <span class="hljs-number">9679</span>, <span class="hljs-number">9668</span>, <span class="hljs-number">9680</span>, <span class="hljs-number">9698</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>AtomicIntegerArray</code>来创建安全数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>        ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>        (array) -&gt; array.length(),<br>        (array, index) -&gt; array.getAndIncrement(index),<br>        array -&gt; System.out.println(array)<br>);<br><br>demo(<br>        ()-&gt; <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-number">10</span>),<br>        AtomicIntegerArray::length,<br>        AtomicIntegerArray::getAndIncrement,<br>        System.out::println<br>);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>]<br></code></pre></td></tr></table></figure>

<h3 id="7-字段更新器"><a href="#7-字段更新器" class="headerlink" title="7.字段更新器"></a>7.字段更新器</h3><p>保证<code>多线程</code>访问<code>同一个对象的成员变量</code>时, <code>成员变量的线程安全性</code>。</p>
<ul>
<li>AtomicReferenceFieldUpdater —引用类型的属性</li>
<li>AtomicIntegerFieldUpdater — 整形的属性</li>
<li>AtomicLongFieldUpdater — 长整型的属性</li>
</ul>
<p>注意：利用字段更新器，可以针对<code>对象的某个域（Field）进行原子操作</code>，只能<code>配合 volatile 修饰</code>的字段使用，否则会出现异常。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.AtomicFieldTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicFieldTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student stu = <span class="hljs-keyword">new</span> Student();<br>        <span class="hljs-comment">// 获得原子更新器</span><br>      	<span class="hljs-comment">// 泛型</span><br>      	<span class="hljs-comment">// 参数1 持有属性的类 参数2 被更新的属性的类</span><br>      	<span class="hljs-comment">// newUpdater中的参数：第三个为属性的名称</span><br>        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">// 期望的为null, 如果name属性没有被别的线程更改过, 默认就为null, 此时匹配, 就可以设置name为张三</span><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        System.out.println(updater.compareAndSet(stu, stu.name, <span class="hljs-string">&quot;王五&quot;</span>));<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br>Student&#123;name=<span class="hljs-string">&#x27;王五&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-原子累加器（LongAddr）（重要）"><a href="#8-原子累加器（LongAddr）（重要）" class="headerlink" title="8.原子累加器（LongAddr）（重要）"></a>8.原子累加器（LongAddr）（重要）</h3><ul>
<li>LongAddr</li>
<li>LongAccumulator</li>
<li>DoubleAddr</li>
<li>DoubleAccumulator</li>
</ul>
<p><code>累加器性能比较 AtomicLong, LongAddr</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;----AtomicLong----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;----LongAdder----&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(() -&gt; <span class="hljs-keyword">new</span> LongAdder(), adder -&gt; adder.increment());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;<br>        T adder = adderSupplier.get();<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 4 个线程，每人累加 50 万</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500000</span>; j++) &#123;<br>                    action.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(t -&gt; t.start());<br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(adder + <span class="hljs-string">&quot; cost:&quot;</span> + (end - start) / <span class="hljs-number">1000_000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">----AtomicLong----<br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">646</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">707</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">689</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">713</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">657</span><br>----LongAdder----<br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">148</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">139</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">130</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">122</span><br><span class="hljs-number">20000000</span> cost:<span class="hljs-number">116</span><br></code></pre></td></tr></table></figure>

<p>LongAddr</p>
<ul>
<li><strong>性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</strong></li>
</ul>
<p>AtomicLong</p>
<ul>
<li><strong>之前AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS重试, 性能没有LongAdder高</strong></li>
</ul>
<h3 id="9-LongAdder原理（了解）"><a href="#9-LongAdder原理（了解）" class="headerlink" title="9.LongAdder原理（了解）"></a>9.LongAdder原理（了解）</h3><p><strong>原理之伪共享</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e1c53a0fb41d7d089e5ddcc71f1f2a0d.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>缓存行伪共享从<code>缓存</code>说起</li>
<li>缓存与内存的速度比较</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9d3df3ad5311a92ecf235ccf78584ca3.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b4d95b0315026ad343cda2dd2d2f3c2a.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>因为 <code>CPU 与 内存的速度差异很大</code>，需要靠<code>预读数据</code>至<strong>缓存</strong>来提升效率。而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<strong>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</strong></li>
<li>CPU 要保证数据的<strong>一致性</strong> (缓存一致性)，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/56de3a77bb6f96ba480f622083864c36.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p>
<ul>
<li>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</li>
<li>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</li>
</ul>
<p><strong>累加主要调用以下方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;<br>       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;<br>       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;<br>           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;<br>           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||<br>               !(uncontended = a.cas(v = a.value, v + x)))<br>               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>累加流程图</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ce399f7bd72da53a22f6fbaba896dcc1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="10-Unsafe（重点）"><a href="#10-Unsafe（重点）" class="headerlink" title="10.Unsafe（重点）"></a>10.Unsafe（重点）</h3><ul>
<li>Unsafe对象提供了非常底层的，操作内存、线程的方法，Unsafe对象不能直接调用，只能通过<code>反射</code>获得</li>
<li>可以发现<code>AtomicInteger</code>以及其他的原子类、底层都使用的是Unsafe类</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201228125739963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>使用底层的<code>Unsafe</code>实现原子操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 通过反射获得Unsafe对象</span><br>        Class unsafeClass = Unsafe.class;<br>        <span class="hljs-comment">// 获得构造函数，Unsafe的构造函数为私有的</span><br>        Constructor constructor = unsafeClass.getDeclaredConstructor();<br>        <span class="hljs-comment">// 设置为允许访问私有内容</span><br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 创建Unsafe对象</span><br>        Unsafe unsafe = (Unsafe) constructor.newInstance();<br><br>        <span class="hljs-comment">// 创建Person对象</span><br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        <span class="hljs-comment">// 获得其属性 name 的偏移量</span><br>        <span class="hljs-keyword">long</span> nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-keyword">long</span> ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br><br>        <span class="hljs-comment">// 通过unsafe的CAS操作改变值</span><br>        unsafe.compareAndSwapObject(person, nameOffset, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;guizy&quot;</span>);<br>        unsafe.compareAndSwapInt(person, ageOffset, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 配合CAS操作，必须用volatile修饰</span><br>    <span class="hljs-keyword">volatile</span> String name;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本章重点讲解</p>
<ol>
<li>CAS 与 volatile</li>
<li>juc 包下 API<ol>
<li>原子整数</li>
<li>原子引用</li>
<li>原子数组</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ol>
</li>
<li>Unsafe</li>
<li>原理方面<ol>
<li>LongAdder 源码</li>
<li>伪共享</li>
</ol>
</li>
</ol>
<h2 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h2><h3 id="一、日期转换的问题"><a href="#一、日期转换的问题" class="headerlink" title="一、日期转换的问题"></a>一、日期转换的问题</h3><p>问题提出，下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的，有很大几率出现java.lang.NumberFormatException 或者出现不正确的日期解析结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="hljs-string">&quot;1951-04-21&quot;</span>));<br>              &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  log.error(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, e);<br>              &#125;<br>          &#125;).start();<br>      &#125;<br></code></pre></td></tr></table></figure>

<p><strong>思路-不可变对象</strong></p>
<p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改</p>
<ul>
<li><code>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</code> </li>
</ul>
<p>不可变</p>
<ul>
<li>如果一个对象在<strong>不能够修改其内部状态（属性）</strong>，那么他就是<strong>线程安全</strong>的，<code>因为不存在并发修改</code></li>
</ul>
<p>例如在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            LocalDate date = dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::from);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201229214014754.png" srcset="/img/loading.gif" lazyload></p>
<p>不可变对象，实际是另一种避免竞争的方式</p>
<h3 id="二、不可变类设计String"><a href="#二、不可变类设计String" class="headerlink" title="二、不可变类设计String"></a>二、不可变类设计String</h3><p>String类中不可变的体现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];	<span class="hljs-comment">// 在JDK9 使用了byte[] 数组</span><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-final的使用"><a href="#1-final的使用" class="headerlink" title="1.final的使用"></a>1.final的使用</h4><ul>
<li><strong>Integer、Double、String、DateTimeFormatter以及基本类型包装类，都是使用final来修饰的</strong></li>
<li>发现该类、类中所有属性都是final的，属性用final修饰保证了该属性是只读的，不能修改，<strong>类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</strong></li>
</ul>
<h5 id="1-1保护性拷贝"><a href="#1-1保护性拷贝" class="headerlink" title="1.1保护性拷贝"></a>1.1保护性拷贝</h5><ul>
<li>使用字符串时，也有一些跟修改相关的方法，比如substring、replace等，以substring实现为例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(endIndex);<br>    &#125;<br>    <span class="hljs-keyword">int</span> subLen = endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>    &#125;<br>    <span class="hljs-comment">// 上面是一些校验，下面才是真正的创建新的String对象</span><br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-keyword">this</span><br>            : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>发现其方法最后是调用String的构造方法创建了一个新字符串，<strong>在进入这个构造看，是否对final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的char[] value,对内容进行复制</strong></li>
<li>这种通过创建副本对象来避免共享的手段称为【保护性拷贝】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-keyword">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>    &#125;<br>    <span class="hljs-comment">// 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值</span><br>    <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-final原理"><a href="#2-final原理" class="headerlink" title="2.final原理"></a>2.final原理</h4><ul>
<li>设置final变量的原理<ul>
<li>理解了volatile原理（读写屏障），在对比final的实现就比较简单了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinal</span> </span>&#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>; <br> &#125;<br></code></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: aload_0<br>1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">4</span>: aload_0<br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span><br>7: putfield #2 // Field a:I<br> &lt;-- 写屏障<br><span class="hljs-number">10</span>: retu<br></code></pre></td></tr></table></figure>

<ul>
<li>发现final变量的赋值也会通过<strong>putfield</strong>指令来完成，同样在这条指令之后也会加入写屏障，<strong>保证在其他线程读到它的值时不会出现为0的情况。</strong></li>
</ul>
<h3 id="三、享元设计模式"><a href="#三、享元设计模式" class="headerlink" title="三、享元设计模式"></a>三、享元设计模式</h3><ul>
<li>简介定义英文名称：Flyweight pattern, <strong>重用数量有限的同一类对象</strong><ul>
<li>结构型模式</li>
</ul>
</li>
<li>享元模式的体现<ul>
<li>1.在JDK中<code>Boolean，Byte，Short，Integer，Long，Character</code>等包装类提供了<code>valueOf</code>方法，例如 Long 的<code>valueOf</code>会缓存<code>-128~127</code>之间的 Long 对象，<strong>在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-keyword">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Long(l);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>Byte, Short, Long 缓存的范围都是-128-127</li>
<li>Character 缓存的范围是 0-127</li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
<li>Integer的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 “-Djava.lang.Integer.IntegerCache.high “来改变</li>
<li>2、String串池</li>
<li>3、BigDecimal、BigInteger</li>
</ul>
<h4 id="1-实现一个简单的连接池"><a href="#1-实现一个简单的连接池" class="headerlink" title="1.实现一个简单的连接池"></a>1.实现一个简单的连接池</h4><ul>
<li>例如：<strong>一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Description: 简易连接池</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guizy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/12/29 21:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">/*使用连接池*/</span><br>        Pool pool = <span class="hljs-keyword">new</span> Pool(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                Connection conn = pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;guizy.Pool&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pool</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br><br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><br>    <span class="hljs-comment">// 3. 连接状态数组: 0 表示空闲, 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.connections = <span class="hljs-keyword">new</span> Connection[poolSize];<br>        <span class="hljs-keyword">this</span>.states = <span class="hljs-keyword">new</span> AtomicIntegerArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[poolSize]);<span class="hljs-comment">//使用AtomicIntegerArray保证states的线程安全</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> MockConnection(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">borrow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<span class="hljs-comment">//使用compareAndSet保证线程安全</span><br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待, 如果不写这个synchronized,其他线程不会进行等待, </span><br>            <span class="hljs-comment">// 一直在上面while(true), 空转, 消耗cpu资源</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(Connection conn)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-keyword">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Connection</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MockConnection</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Connection 实现方法略</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">0</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.005</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.000</span> guizy.Pool [Thread-<span class="hljs-number">1</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.006</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">0</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.099</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.581</span> guizy.Pool [Thread-<span class="hljs-number">3</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.582</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.582</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - wait...<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.617</span> guizy.Pool [Thread-<span class="hljs-number">1</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.618</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">07.955</span> guizy.Pool [Thread-<span class="hljs-number">4</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">01</span>:<span class="hljs-number">08.552</span> guizy.Pool [Thread-<span class="hljs-number">2</span>] - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201229220417401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JUC/">JUC</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JUC/">JUC</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A%E7%AF%87-Synchronized%E5%8E%9F%E7%90%86-LockSupport%E5%8E%9F%E7%90%86-ReentrantLock%E5%8E%9F%E7%90%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java并发编程上篇 - (Synchronized原理,LockSupport原理,ReentrantLock原理)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/23/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/">
                        <span class="hidden-mobile">JVM学习笔记4</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.lazyComments('valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#valine",
          app_id: "99lfyqRg3CLazXoohVQjMwH3-gzGzoHsz",
          app_key: "qx9rFQuqjhuegpH6AwJ8B0eD",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: true,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
